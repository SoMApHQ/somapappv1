<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-analytics-compat.js"></script>
  <script src="somapappv1multischool/js/context.js"></script>
  <script src="Todashboardhtml/yearContext.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-storage-compat.js"></script>
  <script src="firebase.js"></script>
  <script src="js/finance_core.js"></script>
  <script src="js/finance_dedupe.js"></script>
  <title>SoMAp - Finance</title>

  <!-- UI -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>

  <!-- Exports -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.0/jspdf.plugin.autotable.min.js"></script>

  <style>
    body { background: #f8fafc; }
    .table-header { background: #eef2ff; color: #1f2937; }
    .table-row:nth-child(even) { background: #ffffff; }
    .modal { display:none; position:fixed; inset:0; background: rgba(0,0,0,0.5); z-index:1000; }
    .modal-content { background:#fff; max-width:800px; margin:4% auto; padding:18px; border-radius:8px; height:80vh; overflow:auto; }
    .expander { cursor: pointer; transition: transform .2s ease; }
    .expander .fa { transition: transform .2s ease; }
    .expander.open .fa { transform: rotate(180deg); }
    .status-pill { padding:2px 8px; border-radius:999px; font-size: 11px; font-weight:600; }
    .status-paid { background:#dcfce7; color:#166534; }
    .status-partial { background:#fef9c3; color:#854d0e; }
    .status-overdue { background:#fee2e2; color:#991b1b; }
    /* tiny shimmer used before iframe mounts */
    .skel { position: relative; overflow: hidden; background: #f1f5f9; }
    .skel::after {
      content: ""; position:absolute; inset:0;
      background: linear-gradient(90deg, rgba(241,245,249,0) 0%, rgba(226,232,240,.8) 50%, rgba(241,245,249,0) 100%);
      transform: translateX(-100%); animation: shimmer 1.2s infinite;
    }
    @keyframes shimmer { 100% { transform: translateX(100%); } }
  </style>
</head>

<body class="p-6">
  <div class="max-w-6xl mx-auto">
    <header class="mb-6 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
      <div class="flex flex-col">
        <h1 class="text-2xl font-semibold text-indigo-700">
          SoMAp Finance
          <span id="financeSchoolLabel" class="ml-2 inline-flex items-center px-3 py-1 rounded-full bg-indigo-50 text-indigo-700 border border-indigo-100 text-xs font-semibold"></span>
        </h1>
        <p class="mt-1 text-sm font-medium text-indigo-600/80">
          Working year: <span id="financeYearLabel">--</span>
          <span class="ml-3 text-slate-600">Students: <span id="financeStudentCount" class="font-semibold text-slate-900">--</span></span>
        </p>
      </div>
      <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:gap-3">
        <label class="flex items-center gap-2 rounded-lg border border-indigo-200 bg-indigo-50/70 px-3 py-1 text-xs font-semibold uppercase tracking-wide text-indigo-700">
          <span class="hidden sm:inline text-[0.7rem]">Academic Year</span>
          <select
            data-somap-year-select
            class="min-w-[120px] rounded-md border border-indigo-200 bg-white px-2 py-1 text-sm font-medium text-indigo-700 focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-200"
          >
          </select>
        </label>
        <button id="reloadBtn" class="px-3 py-1 bg-indigo-600 text-white rounded">Reload</button>
        <a href="index.html" class="px-3 py-1 border rounded text-sm">Back to Dashboard</a>
      </div>
    </header>

    <!-- KPIs -->
    <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-6">
      <div class="bg-white p-4 rounded shadow">
        <h3 class="text-sm text-gray-500">Total Due (All Students)</h3>
        <div id="totalDue" class="text-xl font-semibold mt-2">--</div>
      </div>
      <div class="bg-white p-4 rounded shadow">
        <h3 class="text-sm text-gray-500">Total Collected</h3>
        <div id="totalCollected" class="text-xl font-semibold mt-2">--</div>
      </div>
      <div class="bg-white p-4 rounded shadow">
        <h3 class="text-sm text-gray-500">Total Outstanding (Due – Collected)</h3>
        <div id="totalOutstanding" class="text-xl font-semibold mt-2">--</div>
      </div>
      <div class="bg-white p-4 rounded shadow">
        <h3 class="text-sm text-gray-500">Total Expenses</h3>
        <div id="totalExpenses" class="text-xl font-semibold mt-2">--</div>
      </div>
      <div class="bg-white p-4 rounded shadow">
        <h3 class="text-sm text-gray-500">Net Balance (Collected - Expenses)</h3>
        <div id="netBalance" class="text-xl font-semibold mt-2">--</div>
      </div>
      <a id="financialStatementsCard" href="Tofinancehtml/financialstatements/fs_dashboard.html" class="bg-gradient-to-br from-indigo-600 to-emerald-500 p-4 rounded shadow text-white flex flex-col justify-between">
        <div>
          <h3 class="text-sm font-semibold">Financial Statements</h3>
          <p class="text-xs text-indigo-50 mt-1">Prepare TRA-ready P&L, Balance Sheet, Cash Flow.</p>
        </div>
        <span class="mt-3 inline-flex items-center text-sm font-semibold">Open module <i class="fa fa-arrow-right ml-2"></i></span>
      </a>
    </div>

    <!-- Filters + actions -->
    <div class="flex items-center justify-between mb-4">
      <div class="flex items-center gap-3">
        <label class="text-sm text-gray-600">Filter by class</label>
        <select id="classFilter" class="p-2 border rounded"></select>
        <button id="showOnlyDebtors" class="px-3 py-1 bg-yellow-500 text-white rounded text-sm">Show Debtors</button>
      </div>
      <div class="flex items-center gap-2">
        <button id="downloadCsv" class="px-3 py-1 bg-indigo-600 text-white rounded"><i class="fa fa-file-excel mr-1"></i> Main CSV</button>
        <button id="downloadPdf" class="px-3 py-1 bg-red-600 text-white rounded"><i class="fa fa-file-pdf mr-1"></i> Main PDF</button>
        <button id="downloadDebtNowCsv" class="px-3 py-1 bg-amber-600 text-white rounded"><i class="fa fa-file-excel mr-1"></i> Debt (current) CSV</button>
        <button id="downloadDebtNowPdf" class="px-3 py-1 bg-amber-700 text-white rounded"><i class="fa fa-file-pdf mr-1"></i> Debt (current) PDF</button>
        <button id="downloadBreakdownCsv" class="px-3 py-1 bg-teal-600 text-white rounded"><i class="fa fa-file-excel mr-1"></i> Breakdown CSV</button>
        <button id="downloadBreakdownPdf" class="px-3 py-1 bg-teal-700 text-white rounded"><i class="fa fa-file-pdf mr-1"></i> Breakdown PDF</button>
      </div>
    </div>

    <!-- Table -->
    <div class="bg-white rounded shadow overflow-x-auto">
      <table id="financeTable" class="min-w-full text-sm">
        <thead>
          <tr class="table-header">
            <th class="p-2 border"></th>
            <th class="p-2 border">Admission No</th>
            <th class="p-2 border">Full Name</th>
            <th class="p-2 border">Class</th>
            <th class="p-2 border">Fee (year)</th>
            <th class="p-2 border">Payment Plan</th>
            <th class="p-2 border">Paid</th>
            <th class="p-2 border">Balance (Year)</th>
            <th class="p-2 border">Debt till …</th>
            <th class="p-2 border">Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Expenses -->
    <div class="bg-white rounded shadow p-4 mt-6">
      <h2 class="text-lg font-semibold text-indigo-700 mb-3">Expenses</h2>
      <form id="expenseForm" class="grid md:grid-cols-5 gap-3 mb-4">
        <select id="expenseCategory" required class="p-2 border rounded">
          <option value="">Select Category</option>
          <option>FOOD</option>
          <option>SALARIES</option>
          <option>OFFICE</option>
          <option>EDUCATION</option>
          <option>WATER & ELECTRICITY</option>
          <option>SANITATION</option>
          <option>ENVIRONMENT</option>
          <option>HEALTH</option>
          <option>SECURITY</option>
          <option>CLOTHING</option>
          <option>SHELTER</option>
          <option>RECREATION</option>
          <option>PROJECTS</option>
          <option>TRANSPORT</option>
          <option>PURCHASES</option>
          <option>SIL</option>
          <option>MAINTENANCE</option>
          <option>BOOKS</option>
          <option>EMERGENCY</option>
          <option>MISCELLANEOUS</option>
        </select>
        <input id="expenseDescription" type="text" placeholder="Description" required class="p-2 border rounded">
        <input id="expenseAmount" type="number" min="1" placeholder="Amount" required class="p-2 border rounded">
        <input id="expenseDate" type="date" required class="p-2 border rounded">
        <button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded">Add Expense</button>
      </form>
      <div class="flex items-center gap-2 mb-3">
        <button id="downloadExpenseCsv" class="px-3 py-1 bg-green-600 text-white rounded">Download Expense Report (CSV)</button>
        <button id="downloadExpensePdf" class="px-3 py-1 bg-red-600 text-white rounded">Download Expense Report (PDF)</button>
      </div>
      <table id="expenseTable" class="min-w-full text-sm border">
        <thead>
          <tr class="table-header">
            <th class="p-2 border">Category</th>
            <th class="p-2 border">Description</th>
            <th class="p-2 border">Amount</th>
            <th class="p-2 border">Date</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Payment modal -->
    <div id="paymentModal" class="modal">
      <div class="modal-content">
        <span id="closePaymentModal" class="float-right cursor-pointer text-2xl">&times;</span>
        <h2 class="text-lg font-semibold text-indigo-700 mb-3">Record Payment</h2>
        <form id="paymentForm" class="space-y-3">
          <div>
            <label class="text-sm text-gray-600">Student</label>
            <select id="studentSelect" class="w-full p-2 border rounded" required></select>
          </div>
          <div>
            <label class="text-sm text-gray-600">Amount</label>
            <input id="paymentAmount" type="number" step="1" min="1" class="w-full p-2 border rounded" required />
          </div>
          <div>
            <label class="text-sm text-gray-600">Payment Date</label>
            <input id="paymentDate" type="date" class="w-full p-2 border rounded" required />
          </div>
          <div>
            <label class="text-sm text-gray-600">Method</label>
            <select id="paymentMethod" class="w-full p-2 border rounded">
              <option>Cash</option>
              <option>MPesa</option>
              <option>Airtel Money</option>
              <option>TigoPesa</option>
              <option>Bank Transfer</option>
              <option>Other</option>
            </select>
          </div>
          <div>
            <label class="text-sm text-gray-600">Reference Code (MPesa / Receipt / Bank)</label>
            <input id="paymentReference" type="text" class="w-full p-2 border rounded" placeholder="e.g. MPESA1ABC23" />
          </div>
          <div>
            <label class="text-sm text-gray-600">Paid By (Name)</label>
            <input id="paymentPaidBy" type="text" class="w-full p-2 border rounded" placeholder="e.g. Parent name or Admin name" required />
          </div>
          <div>
            <label class="text-sm text-gray-600">Contact of Payer</label>
            <input id="paymentPayerContact" type="tel" class="w-full p-2 border rounded" placeholder="e.g. +255..." required />
          </div>
          <div>
            <label class="text-sm text-gray-600">Note (optional)</label>
            <input id="paymentNote" type="text" class="w-full p-2 border rounded" />
          </div>
          <div class="flex space-x-2">
            <button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded">Save Payment</button>
            <button id="cancelPayment" type="button" class="px-4 py-2 border rounded">Cancel</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Details modal -->
    <div id="detailsModal" class="modal">
      <div class="modal-content">
        <span id="closeDetailsModal" class="float-right cursor-pointer text-2xl">&times;</span>
        <h2 class="text-lg font-semibold text-indigo-700 mb-3">Student Finance Details</h2>
        <div id="detailsContent"></div>
      </div>
    </div>
  </div>

<script>
(function () {
  /* ===== Parent mode detection (non-destructive) ===== */
  const parentCtx = { enabled:false, studentId:null, adm:null, year:null, className:null };
  (function detectParentMode(){
    const q = new URLSearchParams(location.search);
    const scope = (q.get('scope')||'').toLowerCase();
    if (scope === 'parent') {
      parentCtx.enabled  = true;
      parentCtx.studentId= q.get('student');
      parentCtx.adm      = q.get('adm');
      parentCtx.year     = q.get('year');
      parentCtx.className= q.get('class');
      try {
        sessionStorage.setItem('parent_scope','1');
        if (parentCtx.studentId) sessionStorage.setItem('parent_student', parentCtx.studentId);
        if (parentCtx.adm)       sessionStorage.setItem('parent_adm', parentCtx.adm);
        if (parentCtx.year)      sessionStorage.setItem('parent_year', parentCtx.year);
        if (parentCtx.className) sessionStorage.setItem('parent_class', parentCtx.className);
      } catch(_) {}
    } else if (sessionStorage.getItem('parent_scope') === '1') {
      parentCtx.enabled   = true;
      parentCtx.studentId = sessionStorage.getItem('parent_student');
      parentCtx.adm       = sessionStorage.getItem('parent_adm');
      parentCtx.year      = sessionStorage.getItem('parent_year');
      parentCtx.className = sessionStorage.getItem('parent_class');
    }
  })();

  const SOMAP_DEFAULT_YEAR = 2025;
  const CARRY_FORWARD_START_YEAR = 2025;
  const FINANCE_ADMIN_EMAIL = 'socratesschool2020@gmail.com';
  const CLASS_ORDER = ['Baby Class','Middle Class','Pre Unit Class','Class 1','Class 2','Class 3','Class 4','Class 5','Class 6','Class 7'];
  const norm = (s) => String(s || '').trim().toLowerCase();
  function canonClass(name) {
    const n = norm(name);
    if (!n) return '';
    if (n === 'pre unit' || n === 'preunit' || n === 'pre-unit' || n === 'pre unit class') return 'Pre Unit Class';
    if (n === 'baby' || n === 'baby class') return 'Baby Class';
    if (n === 'middle' || n === 'middle class') return 'Middle Class';
    const m = n.match(/^class\s*(\d+)$/);
    if (m) return `Class ${m[1]}`;
    if (n === 'graduated') return 'GRADUATED';
    return String(name || '').trim();
  }
  function shiftClass(baseName, deltaYears) {
    const base = canonClass(baseName);
    const i = CLASS_ORDER.findIndex((c) => norm(c) === norm(base));
    if (i < 0) return base || '';
    const j = i + Number(deltaYears || 0);
    if (j < 0) return 'PRE-ADMISSION';
    if (j >= CLASS_ORDER.length) return 'GRADUATED';
    return CLASS_ORDER[j];
  }

  function resolveFinanceSchoolId() {
    if (window.currentSchoolId) return window.currentSchoolId;
    const params = new URLSearchParams(location.search || '');
    const candidate = params.get('school') || params.get('schoolId') || (function () {
      try { return localStorage.getItem('somap_school'); } catch (_) { return ''; }
    })() || 'socrates';
    const normalized = String(candidate || '').trim() || 'socrates';
    window.currentSchoolId = normalized;
    return normalized;
  }

  const db = window.db || null;
  const currentSchool = window.SOMAP && SOMAP.getSchool();
  if (!currentSchool || !currentSchool.id) {
    window.location.href = "somapappv1multischool/multischool.html";
  }
  window.currentSchoolId = currentSchool?.id;
  const financeSchoolLabel = document.getElementById('financeSchoolLabel');
  if (financeSchoolLabel) {
    financeSchoolLabel.textContent = currentSchool.name || currentSchool.code || currentSchool.id || 'School';
  }

  function schoolRef(subPath) {
    return db.ref(SOMAP.P(subPath));
  }
  const yearContext = window.somapYearContext || null;
  const yearSelectEl = document.querySelector('[data-somap-year-select]');
  const financeQuery = new URLSearchParams(location.search);
  let financeYear = financeQuery.get('year')
    || (yearContext?.getSelectedYear?.())
    || (() => { try { return sessionStorage.getItem('somap_selected_year'); } catch (_) { return null; } })()
    || SOMAP_DEFAULT_YEAR;
  financeYear = String(financeYear);
  let activeYear = financeYear;
  const activeSchoolId = resolveFinanceSchoolId();
  try { sessionStorage.setItem('somap_selected_year', financeYear); } catch (_) {}
  if (yearContext?.setSelectedYear) {
    yearContext.setSelectedYear(financeYear, { manual: false });
  }
  if (yearSelectEl) {
    yearSelectEl.value = financeYear;
    yearSelectEl.addEventListener('change', (e) => {
      const newYear = String(e.target.value || SOMAP_DEFAULT_YEAR);
      if (newYear === financeYear) return;
      financeYear = newYear;
      activeYear = newYear;
      try { sessionStorage.setItem('somap_selected_year', newYear); } catch (_) {}
      refreshFinanceData(newYear);
      window.somapYearContext?.setSelectedYear?.(newYear);
    });
  }

  function hasFinanceAdminAccess() {
    try {
      const role = sessionStorage.getItem('somap_role');
      if (role && String(role).toLowerCase() === 'admin') return true;
    } catch (_) {}
    const emails = [];
    if (window.currentUserEmail) emails.push(window.currentUserEmail);
    try {
      const stored = sessionStorage.getItem('somapUserEmail');
      if (stored) emails.push(stored);
    } catch (_) {}
    try {
      const storedLegacy = sessionStorage.getItem('userEmail');
      if (storedLegacy) emails.push(storedLegacy);
    } catch (_) {}
    try {
      const authEmail = firebase?.auth?.()?.currentUser?.email;
      if (authEmail) emails.push(authEmail);
    } catch (_) {}
    return emails.some((email) => String(email).toLowerCase() === FINANCE_ADMIN_EMAIL.toLowerCase());
  }

  const tbody = document.querySelector('#financeTable tbody');
  const studentSelect = document.getElementById('studentSelect');
  const paymentModal = document.getElementById('paymentModal');
  const closePaymentModal = document.getElementById('closePaymentModal');
  const paymentForm = document.getElementById('paymentForm');
  const cancelPayment = document.getElementById('cancelPayment');
  const detailsModal = document.getElementById('detailsModal');
  const closeDetailsModal = document.getElementById('closeDetailsModal');
  const detailsContent = document.getElementById('detailsContent');
  const CLASS_FILTERS = ['All Classes','Baby Class','Middle Class','Pre Unit','Pre Unit Class','Class 1','Class 2','Class 3','Class 4','Class 5','Class 6','Class 7'];
  const classFilter = document.getElementById('classFilter');
  const showOnlyDebtorsBtn = document.getElementById('showOnlyDebtors');
  const yearHint = document.getElementById('financeYearLabel');
  const downloadCsvBtn = document.getElementById('downloadCsv');
  const downloadPdfBtn = document.getElementById('downloadPdf');
  const downloadDebtNowCsvBtn = document.getElementById('downloadDebtNowCsv');
  const downloadDebtNowPdfBtn = document.getElementById('downloadDebtNowPdf');
  const downloadBreakdownCsvBtn = document.getElementById('downloadBreakdownCsv');
  const downloadBreakdownPdfBtn = document.getElementById('downloadBreakdownPdf');
  const reloadBtn = document.getElementById('reloadBtn');

  let cachedStudents = {};
  let financeAggregateSnapshot = { totalStudents: 0, totalDue: 0, totalCollected: 0, totalOutstanding: 0, totalExpenses: 0 };
  function lookupStudentByAdmission(adm) {
    const normalized = String(adm || '').trim();
    if (!normalized) return null;
    if (cachedStudents[normalized]) {
      return { id: normalized, student: cachedStudents[normalized] };
    }
    const matchKey = Object.keys(cachedStudents || {}).find((key) => {
      const entry = cachedStudents[key] || {};
      return String(entry.admissionNumber || entry.admissionNo || key).trim() === normalized;
    });
    if (!matchKey) return null;
    return { id: matchKey, student: cachedStudents[matchKey] };
  }
  window.__finance_lookupStudent = lookupStudentByAdmission;
  let showingDebtorsOnly = false;

  populateClassFilterDropdown();

  function populateClassFilterDropdown() {
    if (!classFilter) return;
    const currentValue = classFilter.value || '';
    classFilter.innerHTML = '';
    CLASS_FILTERS.forEach((label, idx) => {
      const option = document.createElement('option');
      option.value = idx === 0 ? '' : label;
      option.textContent = label;
      classFilter.appendChild(option);
    });
    if (currentValue) {
      const exists = Array.from(classFilter.options).some(opt => opt.value === currentValue);
      classFilter.value = exists ? currentValue : '';
    } else {
      classFilter.value = '';
    }
  }

  function updateYearHint() {
    if (yearHint) yearHint.textContent = `${financeYear}`;
  }

  if (!db) {
    console.error('DB not found.');
    alert('DB not ready. Ensure firebase.js initializes window.db.');
  }

  // ===== Helpers (kept as-is) =====
  function fmt(n) { n = Number(n) || 0; return n.toLocaleString(); }
  function parseMoney(value) {
    if (value == null) return 0;
    if (typeof value === 'number') return Number.isFinite(value) ? value : 0;
    if (typeof value === 'string') {
      const cleaned = value.replace(/[^\d.-]/g, '');
      const parsed = Number(cleaned);
      return Number.isFinite(parsed) ? parsed : 0;
    }
    return 0;
  }
  function clamp(n) { return Math.max(0, Math.round(parseMoney(n))); }
  function todayYMD() {
    const now = new Date();
    const selectedYear = Number(financeYear);
    return {
      y: Number.isFinite(selectedYear) ? selectedYear : now.getFullYear(),
      m: now.getMonth() + 1,
      d: now.getDate(),
    };
  }
  function dateFromYMD(y, m, d) { return new Date(y, m - 1, d).getTime(); }
  function isPast(ts) { return Date.now() > ts; }
  function apportion(total, weights) {
    if (!weights.length) return [];
    const sumW = weights.reduce((a, b) => a + b, 0);
    let amounts = weights.map(w => Math.floor((w * total) / sumW));
    let sumA = amounts.reduce((a, b) => a + b, 0);
    let rem = total - sumA;
    if (rem > 0) {
      const sortedIdx = [...weights.keys()].sort((a, b) => weights[b] - weights[a]);
      for (let i = 0; i < rem; i++) amounts[sortedIdx[i % sortedIdx.length]]++;
    }
    return amounts;
  }

  // ===== Installment config (DISCOUNTS REMOVED) =====
  const installmentConfigs = {
    lower: {
      type: '6',
      weights: [44, 13, 12, 22, 22, 16],
      labels: ['Inst 1', 'Inst 2', 'Inst 3', 'Inst 4', 'Inst 5', 'Inst 6'],
      windows: [
        { from: [12, 1], to: [1, 10] },
        { from: [3, 1], to: [3, 15] },
        { from: [4, 1], to: [4, 15] },
        { from: [5, 1], to: [5, 15] },
        { from: [7, 1], to: [7, 15] },
        { from: [9, 1], to: [9, 15] },
      ]
    },
    class4_7: {
      type: '4',
      weights: [27, 20, 20, 15],
      labels: ['Inst 1', 'Inst 2', 'Inst 3', 'Inst 4'],
      windows: [
        { from: [12, 1], to: [1, 10] },
        { from: [3, 1], to: [3, 15] },
        { from: [4, 1], to: [4, 15] },
        { from: [5, 1], to: [5, 15] },
      ]
    },
    class5: {
      type: '6',
      weights: [44, 23, 22, 32, 26, 17],
      labels: ['Inst 1', 'Inst 2', 'Inst 3', 'Inst 4', 'Inst 5', 'Inst 6'],
      windows: [
        { from: [12, 1], to: [1, 10] },
        { from: [3, 1], to: [3, 15] },
        { from: [4, 1], to: [4, 15] },
        { from: [5, 1], to: [5, 15] },
        { from: [7, 1], to: [7, 15] },
        { from: [9, 1], to: [9, 15] },
      ]
    },
    class6: {
      type: '6',
      weights: [236, 115, 110, 160, 160, 100],
      labels: ['Inst 1', 'Inst 2', 'Inst 3', 'Inst 4', 'Inst 5', 'Inst 6'],
      windows: [
        { from: [12, 1], to: [1, 10] },
        { from: [3, 1], to: [3, 15] },
        { from: [4, 1], to: [4, 15] },
        { from: [5, 1], to: [5, 15] },
        { from: [7, 1], to: [7, 15] },
        { from: [9, 1], to: [9, 15] },
      ]
    },
    monthly: {
      type: 'monthly',
      weights: [2, 1, 1, 1, 1, 1, 2, 1, 1, 1],
      labels: ['Jan (2 months)', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul (2 months)', 'Aug', 'Sep', 'Oct'],
      windows: [
        { from: [1, 1], to: [1, 31] },
        { from: [2, 1], to: [2, 28] },
        { from: [3, 1], to: [3, 31] },
        { from: [4, 1], to: [4, 30] },
        { from: [5, 1], to: [5, 31] },
        { from: [6, 1], to: [6, 30] },
        { from: [7, 1], to: [7, 31] },
        { from: [8, 1], to: [8, 31] },
        { from: [9, 1], to: [9, 30] },
        { from: [10, 1], to: [10, 31] },
      ]
    },
    '2inst': {
      type: '2',
      // discount removed
      weights: [1, 1],
      labels: ['1st Half', '2nd Half'],
      windows: [
        { from: [1, 1], to: [1, 10] },
        { from: [7, 1], to: [7, 5] },
      ]
    },
    full: {
      type: 'full',
      // discount removed
      weights: [1],
      labels: ['Full Year'],
      windows: [
        { from: [1, 1], to: [1, 10] },
      ]
    }
  };

  function getConfig(student) {
    const plan = (student.paymentPlan || '').toLowerCase();
    const c = (student.classLevel || '').toLowerCase();
    if (plan.includes('monthly')) return installmentConfigs.monthly;
    if (plan.includes('2')) return installmentConfigs['2inst'];
    if (plan.includes('full')) return installmentConfigs.full;
    if (plan.includes('4') || (plan.includes('inst') && (c === 'class 4' || c === 'class 7'))) return installmentConfigs.class4_7;
    if (plan.includes('inst')) {
      if (c === 'class 1' || c === 'class 2' || c === 'class 3') return installmentConfigs.lower;
      if (c === 'class 5') return installmentConfigs.class5;
      if (c === 'class 6') return installmentConfigs.class6;
    }
    return installmentConfigs.full;
  }

  function buildSchedule(student) {
    if (!student || student.isGraduated) {
      return { items: [], periodLabelNow: '-', expectedToDate: 0 };
    }
    const { y } = todayYMD();

    // 1) Student-level custom schedule wins
    if (Array.isArray(student._customSchedule) && student._customSchedule.length) {
      const sc = student._customSchedule
        .filter(it => it && it.label && it.from && it.to)
        .map((it, idx) => ({
          key: `custom${idx+1}`,
          label: String(it.label || 'Item'),
          fromTS: new Date(it.from).getTime() || 0,
          toTS: new Date(it.to).getTime() || 0,
          amount: Math.max(0, Math.round(Number(it.amount) || 0)),
          paidAllocated: 0,
          status: 'Pending'
        }));
      let lastDueIndex = -1, periodLabel = '-', expectedToDate = 0;
      const now = Date.now();
      sc.forEach((it, idx) => { if (it.toTS < now) { lastDueIndex = idx; expectedToDate += it.amount; } });
      if (lastDueIndex >= 0) periodLabel = sc[lastDueIndex].label;
      return { items: sc, periodLabelNow: periodLabel, expectedToDate };
    }

    // 2) Year plan schedule (from installmentPlans/{y})
    if (Array.isArray(student._planSchedule) && student._planSchedule.length) {
      const baseFee = Math.max(0, Math.round(Number(student.baseFee ?? (student.feePerYear - (student.carryAmount || 0))) || 0));
      const carryAmount = Math.max(0, Number(student.carryAmount || 0));
      const weights = student._planSchedule.map(s => Math.max(0, Number(s.weight) || 0));
      const amounts = apportion(baseFee, weights);
      if (carryAmount > 0) {
        if (amounts.length) amounts[0] += carryAmount; else amounts.push(carryAmount);
      }
      const sc = student._planSchedule.map((s, i) => ({
        key: `inst${i+1}`,
        label: s.label || `Inst ${i+1}`,
        fromTS: s.from ? new Date(s.from).getTime() : 0,
        toTS: s.to ? new Date(s.to).getTime() : 0,
        amount: Math.max(0, amounts[i] || 0),
        paidAllocated: 0,
        status: 'Pending'
      }));
      let lastDueIndex = -1, periodLabel = '-', expectedToDate = 0;
      const now = Date.now();
      sc.forEach((it, idx) => { if (it.toTS < now) { lastDueIndex = idx; expectedToDate += it.amount; } });
      if (lastDueIndex >= 0) periodLabel = sc[lastDueIndex].label;
      return { items: sc, periodLabelNow: periodLabel, expectedToDate };
    }

    // 3) Fallback to existing static configs by class/plan
    const config = getConfig(student);
    const baseFee = Math.max(0, Math.round(Number(student.baseFee ?? (student.feePerYear - (student.carryAmount || 0))) || 0));
    const carryAmount = Math.max(0, Number(student.carryAmount || 0));
    const amounts = apportion(baseFee, config.weights);
    if (carryAmount > 0) {
      if (amounts.length) amounts[0] += carryAmount;
      else amounts.push(carryAmount);
    }
    const sc = [];
    config.labels.forEach((label, i) => {
      let fromY = y, toY = y;
      const fromM = config.windows[i].from[0], fromD = config.windows[i].from[1];
      const toM = config.windows[i].to[0], toD = config.windows[i].to[1];
      if (fromM === 12) fromY = y - 1;
      if (toM === 12) toY = y - 1;
      const fromTS = dateFromYMD(fromY, fromM, fromD);
      const toTS = dateFromYMD(toY, toM, toD);
      sc.push({ key: `inst${i + 1}`, label, fromTS, toTS, amount: amounts[i] || 0, paidAllocated:0, status:'Pending' });
    });
    let lastDueIndex = -1, periodLabel = '-', expectedToDate = 0;
    const now = Date.now();
    sc.forEach((it, idx) => { if (it.toTS < now) { lastDueIndex = idx; expectedToDate += it.amount; } });
    if (lastDueIndex >= 0) periodLabel = sc[lastDueIndex].label;
    return { items: sc, periodLabelNow: periodLabel, expectedToDate };
  }

  function allocatePayments(student, schedule) {
    const payList = [];
    if (student.payments) {
      Object.values(student.payments).forEach(p => {
        payList.push({ amount: clamp(p.amount), ts: Number(p.timestamp) || 0 });
      });
    }
    payList.sort((a, b) => a.ts - b.ts);
    let pot = payList.reduce((s, p) => s + p.amount, 0);
    const totalPaid = pot;
    let prevDebt = clamp(student.previousDebt || 0);
    let toPrev = Math.min(prevDebt, pot); prevDebt -= toPrev; pot -= toPrev;

    for (const it of schedule.items) {
      const need = Math.max(0, it.amount - it.paidAllocated);
      if (need <= 0) continue;
      if (pot <= 0) break;
      const use = Math.min(need, pot);
      it.paidAllocated += use;
      pot -= use;
    }
    const credit = Math.max(0, pot);
    const now = Date.now();
    for (const it of schedule.items) {
      const a = it.paidAllocated, need = it.amount;
      if (a >= need) it.status = 'Cleared';
      else if (isPast(it.toTS)) it.status = a > 0 ? 'Partially Paid (Overdue)' : 'Overdue';
      else it.status = a > 0 ? 'Partially Paid' : 'Pending';
    }
    const expectedToDate = schedule.items.filter(it => it.toTS < now).reduce((s, it) => s + it.amount, 0);
    const paidConsumed = totalPaid - credit;
    const debtTillNow = Math.max(0, expectedToDate - paidConsumed);
    return { scheduleItems: schedule.items, prevDebtAfter: prevDebt, credit, totalPaid, debtTillNow };
  }

  function computeStudentFinancials(student) {
    const feePerYear = Math.max(0, Number(student.feePerYear) || 0);
    const previousDebt = 0;
    const schedule = buildSchedule(student);
    const alloc = allocatePayments(student, schedule);
    const paidAfterPrev = Math.max(0, alloc.totalPaid - (previousDebt - alloc.prevDebtAfter));
    const yearBalance = Math.max(0, feePerYear - paidAfterPrev);
    return {
      feePerYear,
      previousDebt,
      paidAmount: alloc.totalPaid,
      balance: yearBalance,
      periodDebtLabel: schedule.periodLabelNow || '-',
      periodDebtValue: alloc.debtTillNow,
      credit: alloc.credit,
      scheduleItems: alloc.scheduleItems
    };
  }

  function normalizePayments(source, targetYear) {
    if (!source) return {};
    let bucket = source;
    if (source && typeof source === 'object' && !Array.isArray(source) && source.payments) {
      bucket = source.payments;
    }
    if (!bucket || typeof bucket !== 'object') return {};
    const normalized = {};
    const desiredYear = Number(targetYear);
    Object.entries(bucket).forEach(([key, raw]) => {
      if (raw == null) return;
      if (typeof raw === 'number' || typeof raw === 'string') {
        const amount = parseMoney(raw);
        if (!(amount > 0)) return;
        normalized[key] = {
          amount,
          timestamp: Date.now(),
          academicYear: Number.isFinite(desiredYear) ? desiredYear : undefined,
        };
        return;
      }
      const amount = parseMoney(raw.amount ?? raw.value ?? raw.paid ?? raw.payment ?? raw.total ?? 0);
      if (!(amount > 0)) return;
      const timestamp = Number(
        raw.timestamp ?? raw.datePaid ?? raw.createdAt ?? raw.updatedAt ?? raw.recordedAt ?? raw.time ?? Date.now()
      );
      let paymentYear = Number(
        raw.academicYear ??
        raw.financeYear ??
        raw.feeYear ??
        raw.year ??
        raw._year ??
        raw.academic_session
      );
      if (!Number.isFinite(paymentYear)) {
        const tsDate = new Date(timestamp);
        if (!Number.isNaN(tsDate.getTime())) paymentYear = tsDate.getFullYear();
      }
      if (Number.isFinite(desiredYear) && Number.isFinite(paymentYear) && paymentYear !== desiredYear) return;
      const payload = { ...raw, amount, timestamp };
      if (Number.isFinite(paymentYear)) payload.academicYear = paymentYear;
      else if (Number.isFinite(desiredYear)) payload.academicYear = desiredYear;
      normalized[key] = payload;
    });
    return normalized;
  }

function buildFinanceStudents(
  baseStudents = {},
  anchorEnrollments = {},
  enrollments = {},
  classFees = {},
  overrides = {},
  plans = {},
  ledgers = {},
  carryForward = {},
  studentFees = {},
  approvalsByStudent = {},
  year = activeYear
) {
    const targetYear = String(year || activeYear || SOMAP_DEFAULT_YEAR);
    const targetYearNum = Number(targetYear);
    const anchorYearNum = Number(SOMAP_DEFAULT_YEAR);

    const isNonEmptyObj = (o) => o && typeof o === 'object' && !Array.isArray(o) && Object.keys(o).length > 0;
    const hasPaymentsForYear = (paymentsObj, yNum) => {
      if (!paymentsObj || typeof paymentsObj !== 'object') return false;
      return Object.values(paymentsObj).some((p) => {
        if (!p) return false;
        const ay = Number(p.academicYear ?? p.financeYear ?? p.year);
        if (Number.isFinite(ay) && ay === yNum) return true;
        const ts = Number(p.timestamp ?? p.datePaid ?? p.createdAt);
        if (Number.isFinite(ts)) {
          const dt = new Date(ts);
          if (!Number.isNaN(dt.getTime()) && dt.getFullYear() === yNum) return true;
        }
        return false;
      });
    };

    const ids = new Set([
      ...Object.keys(anchorEnrollments || {}),
      ...Object.keys(enrollments || {}),
      ...Object.keys(overrides || {}),
      ...Object.keys(ledgers || {}),
      ...Object.keys(carryForward || {}),
      ...Object.keys(studentFees || {}),
      ...Object.keys(baseStudents || {}),
    ]);

    const map = {};
    ids.forEach((id) => {
      const base = baseStudents[id] || {};
      const anchor = anchorEnrollments[id] || {};
      const enrollment = enrollments[id] || {};
      const override = overrides[id] || {};
      const ledgerEntry = ledgers[id] || {};
      const carry = carryForward[id] || {};

      const hasTargetEnroll = isNonEmptyObj(enrollment);
      const hasAnchorEnroll = isNonEmptyObj(anchor);
      const carryAmount = Math.max(0, Number(carry.amount ?? carry.balance ?? 0));
      const hasOverride = isNonEmptyObj(override);

      let studentFeeOverride = studentFees[id];
      if (!studentFeeOverride) {
        const admKey =
          base.admissionNumber || base.admissionNo ||
          anchor.admissionNumber || anchor.admissionNo ||
          enrollment.admissionNumber || enrollment.admissionNo || '';
        if (admKey && studentFees[admKey]) studentFeeOverride = studentFees[admKey];
      }

      const coerceFee = (value) => {
        if (value == null) return null;
        if (typeof value === 'number') return Number.isFinite(value) ? value : null;
        if (typeof value === 'string') {
          const cleaned = value.replace(/[^\d.-]/g, '');
          if (!cleaned) return null;
          const parsed = Number(cleaned);
          return Number.isFinite(parsed) ? parsed : null;
        }
        if (typeof value === 'object') {
          const maybe = value.feePerYear ?? value.baseFee ?? value.amount ?? value.total ?? value.value;
          return coerceFee(maybe);
        }
        return null;
      };
      const explicitStudentFee = coerceFee(studentFeeOverride);

      const ledgerHasThisYear =
        (ledgerEntry && typeof ledgerEntry === 'object' && (
          (ledgerEntry[targetYear] && isNonEmptyObj(ledgerEntry[targetYear])) ||
          (ledgerEntry[String(targetYear)] && isNonEmptyObj(ledgerEntry[String(targetYear)])) ||
          (ledgerEntry[Number(targetYear)] && isNonEmptyObj(ledgerEntry[Number(targetYear)])) ||
          isNonEmptyObj(ledgerEntry.payments) ||
          isNonEmptyObj(ledgerEntry.entries) ||
          isNonEmptyObj(ledgerEntry.records)
        ));
      const baseHasYearPayments = hasPaymentsForYear(base.payments, targetYearNum);

      const existsInYear =
        hasTargetEnroll ||
        (hasAnchorEnroll && targetYearNum >= anchorYearNum) ||
        hasOverride ||
        carryAmount > 0 ||
        explicitStudentFee != null ||
        ledgerHasThisYear ||
        baseHasYearPayments;
      if (!existsInYear) return;

      let baseClass = '';
      let delta = 0;
      if (hasTargetEnroll) {
        baseClass = enrollment.className || enrollment.classLevel || enrollment.class || '';
        delta = 0;
      } else if (hasAnchorEnroll) {
        baseClass = anchor.className || anchor.classLevel || anchor.class || '';
        delta = targetYearNum - anchorYearNum;
      } else {
        baseClass = base.classLevel || base.class || '';
        delta = 0;
      }
      baseClass = canonClass(baseClass);
      if (hasAnchorEnroll) {
        const anchorClass = canonClass(anchor.className || anchor.classLevel || anchor.class || '');
        if (norm(anchorClass) === norm('Class 7') && targetYearNum > anchorYearNum) {
          delta = 999;
        }
      }

      const classLevel = shiftClass(baseClass, delta);
      const classDefaults = classFees[classLevel] || classFees[baseClass] || {};
      const resolvedPlanId = override.planId || classDefaults.defaultPlanId || null;
      const resolvedPlan = resolvedPlanId ? plans[resolvedPlanId] : null;

      const isMonthlyPlan = resolvedPlan?.schedule && Array.isArray(resolvedPlan.schedule) &&
        resolvedPlan.schedule.some((row) => String(row.label || '').includes('Monthly:'));

      let paymentPlan =
        (resolvedPlan && resolvedPlan.name) ||
        override.planName ||
        override.paymentPlan ||
        enrollment.planName ||
        enrollment.paymentPlan ||
        classDefaults.defaultPlan ||
        base.paymentPlan ||
        '6-instalments';
      if (isMonthlyPlan) paymentPlan = 'Malipo kwa mwezi';

      const admissionNumber =
        enrollment.admissionNumber ||
        enrollment.admissionNo ||
        base.admissionNumber ||
        id;

      let baseFeeCandidate =
        (explicitStudentFee != null ? explicitStudentFee : undefined) ??
        override.feePerYear ??
        classDefaults.feePerYear ??
        base.feePerYear ??
        base.feeDue ??
        base.requiredFee ??
        0;
      if (isMonthlyPlan && (!baseFeeCandidate || baseFeeCandidate === 0) && resolvedPlan?.schedule) {
        const totalFromSchedule = resolvedPlan.schedule.reduce((sum, row) => sum + (Number(row.amount) || 0), 0);
        if (totalFromSchedule > 0) baseFeeCandidate = totalFromSchedule;
      }

      const baseFee = Math.max(0, Math.round(Number(baseFeeCandidate) || 0));
      const effectiveFee = Math.max(0, baseFee + carryAmount);

      let paymentsSource = {};
      if (ledgerEntry && typeof ledgerEntry === 'object') {
        const yearBucket =
          ledgerEntry[targetYear] ||
          ledgerEntry[String(targetYear)] ||
          ledgerEntry[Number(targetYear)];
        if (yearBucket && typeof yearBucket === 'object') {
          if (yearBucket.payments) paymentsSource = yearBucket.payments;
          else if (yearBucket.entries) paymentsSource = yearBucket.entries;
          else if (yearBucket.records) paymentsSource = yearBucket.records;
          else paymentsSource = yearBucket;
        } else if (ledgerEntry.payments || ledgerEntry.entries || ledgerEntry.records) {
          paymentsSource = ledgerEntry.payments || ledgerEntry.entries || ledgerEntry.records;
        } else {
          paymentsSource = ledgerEntry;
        }
      } else if (ledgerEntry != null) {
        paymentsSource = ledgerEntry;
      }
      if (!Object.keys(paymentsSource || {}).length && base.payments) {
        const approvedFallback = {};
        Object.entries(base.payments).forEach(([key, entry]) => {
          if (!entry) return;
          const approvedMarker = Number(entry.approvedAt || entry.approved || 0);
          if (approvedMarker > 0) approvedFallback[key] = entry;
        });
        if (Object.keys(approvedFallback).length) paymentsSource = approvedFallback;
      }
      if (!Object.keys(paymentsSource || {}).length) {
        const fallbackEntries = approvalsByStudent[id] || [];
        if (fallbackEntries.length) {
          paymentsSource = {};
          fallbackEntries.forEach((entry, idx) => {
            const entryKey = entry.approvalId || `appr-${id}-${idx}`;
            paymentsSource[entryKey] = {
              amount: Number(entry.amount || 0),
              timestamp: Number(entry.timestamp || entry.approvedAt || Date.now()),
              method: entry.method || '',
              note: entry.note || '',
              referenceCode: entry.referenceCode || '',
              academicYear: Number(targetYear),
              approvedAt: Number(entry.approvedAt || entry.timestamp || Date.now()),
            };
          });
        }
      }

      const dedupedPayments = window.SOMAP_FINANCE?.dedupePaymentMap
        ? window.SOMAP_FINANCE.dedupePaymentMap(paymentsSource, targetYear, admissionNumber || id)
        : paymentsSource;
      const payments = normalizePayments(dedupedPayments, targetYear);

      const parentContact =
        enrollment.parentPhone ||
        enrollment.guardianPhone ||
        base.primaryParentContact ||
        base.parentPhone ||
        base.guardianPhone ||
        base.contact ||
        '';

      const record = {
        ...base,
        classLevel,
        classLevelRaw: baseClass || '',
        paymentPlan,
        feePerYear: effectiveFee,
        baseFee,
        carryAmount,
        payments,
        financeYear: targetYear,
        academicYear: targetYear,
        primaryParentContact: parentContact || base.primaryParentContact,
        admissionNumber: admissionNumber || id,
        hasYearData: existsInYear,
        isGraduated: classLevel === 'GRADUATED',
      };

      if (Array.isArray(override.customSchedule) && override.customSchedule.length) {
        record._customSchedule = override.customSchedule;
      } else if (resolvedPlan && Array.isArray(resolvedPlan.schedule)) {
        record._planSchedule = resolvedPlan.schedule;
      }

      record.previousDebt = 0;
      if (!record.firstName && enrollment.firstName) record.firstName = enrollment.firstName;
      if (!record.lastName && enrollment.lastName) record.lastName = enrollment.lastName;
      if (!record.middleName && enrollment.middleName) record.middleName = enrollment.middleName;
      if (override && Object.keys(override).length) record.override = override;
      record._classDefaults = classDefaults;
      map[id] = record;
    });

    return map;
  }

  const financeYearDataCache = new Map();
  const financeApprovalsCache = new Map();
  const financeBalanceCache = new Map();

  async function loadApprovedFinanceApprovals(year, force = false) {
    if (!db) return {};
    const targetYear = String(year || financeYear || SOMAP_DEFAULT_YEAR);
    if (!force && financeApprovalsCache.has(targetYear)) return financeApprovalsCache.get(targetYear);
    try {
      const snapshot = await schoolRef('approvalsHistory').once('value');
      const tree = snapshot.val() || {};
      const grouped = {};
      const normalizedTargetYear = Number(targetYear);
      Object.entries(tree).forEach(([_, months]) => {
        Object.entries(months || {}).forEach(([__, records]) => {
          Object.entries(records || {}).forEach(([key, record]) => {
            if (!record) return;
            const recordYear = Number(record.forYear ?? record.academicYear ?? record.year);
            if (!Number.isFinite(recordYear) || recordYear !== normalizedTargetYear) return;
            const finalStatus = String(record.finalStatus || record.status || '').toLowerCase();
            if (!['approved', 'completed'].includes(finalStatus)) return;
            const moduleSource = String(record.sourceModule || record.module || '').toLowerCase();
            if (!moduleSource.includes('finance')) return;
            const studentKey = record.studentId || record.modulePayload?.studentKey || record.studentAdm;
            if (!studentKey) return;
            const amount = Number(record.amountPaidNow ?? record.amount ?? record.paidAmount ?? 0);
            if (!(amount > 0)) return;
            const timestamp = Number(record.approvedAt || record.datePaid || record.createdAt || Date.now());
            if (!grouped[studentKey]) grouped[studentKey] = [];
            grouped[studentKey].push({
              approvalId: key,
              amount,
              timestamp,
              method: record.method || record.paymentMethod || record.modulePayload?.payment?.method || '',
              note: record.note || record.modulePayload?.payment?.note || '',
              referenceCode: record.referenceCode || record.paymentReferenceCode || record.modulePayload?.payment?.referenceCode || '',
              academicYear: normalizedTargetYear,
              approvedAt: timestamp,
            });
          });
        });
      });
      financeApprovalsCache.set(targetYear, grouped);
      return grouped;
    } catch (err) {
      console.warn('Finance: approvals history read failed', err?.message || err);
      financeApprovalsCache.set(targetYear, {});
      return {};
    }
  }

  async function loadFinanceStudentsForYearCached(year) {
    const key = String(year || activeYear || SOMAP_DEFAULT_YEAR);
    if (!db) return {};
    if (key === String(activeYear) || key === String(financeYear)) {
      return cachedStudents || {};
    }
    if (financeYearDataCache.has(key)) {
      return financeYearDataCache.get(key);
    }

    const promise = (async () => {
      try {
        const [
          baseSnap,
          anchorEnrollSnap,
          enrollmentSnap,
          classFeesSnap,
          stOverridesSnap,
          studentFeesSnap,
          plansSnap,
        ledgerSnap,
        carrySnap,
      ] = await Promise.all([
        schoolRef('students').once('value'),
        schoolRef(`enrollments/${SOMAP_DEFAULT_YEAR}`).once('value'),
        schoolRef(`enrollments/${key}`).once('value'),
        schoolRef(`feesStructure/${key}`).once('value'),
        schoolRef(`studentOverrides/${key}`).once('value'),
        schoolRef(`studentFees/${key}`).once('value'),
        schoolRef(`installmentPlans/${key}`).once('value'),
        schoolRef(`financeLedgers/${key}`).once('value'),
        schoolRef(`financeCarryForward/${key}`).once('value'),
        ]);

        const baseStudents = baseSnap.val() || {};
        let ledgerData = ledgerSnap.val() || {};
        if (!Object.keys(ledgerData || {}).length) {
          try {
            const legacyLedgerSnap = await schoolRef('financeLedgers').once('value');
            ledgerData = legacyLedgerSnap.val() || {};
          } catch (legacyErr) {
            console.warn('Legacy financeLedgers read failed (helper)', legacyErr?.message || legacyErr);
          }
        }

        let studentFeesData = studentFeesSnap.val() || {};
        if (!Object.keys(studentFeesData || {}).length) {
          try {
            const legacyStudentFeesSnap = await schoolRef(`finance/${key}/studentFees`).once('value');
            studentFeesData = legacyStudentFeesSnap.val() || {};
          } catch (studentFeesErr) {
            console.warn('Student fee override read failed (helper)', studentFeesErr?.message || studentFeesErr);
          }
        }

        const approvalsByStudent = await loadApprovedFinanceApprovals(key);
        const built = buildFinanceStudents(
          baseStudents,
          anchorEnrollSnap.val() || {},
          enrollmentSnap.val() || {},
          classFeesSnap.val() || {},
          stOverridesSnap.val() || {},
          plansSnap.val() || {},
          ledgerData,
          carrySnap.val() || {},
          studentFeesData,
          approvalsByStudent,
          key
        );
        return built || {};
      } catch (err) {
        console.warn('Carry-forward helper failed to load year dataset', key, err);
        return {};
      }
    })();

    financeYearDataCache.set(key, promise);
    return promise;
  }

  window.__finance_getBalanceForYearAdmission = async function (year, admissionNo) {
    const normalizedYear = String(year || '');
    const normalizedAdm = String(admissionNo || '').trim();
    if (!normalizedAdm) return 0;
    const cacheKey = `${normalizedYear}::${normalizedAdm}`;
    if (financeBalanceCache.has(cacheKey)) {
      return financeBalanceCache.get(cacheKey);
    }
    try {
      const dataset = await loadFinanceStudentsForYearCached(normalizedYear);
      if (!dataset || !Object.keys(dataset).length) {
        financeBalanceCache.set(cacheKey, 0);
        return 0;
      }
      let student = dataset[normalizedAdm];
      if (!student) {
        const matchKey = Object.keys(dataset).find((key) => {
          const entry = dataset[key] || {};
          return String(entry.admissionNumber || entry.admissionNo || key).trim() === normalizedAdm;
        });
        if (matchKey) student = dataset[matchKey];
      }
      if (!student) {
        financeBalanceCache.set(cacheKey, 0);
        return 0;
      }
      const previousFinanceYear = financeYear;
      const previousActiveYear = activeYear;
      try {
        financeYear = normalizedYear;
        activeYear = normalizedYear;
        const fin = computeStudentFinancials(student);
        const balanceValue = Math.max(0, Number(fin?.balance) || 0);
        financeBalanceCache.set(cacheKey, balanceValue);
        return balanceValue;
      } finally {
        financeYear = previousFinanceYear;
        activeYear = previousActiveYear;
      }
    } catch (err) {
      console.warn('Carry-forward helper balance lookup failed', year, admissionNo, err);
      financeBalanceCache.set(cacheKey, 0);
      return 0;
    }
  };

  // Expose a summary getter so child iframes (payment.html) can stay in sync with the finance table.
  window.__finance_getStudentFinanceSummary = async function (year, studentIdOrAdm) {
    const targetYear = String(year || financeYear || activeYear || SOMAP_DEFAULT_YEAR);
    const identifier = String(studentIdOrAdm || '').trim();
    if (!identifier) return null;
    try {
      const dataset = await loadFinanceStudentsForYearCached(targetYear);
      let student = dataset[identifier];
      if (!student) {
        const matchKey = Object.keys(dataset).find((key) => {
          const entry = dataset[key] || {};
          return String(entry.admissionNumber || entry.admissionNo || key).trim() === identifier;
        });
        if (matchKey) student = dataset[matchKey];
      }
      if (!student) return null;

      const prevFinanceYear = financeYear;
      const prevActiveYear = activeYear;
      try {
        financeYear = targetYear;
        activeYear = targetYear;
        const fin = computeStudentFinancials(student);
        const baseFee = Math.max(0, Number(student.baseFee || student.feePerYear || 0));
        const carry = Math.max(0, Number(student.carryAmount || 0));
        const totalDue = Math.max(0, baseFee + carry);
        return {
          due: totalDue,
          baseFee,
          carry,
          paid: Math.max(0, Number(fin.paidAmount || 0)),
          balance: Math.max(0, Number(fin.balance || 0)),
          credit: Math.max(0, Number(fin.credit || 0)),
        };
      } finally {
        financeYear = prevFinanceYear;
        activeYear = prevActiveYear;
      }
    } catch (err) {
      console.warn('Finance: summary export failed', err?.message || err);
      return null;
    }
  };

  // ====== SPEED FIX: placeholder breakdown row (no iframe yet) ======
  function breakdownRowHTML(id) {
    return `
      <tr id="br-${id}" class="hidden bg-slate-50">
        <td class="p-2 border-t" colspan="10">
          <div class="breakdown-slot" data-id="${id}">
            <div class="p-3 text-xs text-slate-500 skel rounded">Loading area…</div>
          </div>
        </td>
      </tr>
    `;
  }

  // ===== Render table (unchanged except: uses placeholder breakdown row) =====
  function renderTable() {
    tbody.innerHTML = '';
    let totalDue = 0, totalCollected = 0;
    let shown = 0;
    const filterClass = classFilter.value;
    const isParentScope = parentCtx.enabled;

    Object.entries(cachedStudents).forEach(([id, student]) => {
      if (filterClass && student.classLevel !== filterClass) return;
      if (!isParentScope && student.isGraduated) return;

      let fin = computeStudentFinancials(student);
      if (student.isGraduated) {
        const effectiveFee = 0;
        fin = {
          feePerYear: isParentScope ? 0 : effectiveFee,
          previousDebt: 0,
          paidAmount: 0,
          balance: isParentScope ? 0 : effectiveFee,
          periodDebtLabel: '-',
          periodDebtValue: 0,
          credit: 0,
          scheduleItems: []
        };
      }

      if (showingDebtorsOnly && (fin.balance <= 0 && fin.periodDebtValue <= 0)) return;

      totalDue += fin.feePerYear;
      totalCollected += fin.paidAmount;

      const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
      const debtLabel = fin.periodDebtValue > 0 ? `Debt till ${fin.periodDebtLabel}` : '-';
      const prevYearNum = Number(financeYear) - 1;
      const carryYearLabel = Number.isFinite(prevYearNum) ? prevYearNum : `${financeYear}-1`;
      const carryNote = student.carryAmount > 0
        ? `<div class="text-xs text-slate-500 text-right mt-1">Includes carry-forward from ${carryYearLabel}: ${fmt(student.carryAmount)}</div>`
        : '';
      const statusNote = student.isGraduated
        ? `<div class="mt-1 text-xs font-semibold text-emerald-600 uppercase">Graduated</div>`
        : (!student.hasYearData && Object.keys(student.payments || {}).length === 0
            ? `<div class="mt-1 text-xs text-slate-500">No finance records captured for ${financeYear} yet.</div>`
            : '');

      const disablePay = student.isGraduated;
      const payBtnHtml = disablePay
        ? `<button class="payBtn px-2 py-1 text-xs bg-slate-200 text-slate-500 rounded ml-1 cursor-not-allowed" data-id="${id}" disabled>Pay</button>`
        : `<button class="payBtn px-2 py-1 text-xs bg-indigo-600 text-white rounded ml-1" data-id="${id}">Pay</button>`;

      const tr = document.createElement('tr');
      tr.className = 'table-row';
      tr.dataset.studentId = id;
      tr.innerHTML = `
        <td class="p-2 border text-center align-top">
          <button class="expander text-indigo-600 hover:text-indigo-800" data-id="${id}" title="Expand/Collapse">
            <i class="fa fa-chevron-down"></i>
          </button>
        </td>
        <td class="p-2 border align-top">${student.admissionNumber || ''}</td>
        <td class="p-2 border align-top">${fullName}</td>
        <td class="p-2 border align-top">${student.classLevel || ''}${statusNote}</td>
        <td class="p-2 border align-top text-right">${fmt(fin.feePerYear)}${carryNote}</td>
        <td class="p-2 border align-top">${student.paymentPlan || ''}</td>
        <td class="p-2 border align-top text-right">${fmt(fin.paidAmount)}</td>
        <td class="p-2 border align-top text-right">${fmt(fin.balance)}</td>
        <td class="p-2 border align-top">
          <div class="flex items-center justify-between gap-2">
            <span>${debtLabel}</span>
            <span class="font-semibold ${fin.periodDebtValue > 0 ? 'text-red-700' : ''}">${fmt(fin.periodDebtValue)}</span>
          </div>
        </td>
        <td class="p-2 border align-top">
          <button class="viewBtn px-2 py-1 text-xs border rounded" data-id="${id}">View</button>
          ${payBtnHtml}
        </td>
      `;
      tbody.appendChild(tr);
      shown++;

      const brWrap = document.createElement('tbody');
      brWrap.innerHTML = breakdownRowHTML(id);
      tbody.appendChild(brWrap.firstElementChild);
    });

    const totalOutstanding = totalDue - totalCollected;
    const studentCountEl = document.getElementById('financeStudentCount');
    if (studentCountEl) {
      studentCountEl.textContent = String(shown);
    }
    const totalDueEl = document.getElementById('totalDue');
    if (totalDueEl) {
      totalDueEl.textContent = fmt(totalDue);
      totalDueEl.dataset.amount = String(totalDue);
    }
    const totalCollectedEl = document.getElementById('totalCollected');
    if (totalCollectedEl) {
      totalCollectedEl.textContent = fmt(totalCollected);
      totalCollectedEl.dataset.amount = String(totalCollected);
    }
    const totalOutstandingEl = document.getElementById('totalOutstanding');
    if (totalOutstandingEl) {
      totalOutstandingEl.textContent = fmt(totalOutstanding);
      totalOutstandingEl.dataset.amount = String(totalOutstanding);
    }

    tbody.querySelectorAll('.payBtn').forEach(btn => btn.addEventListener('click', (e) => {
      if (btn.disabled) return;
      openPaymentModalFor(e.currentTarget.dataset.id);
    }));
    tbody.querySelectorAll('.viewBtn').forEach(btn => btn.addEventListener('click', e => openDetailsModal(e.target.dataset.id)));
    try {
      document.dispatchEvent(new CustomEvent('finance:tableRendered', { detail: { year: financeYear } }));
    } catch (eventErr) {
      console.warn('finance:tableRendered dispatch failed', eventErr);
    }
    // NOTE: no per-row expander listeners added here (we use a single global delegated listener below)

    updateFinanceAggregates();
  }

  function computeAggregateTotals() {
    const totals = { totalStudents: 0, totalDue: 0, totalCollected: 0, totalOutstanding: 0, totalExpenses: 0 };
    if (!cachedStudents || !Object.keys(cachedStudents).length) return totals;
    Object.values(cachedStudents).forEach((student) => {
      if (!parentCtx.enabled && student.isGraduated) return;
      let fin = computeStudentFinancials(student);
      if (!student.hasYearData || student.isGraduated) {
        const effectiveFee = student.isGraduated ? 0 : Number(student.feePerYear) || 0;
        fin = {
          feePerYear: effectiveFee,
          paidAmount: 0,
        };
      }
      totals.totalStudents += 1;
      totals.totalDue += Number(fin.feePerYear) || 0;
      totals.totalCollected += Number(fin.paidAmount) || 0;
    });
    totals.totalOutstanding = totals.totalDue - totals.totalCollected;
    const totalExpensesEl = document.getElementById('totalExpenses');
    totals.totalExpenses = Number(totalExpensesEl?.dataset.amount || 0);
    return totals;
  }

  async function updateFinanceAggregates() {
    if (parentCtx.enabled) return;
    financeAggregateSnapshot = computeAggregateTotals();
    if (!activeSchoolId || !db) return;
    try {
      const summaryRef = schoolRef(`financials/${financeYear}/financeAggregates`);
      await summaryRef.update({
        totalStudents: financeAggregateSnapshot.totalStudents,
        totalFeesExpected: financeAggregateSnapshot.totalDue,
        totalFeesCollected: financeAggregateSnapshot.totalCollected,
        totalFeesBalance: financeAggregateSnapshot.totalOutstanding,
        totalExpenses: financeAggregateSnapshot.totalExpenses,
        updatedAt: Date.now()
      });
    } catch (err) {
      console.warn('Failed to sync financeAggregates', err);
    }
  }

  // ====== SPEED FIX: lazy-load a single iframe when clicked, and close others ======
  function injectIframeIfNeeded(id) {
    const row = document.getElementById(`br-${id}`);
    if (!row) return;
    const slot = row.querySelector('.breakdown-slot');
    if (!slot || slot.dataset.loaded) return;

    const scopeParam = parentCtx.enabled ? '&scope=parent' : '';
    slot.innerHTML = `
      <div class="p-3 text-xs text-slate-500">Loading breakdown…</div>
      <iframe
        src="Tofinancehtml/payment.html?student=${encodeURIComponent(id)}&year=${encodeURIComponent(financeYear)}${scopeParam}"
        class="w-full h-[360px] rounded border"
        loading="lazy"
      ></iframe>
    `;
    slot.dataset.loaded = '1';
  }

  document.addEventListener('click', (e) => {
    const btn = e.target.closest('button.expander');
    if (!btn) return;

    const id = btn.dataset.id;
    const row = document.getElementById(`br-${id}`);
    if (!row) return;

    // Close any other open breakdown rows
    document.querySelectorAll('tr[id^="br-"]:not(.hidden)').forEach(r => {
      if (r !== row) r.classList.add('hidden');
    });
    // Reset other chevrons
    document.querySelectorAll('button.expander.open').forEach(b => {
      if (b !== btn) {
        b.classList.remove('open');
        const ic = b.querySelector('i'); if (ic) ic.classList.remove('fa-chevron-up'); if (ic) ic.classList.add('fa-chevron-down');
      }
    });

    const wasHidden = row.classList.contains('hidden');
    row.classList.toggle('hidden');

    const icon = btn.querySelector('i');
    if (wasHidden) {
      btn.classList.add('open');
      if (icon) { icon.classList.remove('fa-chevron-down'); icon.classList.add('fa-chevron-up'); }
      injectIframeIfNeeded(id);
    } else {
      btn.classList.remove('open');
      if (icon) { icon.classList.remove('fa-chevron-up'); icon.classList.add('fa-chevron-down'); }
    }
  });

  // Auto-resize when child posts its height
  window.addEventListener('message', (e) => {
    const d = e.data || {};
    if (d.type === 'resizeIframe' && d.id) {
      const frame = document.querySelector(`#br-${d.id} iframe`);
      if (frame) frame.style.height = Math.max(360, Number(d.height) || 0) + 'px';
    }
  });

  // ===== Expenses + exports (unchanged) =====
  const expenseForm = document.getElementById('expenseForm');
  const expenseTableBody = document.querySelector('#expenseTable tbody');

  async function loadExpenses(year = activeYear) {
    try {
      const targetYear = String(year || activeYear);
      const snap = await schoolRef(`expenses/${targetYear}`).once('value');
      const raw = snap.val() || {};
      // Year-scoped only: do NOT fall back to unscoped /expenses, otherwise year switching shows wrong data.
      const expenseValues = Array.isArray(raw) ? raw.filter(Boolean) : Object.values(raw || {});
      expenseTableBody.innerHTML = '';
      let total = 0;
      if (!expenseValues.length) {
        expenseTableBody.innerHTML = `
          <tr>
            <td colspan="4" class="p-2 border text-center text-slate-500">No expenses for ${targetYear} yet.</td>
          </tr>
        `;
      }
      expenseValues.forEach(exp => {
        total += Number(exp.amount) || 0;
        const dateLabel = exp.timestamp
          ? new Date(exp.timestamp).toLocaleDateString()
          : (exp.date || '');
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="p-2 border">${exp.category || ''}</td>
          <td class="p-2 border">${exp.description || ''}</td>
          <td class="p-2 border text-right">${fmt(exp.amount)}</td>
          <td class="p-2 border">${dateLabel}</td>
        `;
        expenseTableBody.appendChild(tr);
      });
      const totalExpensesEl = document.getElementById('totalExpenses');
      if (totalExpensesEl) {
        totalExpensesEl.textContent = fmt(total);
        totalExpensesEl.dataset.amount = String(total);
      }
      const collectedEl = document.getElementById('totalCollected');
      const collected = Number(collectedEl?.dataset.amount || 0);
      const net = collected - total;
      const netEl = document.getElementById('netBalance');
      if (netEl) {
        netEl.textContent = fmt(net);
        netEl.dataset.amount = String(net);
      }
      updateFinanceAggregates();
    } catch (err) {
      console.error('Error loading expenses:', err);
      alert('Error loading expenses: ' + err.message);
    }
  }

  if (expenseForm) {
    expenseForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const category = (document.getElementById('expenseCategory')?.value || '').trim();
      const description = (document.getElementById('expenseDescription')?.value || '').trim();
      const amount = Number(document.getElementById('expenseAmount')?.value || 0);
      const date = (document.getElementById('expenseDate')?.value || '').trim();

      if (!category || !description || !amount || !date) {
        alert('Fill all fields');
        return;
      }

      const year = String(activeYear || yearContext?.getSelectedYear?.() || new Date().getFullYear());
      const timestamp = new Date(`${date}T00:00:00`).getTime();
      await schoolRef(`expenses/${year}`).push({
        category,
        description,
        amount,
        date,
        timestamp: Number.isFinite(timestamp) ? timestamp : Date.now(),
        createdAt: Date.now(),
      });

      expenseForm.reset();
      await loadExpenses(year);
    });
  }

  async function refreshFinanceData(year = activeYear) {
    await loadStudents(year);
    await loadExpenses(year);
  }

  // ===== CSV/PDF downloaders (parent-scoped) =====
  function downloadCSV_Main() {
    const rows = [['Admission No', 'Full Name', 'Class', 'Fee (Year)', 'Plan', 'Paid', 'Balance (Year)', 'Debt till …', 'Debt Amount']];
    let totalFee = 0, totalPaid = 0, totalBal = 0, totalDebt = 0;
    const filterClass = classFilter.value;
    Object.entries(cachedStudents).forEach(([id, s]) => {
      if (filterClass && s.classLevel !== filterClass) return;
      const fin = computeStudentFinancials(s);
      if (showingDebtorsOnly && (fin.balance <= 0 && fin.periodDebtValue <= 0)) return;
      const fullName = `${s.firstName || ''} ${s.middleName || ''} ${s.lastName || ''}`.trim();
      rows.push([s.admissionNumber || '', fullName, s.classLevel || '', fin.feePerYear, s.paymentPlan || '', fin.paidAmount, fin.balance, fin.periodDebtLabel, fin.periodDebtValue]);
      totalFee += fin.feePerYear; totalPaid += fin.paidAmount; totalBal += fin.balance; totalDebt += fin.periodDebtValue;
    });
    rows.push(['TOTAL', '', '', totalFee, '', totalPaid, totalBal, '', totalDebt]);
    const ws = XLSX.utils.aoa_to_sheet(rows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Finance');
    
    // Parent mode: use child-specific filename
    let filename = `finance_export_${Date.now()}.xlsx`;
    if (parentCtx.enabled) {
      const onlyId = Object.keys(cachedStudents||{})[0];
      const only = cachedStudents[onlyId] || {};
      const adm = only.admissionNumber || onlyId;
      filename = `finance_${adm}_${(parentCtx.year||financeYear)}.xlsx`;
    }
    XLSX.writeFile(wb, filename);
  }

  function downloadPDF_Main() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: 'landscape' });
    const headers = [['Admission No', 'Full Name', 'Class', 'Fee (Year)', 'Plan', 'Paid', 'Balance (Year)', 'Debt till …', 'Debt Amount']];
    const body = [];
    let totalFee = 0, totalPaid = 0, totalBal = 0, totalDebt = 0;
    const filterClass = classFilter.value;
    Object.entries(cachedStudents).forEach(([id, s]) => {
      if (filterClass && s.classLevel !== filterClass) return;
      const fin = computeStudentFinancials(s);
      if (showingDebtorsOnly && (fin.balance <= 0 && fin.periodDebtValue <= 0)) return;
      const fullName = `${s.firstName || ''} ${s.middleName || ''} ${s.lastName || ''}`.trim();
      body.push([s.admissionNumber || '', fullName, s.classLevel || '', fin.feePerYear, s.paymentPlan || '', fin.paidAmount, fin.balance, fin.periodDebtLabel, fin.periodDebtValue]);
      totalFee += fin.feePerYear; totalPaid += fin.paidAmount; totalBal += fin.balance; totalDebt += fin.periodDebtValue;
    });
    body.push(['TOTAL', '', '', totalFee, '', totalPaid, totalBal, '', totalDebt]);
    doc.setFontSize(14); doc.text('SoMAp Finance Report', 14, 14);
    doc.autoTable({ head: headers, body, startY: 20, styles: { fontSize: 8 } });
    
    // Parent mode: use child-specific filename
    let filename = `finance_report_${Date.now()}.pdf`;
    if (parentCtx.enabled) {
      const onlyId = Object.keys(cachedStudents||{})[0];
      const only = cachedStudents[onlyId] || {};
      const adm = only.admissionNumber || onlyId;
      filename = `finance_${adm}_${(parentCtx.year||financeYear)}.pdf`;
    }
    doc.save(filename);
  }

  function _gatherDebtNow() {
    const rows = []; let totalDebt = 0;
    const filterClass = classFilter.value;
    Object.entries(cachedStudents).forEach(([id, s]) => {
      if (filterClass && s.classLevel !== filterClass) return;
      const fin = computeStudentFinancials(s);
      if (fin.periodDebtValue > 0) {
        const fullName = `${s.firstName || ''} ${s.middleName || ''} ${s.lastName || ''}`.trim();
        rows.push([s.admissionNumber || '', fullName, s.classLevel || '', s.paymentPlan || '', fin.periodDebtLabel, fin.periodDebtValue]);
        totalDebt += fin.periodDebtValue;
      }
    });
    return { rows, totalDebt };
  }

  function downloadCSV_DebtNow() {
    const header = ['Admission No', 'Full Name', 'Class', 'Plan', 'Debt till …', 'Debt Amount'];
    const { rows, totalDebt } = _gatherDebtNow();
    const data = [header, ...rows, ['TOTAL', '', '', '', '', totalDebt]];
    const ws = XLSX.utils.aoa_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Debt Now');
    XLSX.writeFile(wb, `debt_now_${Date.now()}.xlsx`);
  }

  function downloadPDF_DebtNow() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: 'landscape' });
    const header = [['Admission No', 'Full Name', 'Class', 'Plan', 'Debt till …', 'Debt Amount']];
    const { rows, totalDebt } = _gatherDebtNow();
    const body = [...rows, ['TOTAL', '', '', '', '', totalDebt]];
    doc.setFontSize(14); doc.text('Debt List (Current Period)', 14, 14);
    doc.autoTable({ head: header, body: body, startY: 20, styles: { fontSize: 8 } });
    doc.save(`debt_now_${Date.now()}.pdf`);
  }

  function _gatherBreakdown() {
    const sheets = [];
    const filterClass = classFilter.value;
    Object.entries(cachedStudents).forEach(([id, s]) => {
      if (filterClass && s.classLevel !== filterClass) return;
      const fin = computeStudentFinancials(s);
      const fullName = `${s.firstName || ''} ${s.middleName || ''} ${s.lastName || ''}`.trim();
      const rows = [['Period', 'Expected', 'Allocated Paid', 'Remaining', 'Status', 'Window']];
      let totalExp = 0, totalPaid = 0;
      fin.scheduleItems.forEach(it => {
        const need = it.amount, got = it.paidAllocated, rem = Math.max(0, need - got);
        totalExp += need; totalPaid += got;
        rows.push([it.label, need, got, rem, it.status, `${new Date(it.fromTS).toLocaleDateString()} – ${new Date(it.toTS).toLocaleDateString()}`]);
      });
      const totalRem = Math.max(0, totalExp - totalPaid);
      rows.push(['TOTAL', totalExp, totalPaid, totalRem, '', '']);
      sheets.push({ title: `${fullName} (${s.admissionNumber || ''})`, rows });
    });
    return sheets;
  }

  function downloadCSV_Breakdown() {
    const wb = XLSX.utils.book_new();
    const sheets = _gatherBreakdown();
    if (!sheets.length) return alert('No students to export.');
    sheets.forEach(sh => {
      const ws = XLSX.utils.aoa_to_sheet(sh.rows);
      XLSX.utils.book_append_sheet(wb, ws, sh.title.slice(0, 31));
    });
    
    // Parent mode: use child-specific filename
    let filename = `breakdowns_${Date.now()}.xlsx`;
    if (parentCtx.enabled) {
      const onlyId = Object.keys(cachedStudents||{})[0];
      const only = cachedStudents[onlyId] || {};
      const adm = only.admissionNumber || onlyId;
      filename = `breakdown_${adm}_${(parentCtx.year||financeYear)}.xlsx`;
    }
    XLSX.writeFile(wb, filename);
  }

  function downloadPDF_Breakdown() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: 'landscape' });
    const sheets = _gatherBreakdown();
    if (!sheets.length) return alert('No students to export.');
    sheets.forEach((sh, idx) => {
      if (idx > 0) doc.addPage();
      doc.setFontSize(14);
      doc.text(`Installment Breakdown — ${sh.title}`, 14, 14);
      doc.autoTable({ head: [['Period', 'Expected', 'Allocated Paid', 'Remaining', 'Status', 'Window']], body: sh.rows.slice(1), startY: 20, styles: { fontSize: 8 } });
    });
    
    // Parent mode: use child-specific filename
    let filename = `breakdowns_${Date.now()}.pdf`;
    if (parentCtx.enabled) {
      const onlyId = Object.keys(cachedStudents||{})[0];
      const only = cachedStudents[onlyId] || {};
      const adm = only.admissionNumber || onlyId;
      filename = `breakdown_${adm}_${(parentCtx.year||financeYear)}.pdf`;
    }
    doc.save(filename);
  }

  // ===== Payments & modals (unchanged) =====
  function populateStudentSelect() {
    studentSelect.innerHTML = '<option value="">-- Select student --</option>';
    Object.entries(cachedStudents).forEach(([id, s]) => {
      const fullName = `${s.firstName || ''} ${s.middleName || ''} ${s.lastName || ''}`.trim();
      const opt = document.createElement('option');
      opt.value = id;
      opt.textContent = `${fullName} — ${s.classLevel || ''} — ${s.admissionNumber || ''}`;
      studentSelect.appendChild(opt);
    });
  }

  function openPaymentModalFor(id) {
    if (!cachedStudents[id]) return alert('Student not found');
    studentSelect.value = id;
    // Set default date to today
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('paymentDate').value = today;
    paymentModal.style.display = 'block';
  }
  function closePaymentModalFn() { paymentModal.style.display = 'none'; paymentForm.reset(); }

  const LEDGER_ACTION_PASSWORD = 'REHEMam!';

  function confirmLedgerAction(actionLabel) {
    const input = prompt(`Enter password to ${actionLabel}:`);
    if (input === null) return false;
    if (input !== LEDGER_ACTION_PASSWORD) {
      alert('Incorrect password.');
      return false;
    }
    return true;
  }

  function parseLedgerTimestampInput(input, fallback) {
    const raw = String(input || '').trim();
    if (!raw) return fallback;
    const normalized = raw.replace(' ', 'T');
    const ts = Date.parse(normalized);
    if (!Number.isFinite(ts)) return null;
    return ts;
  }

  async function handleLedgerEdit(studentId, paymentId) {
    if (!confirmLedgerAction('edit this payment')) return;
    const student = cachedStudents[studentId];
    if (!student) return alert('Student not found');
    const payment = student.payments?.[paymentId];
    if (!payment) return alert('Payment not found');

    const amountInput = prompt('Edit amount (TSh)', payment.amount != null ? String(payment.amount) : '');
    if (amountInput === null) return;
    const amount = Number(amountInput);
    if (!Number.isFinite(amount) || amount < 0) {
      alert('Enter a valid non-negative amount.');
      return;
    }
    const methodInput = prompt('Edit method', payment.method || '');
    if (methodInput === null) return;
    const noteInput = prompt('Edit note', payment.note || '');
    if (noteInput === null) return;
    const currentStamp = payment.timestamp ? new Date(payment.timestamp) : null;
    const defaultStamp = currentStamp ? currentStamp.toISOString().slice(0, 16).replace('T', ' ') : '';
    const dateInput = prompt('Edit date/time (YYYY-MM-DD or YYYY-MM-DD HH:mm). Leave blank to keep.', defaultStamp);
    if (dateInput === null) return;
    const nextTimestamp = parseLedgerTimestampInput(dateInput, payment.timestamp || Date.now());
    if (nextTimestamp === null) {
      alert('Invalid date/time format.');
      return;
    }

    try {
      await schoolRef(`financeLedgers/${financeYear}/${studentId}/payments/${paymentId}`).update({
        amount: Math.round(amount),
        method: (methodInput || '').trim(),
        note: (noteInput || '').trim(),
        timestamp: nextTimestamp,
      });
      await refreshFinanceData(financeYear);
      await openDetailsModal(studentId);
    } catch (err) {
      console.error('Failed to edit payment', err);
      alert('Failed to edit payment: ' + (err?.message || err));
    }
  }

  async function handleLedgerDelete(studentId, paymentId) {
    if (!confirmLedgerAction('delete this payment')) return;
    if (!confirm('Delete this payment permanently?')) return;
    try {
      await schoolRef(`financeLedgers/${financeYear}/${studentId}/payments/${paymentId}`).remove();
      await refreshFinanceData(financeYear);
      await openDetailsModal(studentId);
    } catch (err) {
      console.error('Failed to delete payment', err);
      alert('Failed to delete payment: ' + (err?.message || err));
    }
  }

  async function promptEditYearFee(studentId) {
    if (!db) return alert('Database connection not ready.');
    if (!hasFinanceAdminAccess()) return alert('Not authorized to edit fees.');
    const student = cachedStudents[studentId];
    if (!student) return alert('Student not found');
    const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim() || (student.admissionNumber || studentId);
    const currentBase = Math.max(0, Number(student.baseFee || 0));
    const input = prompt(`Set base fee for ${fullName} (${financeYear})`, currentBase ? String(currentBase) : '');
    if (input === null) return;
    const parsed = Number(input);
    if (!Number.isFinite(parsed) || parsed < 0) {
      alert('Enter a valid non-negative amount.');
      return;
    }
    const rounded = Math.round(parsed);
    try {
      await schoolRef(`studentFees/${financeYear}/${studentId}`).update({ feePerYear: rounded });
      await loadStudents(financeYear);
      openDetailsModal(studentId);
      alert(`Base fee updated for ${financeYear}.`);
    } catch (err) {
      console.error('Failed to update fee', err);
      alert('Failed to update fee: ' + (err?.message || err));
    }
  }

  async function openDetailsModal(id) {
    const s = cachedStudents[id]; if (!s) return alert('Student not found');
    let fin = computeStudentFinancials(s);
    if (s.isGraduated) {
      fin = {
        feePerYear: 0,
        previousDebt: 0,
        paidAmount: 0,
        balance: 0,
        periodDebtLabel: '-',
        periodDebtValue: 0,
        credit: 0,
        scheduleItems: [],
      };
    }
    const fullName = `${s.firstName || ''} ${s.middleName || ''} ${s.lastName || ''}`.trim();
    const targetYearNum = Number(financeYear);
    const admission = s.admissionNumber || id;
    let carryForwardPrev = 0;
    if (Number.isFinite(targetYearNum)) {
      const prevYear = targetYearNum - 1;
      if (prevYear >= CARRY_FORWARD_START_YEAR) {
        const safeId = (typeof CSS !== 'undefined' && CSS.escape) ? CSS.escape(String(id)) : String(id).replace(/"/g, '\\"');
        const rowEl = document.querySelector(`#financeTable tbody tr[data-student-id="${safeId}"]`);
        const rowCarry = Number(rowEl?.dataset?.carryForward || 0);
        if (rowCarry > 0) {
          carryForwardPrev = rowCarry;
        } else {
          const key = `${targetYearNum}::${admission}`;
          const sharedCarry = window.__financeCarryForwardVisual?.[key]?.carry;
          if (sharedCarry) carryForwardPrev = Number(sharedCarry) || 0;
        }
        if (carryForwardPrev <= 0 && typeof window.__finance_getBalanceForYearAdmission === 'function') {
          try {
            const bal = await window.__finance_getBalanceForYearAdmission(prevYear, admission);
            carryForwardPrev = Math.max(0, Number(bal) || 0);
          } catch (err) {
            console.warn('Carry-forward (details modal) lookup failed', admission, prevYear, err);
          }
        }
      }
    }
    carryForwardPrev = Math.max(0, Number(carryForwardPrev) || 0);
    const dbCarry = Math.max(0, Number(s.carryAmount || 0));
    const baseFeeRaw = s.baseFee != null ? Number(s.baseFee) : Number(s.feePerYear || 0) - dbCarry;
    const baseFee = Math.max(0, Number.isFinite(baseFeeRaw) ? baseFeeRaw : 0);
    const prevYearLabel = Number.isFinite(targetYearNum) ? targetYearNum - 1 : 'Prev';
    const effectiveCarry = Math.max(dbCarry, carryForwardPrev);
    const totalDue = baseFee + effectiveCarry;
    const paidTotal = Math.max(0, Number(fin.paidAmount || 0));
    const balanceDisplay = Math.max(0, totalDue - paidTotal);
    const debtWithCarry = Math.max(0, Number(fin.periodDebtValue || 0) + carryForwardPrev);

    let carryLine = '';
    if (carryForwardPrev > 0 || dbCarry > 0) {
      const parts = [];
      if (carryForwardPrev > 0) {
        parts.push(`${fmt(carryForwardPrev)}${dbCarry > 0 && dbCarry !== carryForwardPrev ? '' : ''}`);
      }
      if (dbCarry > 0 && dbCarry !== carryForwardPrev) {
        parts.push(`Existing carry-in: ${fmt(dbCarry)}`);
      }
      const combined = parts.length ? parts.join(' + ') : fmt(effectiveCarry);
      carryLine = `<p><strong>Carry Forward (${prevYearLabel}):</strong> ${combined}</p>`;
    }

    const carrySummaryNote = (carryForwardPrev > 0 && dbCarry > 0 && dbCarry === carryForwardPrev)
      ? `<span class="text-xs text-slate-500">(Already captured in ${financeYear} record)</span>`
      : '';

    let html = `
      <p><strong>Name:</strong> ${fullName}</p>
      <p><strong>Admission No:</strong> ${s.admissionNumber || ''}</p>
      <p><strong>Class:</strong> ${s.classLevel || ''}</p>
      <p><strong>Fee (base):</strong> ${fmt(baseFee)}</p>
      ${carryLine || ''}
      ${carrySummaryNote ? `<p class="mt-0">${carrySummaryNote}</p>` : ''}
      <p><strong>Total Due (incl. carry):</strong> ${fmt(totalDue)}</p>
      <p><strong>Payment Plan:</strong> ${s.paymentPlan || ''}</p>
      <p><strong>Debt till:</strong> ${fin.periodDebtLabel} - <strong>${fmt(debtWithCarry)}</strong></p>
      <p><strong>Paid:</strong> ${fmt(paidTotal)}</p>
      <p><strong>Balance (incl. carry):</strong> ${fmt(balanceDisplay)}</p>
    `;
    if (hasFinanceAdminAccess()) {
      html += `
        <div class="mt-3 flex flex-col gap-2">
          <button class="px-3 py-1.5 text-sm bg-amber-500 text-white rounded-md hover:bg-amber-600 transition" data-action="edit-fee-year" data-id="${id}">
            Edit Fee (year)
          </button>
          <span class="text-xs text-slate-500">Updates apply only to ${financeYear} and adjust the base before carry-forward.</span>
        </div>
      `;
    }
    if (!s.hasYearData) {
      html += `
        <div class="mt-2 text-xs text-slate-500">No finance data recorded for ${financeYear}. All totals show as 0 until this year's structure or receipts are captured.</div>
      `;
    }
    html += `
      <hr class="my-3"/>
      <h4 class="font-semibold">Payments Ledger</h4>
    `;
    const paymentEntries = Object.entries(s.payments || {}).filter(([, p]) => p);
    if (!paymentEntries.length) {
      html += '<div class="text-sm text-gray-500">No payments recorded yet.</div>';
    } else {
      const escapeAttr = (value) => String(value).replace(/"/g, '&quot;');
      html += `<div class="overflow-auto"><table class="min-w-full text-xs mt-2"><thead><tr class="table-header"><th class="p-1 border">Date</th><th class="p-1 border">Amount</th><th class="p-1 border">Method</th><th class="p-1 border">Note</th><th class="p-1 border">Actions</th></tr></thead><tbody>`;
      paymentEntries.sort((a, b) => (a[1]?.timestamp || 0) - (b[1]?.timestamp || 0)).forEach(([paymentId, p]) => {
        const d = new Date(p.timestamp || 0).toLocaleString();
        const safeId = escapeAttr(paymentId);
        html += `<tr><td class="p-1 border">${d}</td><td class="p-1 border">${fmt(p.amount)}</td><td class="p-1 border">${p.method || ''}</td><td class="p-1 border">${p.note || ''}</td><td class="p-1 border"><div class="flex gap-1"><button class="px-2 py-0.5 text-[11px] bg-amber-500 text-white rounded" data-action="edit-payment" data-payment-id="${safeId}">Edit</button><button class="px-2 py-0.5 text-[11px] bg-rose-600 text-white rounded" data-action="delete-payment" data-payment-id="${safeId}">Delete</button></div></td></tr>`;
      });
      html += `</tbody></table></div>`;
    }
    detailsContent.innerHTML = html;
    if (hasFinanceAdminAccess()) {
      const editBtn = detailsContent.querySelector('[data-action="edit-fee-year"]');
      if (editBtn) editBtn.addEventListener('click', () => promptEditYearFee(id));
    }
    detailsContent.querySelectorAll('[data-action="edit-payment"]').forEach((btn) => {
      const paymentId = btn.getAttribute('data-payment-id');
      btn.addEventListener('click', () => handleLedgerEdit(id, paymentId));
    });
    detailsContent.querySelectorAll('[data-action="delete-payment"]').forEach((btn) => {
      const paymentId = btn.getAttribute('data-payment-id');
      btn.addEventListener('click', () => handleLedgerDelete(id, paymentId));
    });
    detailsModal.style.display = 'block';
  }
  function closeDetailsModalFn() { detailsModal.style.display = 'none'; detailsContent.innerHTML = ''; }

  function resolveRecorderEmail() {
    if (window.currentUserEmail) return window.currentUserEmail;
    try {
      if (window.sessionStorage) {
        const stored = sessionStorage.getItem('somapUserEmail') || sessionStorage.getItem('userEmail');
        if (stored) return stored;
      }
    } catch (_) {}
    try {
      if (firebase.auth) {
        const user = firebase.auth().currentUser;
        if (user && user.email) return user.email;
      }
    } catch (_) {}
    return 'unknown';
  }

  paymentForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const studentId = studentSelect.value;
    const amount = Number(document.getElementById('paymentAmount').value || 0);
    const paymentDateInput = document.getElementById('paymentDate').value;
    const method = document.getElementById('paymentMethod').value || 'Cash';
    const reference = (document.getElementById('paymentReference').value || '').trim();
    const paidBy = (document.getElementById('paymentPaidBy').value || '').trim();
    const payerContact = (document.getElementById('paymentPayerContact').value || '').trim();
    const note = document.getElementById('paymentNote').value || '';
    if (!studentId) return alert('Choose a student');
    if (amount <= 0) return alert('Enter a valid amount');
    if (!paymentDateInput) return alert('Please select payment date');
    if (!paidBy) return alert('Please enter who made the payment');
    if (!payerContact) return alert('Please enter contact of payer');
    try {
      const studentRef = schoolRef(`students/${studentId}`);
      const snap = await studentRef.once('value');
      const student = snap.val();
      if (!student) throw new Error('Student not found');

      const fin = computeStudentFinancials(student);
      const totalRequired = Number(fin.feePerYear || 0);
      const totalPaidBefore = Number(fin.paidAmount || 0);
      const newBalance = Math.max(0, totalRequired - Math.min(totalRequired, totalPaidBefore + amount));
      const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.replace(/\s+/g, ' ').trim();
      const recorder = resolveRecorderEmail();
      const paymentTimestamp = new Date(paymentDateInput).getTime() || Date.now();
      const parentContact = student.primaryParentContact || student.parentPhone || student.guardianPhone || student.emergencyPhone || '--';

      const pendingRef = schoolRef('approvalsPending').push();
      await pendingRef.set({
        approvalId: pendingRef.key,
        sourceModule: 'finance',
        studentAdm: student.admissionNumber || studentId,
        studentName: fullName || (student.admissionNumber || studentId),
        className: student.classLevel || '',
        parentContact,
        amountPaidNow: Math.round(amount),
        paymentMethod: method,
        paymentReferenceCode: reference || 'N/A',
        datePaid: paymentTimestamp,
        paidBy: paidBy,
        payerContact: payerContact,
        recordedBy: recorder,
        status: 'pending',
        academicYear: financeYear,
        notes: note,
        totalRequired,
        totalPaidBefore,
        newBalanceAfterThis: newBalance,
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        modulePayload: {
          studentKey: studentId,
          payment: {
            amount: Math.round(amount),
            method,
            note,
            timestamp: paymentTimestamp,
            recordedBy: recorder,
            referenceCode: reference || null,
            paidBy: paidBy,
            payerContact: payerContact,
          },
          breakdown: [
            { label: 'Academic Year', value: financeYear },
            { label: 'Plan', value: student.paymentPlan || '--' },
            { label: 'Fee (Year)', value: `TSh ${fmt(totalRequired)}` },
            { label: 'Paid Before', value: `TSh ${fmt(totalPaidBefore)}` },
            { label: 'Balance After Approval', value: `TSh ${fmt(newBalance)}` },
            { label: 'Paid By', value: paidBy },
            { label: 'Payer Contact', value: payerContact },
          ],
        },
      });

      alert('Payment sent for admin approval. Student will update once approved.');
      paymentForm.reset();
      closePaymentModalFn();
      await loadStudents();
    } catch (err) {
      console.error('Error recording payment', err);
      alert('Error recording payment: ' + err.message);
    }
  });

  // ===== Parent mode UI lockdown =====
  function applyParentModeUI(){
    if (!parentCtx.enabled) return;
    
    const fsCard = document.getElementById('financialStatementsCard');
    if (fsCard) fsCard.style.display = 'none';
    
    // Hide filters & bulk exports that could reveal other students
    ['classFilter','showOnlyDebtors','downloadDebtNowCsv','downloadDebtNowPdf',
     'downloadBreakdownCsv','downloadBreakdownPdf'].forEach(id=>{
      const el = document.getElementById(id); 
      if (el) el.style.display = 'none';
    });
    
    // Hide expenses KPIs (parents don't need to see school expenses)
    const kpiCards = document.querySelectorAll('.bg-white.p-4.rounded.shadow');
    if (kpiCards[3]) kpiCards[3].style.display = 'none'; // Total Expenses
    if (kpiCards[4]) kpiCards[4].style.display = 'none'; // Net Balance
    
    // Hide entire expenses section (form, table, reports)
    const expenseSections = document.querySelectorAll('.bg-white.rounded.shadow.p-4.mt-6');
    expenseSections.forEach(section => {
      if (section.querySelector('#expenseForm') || section.querySelector('#expenseTable')) {
        section.style.display = 'none';
      }
    });
    
    // Rename finance KPIs to parent-friendly labels
    const kpiHeaders = document.querySelectorAll('.bg-white.p-4.rounded.shadow h3');
    if (kpiHeaders[0]) kpiHeaders[0].textContent = 'Your Total Due (Year)';
    if (kpiHeaders[1]) kpiHeaders[1].textContent = 'Paid (Total)';
    if (kpiHeaders[2]) kpiHeaders[2].textContent = 'Balance';
    
    // Auto-open the lone breakdown row (there is exactly one row in parent mode)
    setTimeout(() => {
      const onlyId = Object.keys(cachedStudents||{})[0];
      if (onlyId) {
        const br = document.getElementById(`br-${onlyId}`);
        if (br) {
          br.classList.remove('hidden');
          injectIframeIfNeeded(onlyId);
          // Also rotate the chevron
          const expandBtn = document.querySelector(`button.expander[data-id="${onlyId}"]`);
          if (expandBtn) {
            expandBtn.classList.add('open');
            const icon = expandBtn.querySelector('i');
            if (icon) { 
              icon.classList.remove('fa-chevron-down'); 
              icon.classList.add('fa-chevron-up'); 
            }
          }
        }
      }
    }, 100);
  }

  // ===== Data loading and UI wiring =====
  async function loadStudents(year = activeYear) {
    if (!db) return;
    const targetYear = String(year || activeYear);
    activeYear = targetYear;
    financeYear = targetYear;
    try { sessionStorage.setItem('somap_selected_year', targetYear); } catch (_) {}
    updateYearHint();
    if (yearSelectEl && yearSelectEl.value !== targetYear) {
      yearSelectEl.value = targetYear;
    }
    try {
      const [
        baseSnap,
        anchorEnrollSnap,
        enrollmentSnap,
        classFeesSnap,
        stOverridesSnap,
        plansSnap,
        ledgerSnap,
        carrySnap,
        studentFeesSnap
      ] = await Promise.all([
        schoolRef('students').once('value'),
        schoolRef(`enrollments/${SOMAP_DEFAULT_YEAR}`).once('value'),
        schoolRef(`enrollments/${targetYear}`).once('value'),
        schoolRef(`feesStructure/${targetYear}`).once('value'),
        schoolRef(`studentOverrides/${targetYear}`).once('value'),
        schoolRef(`installmentPlans/${targetYear}`).once('value'),
        schoolRef(`financeLedgers/${targetYear}`).once('value'),
        schoolRef(`financeCarryForward/${targetYear}`).once('value'),
        schoolRef(`studentFees/${targetYear}`).once('value'),
      ]);
      const baseStudents = baseSnap.val() || {};
      let ledgerData = ledgerSnap.val() || {};
      if (!Object.keys(ledgerData || {}).length) {
        try {
          const legacyLedgerSnap = await schoolRef('financeLedgers').once('value');
          ledgerData = legacyLedgerSnap.val() || {};
        } catch (legacyErr) {
          console.warn('Legacy financeLedgers read failed', legacyErr?.message || legacyErr);
        }
      }
      let studentFeesData = studentFeesSnap.val() || {};
      if (!Object.keys(studentFeesData || {}).length) {
        try {
          const legacyStudentFeesSnap = await schoolRef(`finance/${targetYear}/studentFees`).once('value');
          studentFeesData = legacyStudentFeesSnap.val() || {};
        } catch (studentFeesErr) {
          console.warn('Student fee override read failed', studentFeesErr?.message || studentFeesErr);
        }
      }
      const approvalsByStudent = await loadApprovedFinanceApprovals(targetYear, true);
      cachedStudents = buildFinanceStudents(
        baseStudents,
        anchorEnrollSnap.val() || {},
        enrollmentSnap.val() || {},
        classFeesSnap.val() || {},
        stOverridesSnap.val() || {},
        plansSnap.val() || {},
        ledgerData,
        carrySnap.val() || {},
        studentFeesData,
        approvalsByStudent,
        targetYear
      );
      if (!Object.keys(cachedStudents).length) {
        cachedStudents = baseStudents;
      }

      // ===== Parent mode: filter to single learner =====
      if (parentCtx.enabled) {
        let targetId = parentCtx.studentId;
        if (!targetId && parentCtx.adm) {
          targetId = Object.keys(cachedStudents||{}).find(k =>
            String(cachedStudents[k]?.admissionNumber||'') === String(parentCtx.adm)
          );
        }
        if (!targetId || !cachedStudents[targetId]) {
          // Clear table and show a friendly message; do not leak other records
          const tbodyEl = document.querySelector('#financeTable tbody');
          if (tbodyEl) tbodyEl.innerHTML =
            `<tr><td colspan="10" class="p-4 text-center text-sm text-slate-600">
              No finance record found for this learner.
            </td></tr>`;
          // Also lock KPIs to 0
          ['totalDue','totalCollected','totalOutstanding'].forEach(id=>{
            const el = document.getElementById(id);
            if (el){ el.textContent = '0'; el.dataset.amount = '0'; }
          });
          const countEl = document.getElementById('financeStudentCount');
          if (countEl) countEl.textContent = '0';
          // Stop further rendering in parent scope
          populateStudentSelect();
          applyParentModeUI();
          return;
        }
        // Reduce dataset to the single learner
        cachedStudents = { [targetId]: cachedStudents[targetId] };
      }

      populateStudentSelect();
      renderTable();
      if (parentCtx.enabled) {
        applyParentModeUI();
      }
    } catch (err) {
      console.error('Error loading students:', err);
      alert('Error loading students: ' + err.message);
    }
  }

  document.getElementById("downloadExpenseCsv").addEventListener("click", () => {
    const rows = [["Category", "Description", "Amount", "Date"]];
    document.querySelectorAll("#expenseTable tbody tr").forEach(tr => {
      const cells = [...tr.querySelectorAll("td")].map(td => td.innerText);
      rows.push(cells);
    });
    const ws = XLSX.utils.aoa_to_sheet(rows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Expenses");
    XLSX.writeFile(wb, "expenses_report.xlsx");
  });

  document.getElementById("downloadExpensePdf").addEventListener("click", () => {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    doc.text("Expense Report", 14, 10);
    const rows = [];
    document.querySelectorAll("#expenseTable tbody tr").forEach(tr => {
      const cells = [...tr.querySelectorAll("td")].map(td => td.innerText);
      rows.push(cells);
    });
    doc.autoTable({ head: [["Category", "Description", "Amount", "Date"]], body: rows, startY: 20 });
    doc.save("expenses_report.pdf");
  });

  closePaymentModal.addEventListener('click', closePaymentModalFn);
  cancelPayment.addEventListener('click', closePaymentModalFn);
  closeDetailsModal.addEventListener('click', closeDetailsModalFn);
  showOnlyDebtorsBtn.addEventListener('click', () => {
    showingDebtorsOnly = !showingDebtorsOnly;
    showOnlyDebtorsBtn.textContent = showingDebtorsOnly ? 'Showing Debtors' : 'Show Debtors';
    renderTable();
  });
  downloadCsvBtn.addEventListener('click', downloadCSV_Main);
  downloadPdfBtn.addEventListener('click', downloadPDF_Main);
  downloadDebtNowCsvBtn.addEventListener('click', downloadCSV_DebtNow);
  downloadDebtNowPdfBtn.addEventListener('click', downloadPDF_DebtNow);
  downloadBreakdownCsvBtn.addEventListener('click', downloadCSV_Breakdown);
  downloadBreakdownPdfBtn.addEventListener('click', downloadPDF_Breakdown);
  reloadBtn.addEventListener('click', async () => { await refreshFinanceData(financeYear); });

  if (yearContext) {
    yearContext.onYearChanged((year) => {
      const normalized = String(year);
      if (normalized === financeYear) return;
      financeYear = normalized;
      activeYear = normalized;
      try { sessionStorage.setItem('somap_selected_year', normalized); } catch (_) {}
      if (yearSelectEl && yearSelectEl.value !== normalized) {
        yearSelectEl.value = normalized;
      }
      refreshFinanceData(normalized);
    });
  }
  window.addEventListener('click', ev => {
    if (ev.target === paymentModal) closePaymentModalFn();
    if (ev.target === detailsModal) closeDetailsModalFn();
  });
  classFilter.addEventListener('change', renderTable);
  document.addEventListener('DOMContentLoaded', () => {
    updateYearHint();
    refreshFinanceData(activeYear);
  });
})();
</script>

<script>
/** SoMAp v2.1 — Carry-Forward Debts (2025→)
 *  Non-invasive decorator for finance.html
 *  - Adds previous-year (>=2025) unpaid balance to current year's Fee (year)
 *  - Exposes data-carry-forward for payment.html (iframe) to pick for January
 */
(function carryForwardPatch() {
  const START_YEAR = 2025;
  const sharedCache = window.__financeCarryForwardVisual || (window.__financeCarryForwardVisual = {});
  let scheduled = false;
  let running = false;

  function detectTargetYear() {
    if (window.currentAcademicYear && Number(window.currentAcademicYear)) return Number(window.currentAcademicYear);
    if (window.somapYearContext?.getSelectedYear) {
      const ctxYear = Number(window.somapYearContext.getSelectedYear());
      if (!Number.isNaN(ctxYear)) return ctxYear;
    }
    const sel = document.querySelector('#yearSelect, select[name="year"], [data-somap-year-select]');
    if (sel) {
      const v = Number(sel.value || sel.textContent);
      if (!Number.isNaN(v)) return v;
    }
    const maybe = (document.title || '').match(/\b(20\d{2})\b/);
    if (maybe) return Number(maybe[1]);
    return new Date().getFullYear();
  }

  async function getPrevYearBalance(adm, prevYear) {
    if (!adm) return 0;
    if (typeof window.__finance_getBalanceForYearAdmission === 'function') {
      return Number(await window.__finance_getBalanceForYearAdmission(prevYear, adm)) || 0;
    }
    if (window.firebase?.database) {
      try {
        const ref = window.firebase.database().ref(`finance/${prevYear}/students/${adm}`);
        const snap = await ref.get();
        if (snap.exists()) {
          const d = snap.val();
          if (d.balance !== undefined) return Number(d.balance) || 0;
          const feeYear = Number(String(d.feeYear || d.fee || 0).replace(/[^\d]/g, '')) || 0;
          const paid = Number(String(d.paid || 0).replace(/[^\d]/g, '')) || 0;
          return Math.max(feeYear - paid, 0);
        }
      } catch (err) {
        console.warn('CarryForward fallback fetch failed', adm, prevYear, err);
      }
    }
    return 0;
  }

  function parseNumberLike(x) {
    if (typeof x === 'number') return x;
    return Number(String(x || '0').replace(/[^\d]/g, '')) || 0;
  }

  function formatTSh(n) {
    const value = Number(n) || 0;
    try {
      return new Intl.NumberFormat('en-KE', {
        style: 'currency',
        currency: 'TZS',
        maximumFractionDigits: 0,
      }).format(value);
    } catch (err) {
      return 'TSh ' + value.toLocaleString('en-US');
    }
  }

  function formatNumber(n) {
    return (Number(n) || 0).toLocaleString('en-US');
  }

  function adjustKpis(delta) {
    if (!delta) return;
    const targets = ['totalDue', 'totalOutstanding'];
    targets.forEach((id) => {
      const el = document.getElementById(id);
      if (!el) return;
      const current = parseNumberLike(el.dataset.amount || el.textContent);
      const next = current + delta;
      el.dataset.amount = String(next);
      el.textContent = formatNumber(next);
    });
  }

  function findFinanceTableRows() {
    const table = document.getElementById('financeTable');
    if (!table) return [];
    const rows = Array.from(table.querySelectorAll('tbody tr')).filter(tr => tr.children.length >= 10);
    return rows.map(tr => {
      const tds = Array.from(tr.children);
      const adm = (tds[1]?.innerText || '').trim();
      const feeYearCell = tds[4] || null;
      const feeYear = parseNumberLike(tds[4]?.innerText);
      return { tr, tds, adm, feeYearCell, feeYear };
    }).filter(entry => entry.adm);
  }

  async function decorateWithCarryForward() {
    if (running) {
      scheduled = true;
      return;
    }
    running = true;
    const targetYear = detectTargetYear();
    const prevYear = targetYear - 1;
    if (!Number.isFinite(prevYear) || prevYear < START_YEAR) {
      running = false;
      return;
    }
    const rows = findFinanceTableRows();
    if (!rows.length) {
      running = false;
      return;
    }
    const uniqueAdms = [...new Set(rows.map(r => r.adm))];
    const cfMap = new Map();
    await Promise.all(uniqueAdms.map(async (adm) => {
      const carry = await getPrevYearBalance(adm, prevYear);
      cfMap.set(adm, Math.max(0, Number(carry) || 0));
    }));

    rows.forEach(row => {
      const carry = cfMap.get(row.adm) || 0;
      const hasCF = carry > 0;
      row.tr.dataset.carryForward = hasCF ? String(carry) : '0';
      row.tr.dataset.carryForwardYear = String(prevYear);
      const storeKey = `${targetYear}::${row.adm}`;
      const lookup = typeof window.__finance_lookupStudent === 'function'
        ? window.__finance_lookupStudent(row.adm)
        : null;
      const student = lookup?.student || null;

      let originalDisplayedDue = row.feeYear;
      let newTotalDue = originalDisplayedDue;
      let appliedCarry = 0;

      if (student) {
        const existingCarry = Math.max(0, Number(student.carryAmount || 0));
        const currentFeePerYear = Math.max(0, Number(student.feePerYear || 0));
        const inferredBase = Math.max(0, Number(
          student.baseFee ??
          (currentFeePerYear > existingCarry ? currentFeePerYear - existingCarry : 0)
        ));

        student.__carryOverlayAmount = carry;
        student.__carryOverlayPrevYear = prevYear;
        student.__carryOverlayYear = targetYear;

        appliedCarry = Math.max(0, carry - existingCarry);
        if (appliedCarry > 0) {
          student.baseFee = inferredBase;
          student.carryAmount = existingCarry + appliedCarry;
          student.feePerYear = Math.max(0, currentFeePerYear || inferredBase + existingCarry) + appliedCarry;
          student.__carryOverlayMerged = true;
        }

        newTotalDue = Math.max(0, Number(student.feePerYear || inferredBase + existingCarry + appliedCarry));
      } else if (hasCF) {
        appliedCarry = carry;
        newTotalDue = row.feeYear + appliedCarry;
      }

      if (hasCF) {
        sharedCache[storeKey] = { carry, prevYear, total: newTotalDue };
        try {
          sessionStorage.setItem(`somap_cf_${targetYear}_${row.adm}`, String(carry));
        } catch (_) {}
      } else {
        delete sharedCache[storeKey];
        try {
          sessionStorage.removeItem(`somap_cf_${targetYear}_${row.adm}`);
        } catch (_) {}
      }

      row.tr.dataset.carryForwardTotal = String(newTotalDue);

      const delta = Math.max(0, newTotalDue - originalDisplayedDue);
      if (delta > 0) {
        adjustKpis(delta);
      }

      if (row.feeYearCell) {
        if (row.feeYearCell.firstChild && row.feeYearCell.firstChild.nodeType === Node.TEXT_NODE) {
          row.feeYearCell.firstChild.textContent = formatNumber(newTotalDue);
        } else {
          row.feeYearCell.textContent = formatNumber(newTotalDue);
        }
        row.feeYearCell.querySelectorAll('[data-cf-badge]').forEach(el => el.remove());
      }

      if (hasCF && row.feeYearCell) {
        const badge = document.createElement('div');
        badge.dataset.cfBadge = 'badge';
        badge.className = 'text-xs mt-1';
        badge.innerHTML = `<span class="px-2 py-0.5 rounded bg-yellow-100 text-yellow-700">Carry Forward (${prevYear}): ${formatTSh(carry)}</span>`;
        const totalLine = document.createElement('div');
        totalLine.dataset.cfBadge = 'total';
        totalLine.className = 'text-sm font-semibold mt-1';
        totalLine.textContent = `Total Due (incl. CF): ${formatTSh(newTotalDue)}`;
        row.feeYearCell.appendChild(badge);
        row.feeYearCell.appendChild(totalLine);
      }

      const paidCell = row.tds[6];
      const balanceCell = row.tds[7];
      const paidAmount = parseNumberLike(paidCell?.innerText || '0');
      const newBalance = Math.max(0, newTotalDue - paidAmount);
      if (balanceCell) {
        balanceCell.textContent = formatNumber(newBalance);
      }

      row.feeYear = newTotalDue;
    });
    running = false;
    if (scheduled) {
      scheduled = false;
      decorateWithCarryForward();
    }
  }

  function queueRun() {
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(decorateWithCarryForward, 0);
    } else {
      document.addEventListener('DOMContentLoaded', () => setTimeout(decorateWithCarryForward, 0), { once: true });
    }
  }

  document.addEventListener('finance:tableRendered', () => setTimeout(decorateWithCarryForward, 0));
  queueRun();
})();
</script>
</body>
</html>
