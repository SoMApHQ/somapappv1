<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-analytics-compat.js"></script>
  <script src="somapappv1multischool/js/context.js"></script>
  <script src="Todashboardhtml/yearContext.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-storage-compat.js"></script>
  <script src="firebase.js"></script>
  <script src="js/finance_core.js"></script>
  <script src="js/finance_dedupe.js"></script>
  <script src="js/finance_cashbook.js"></script>
  <title>SoMAp - Finance</title>

  <!-- UI -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>

  <!-- Exports -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.0/jspdf.plugin.autotable.min.js"></script>

  <style>
    body { background: #f8fafc; }
    .table-header { background: #eef2ff; color: #1f2937; }
    .table-row:nth-child(even) { background: #ffffff; }
    .table-row-overdue { background: #fef2f2 !important; }
    .modal { display:none; position:fixed; inset:0; background: rgba(0,0,0,0.5); z-index:1000; }
    .modal-content { background:#fff; max-width:800px; margin:4% auto; padding:18px; border-radius:8px; height:80vh; overflow:auto; }
    .expander { cursor: pointer; transition: transform .2s ease; }
    .expander .fa { transition: transform .2s ease; }
    .expander.open .fa { transform: rotate(180deg); }
    .status-pill { padding:2px 8px; border-radius:999px; font-size: 11px; font-weight:600; }
    .status-paid { background:#dcfce7; color:#166534; }
    .status-partial { background:#fef9c3; color:#854d0e; }
    .status-overdue { background:#fee2e2; color:#991b1b; }
    /* tiny shimmer used before iframe mounts */
    .skel { position: relative; overflow: hidden; background: #f1f5f9; }
    .skel::after {
      content: ""; position:absolute; inset:0;
      background: linear-gradient(90deg, rgba(241,245,249,0) 0%, rgba(226,232,240,.8) 50%, rgba(241,245,249,0) 100%);
      transform: translateX(-100%); animation: shimmer 1.2s infinite;
    }
    @keyframes shimmer { 100% { transform: translateX(100%); } }
  </style>
</head>

<body class="p-6">
  <div class="max-w-6xl mx-auto">
    <header class="mb-6 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
      <div class="flex flex-col">
        <h1 class="text-2xl font-semibold text-indigo-700">
          SoMAp Finance
          <span id="financeSchoolLabel" class="ml-2 inline-flex items-center px-3 py-1 rounded-full bg-indigo-50 text-indigo-700 border border-indigo-100 text-xs font-semibold"></span>
        </h1>
        <p class="mt-1 text-sm font-medium text-indigo-600/80">
          Working year: <span id="financeYearLabel">--</span>
          <span class="ml-3 text-slate-600">Students: <span id="financeStudentCount" class="font-semibold text-slate-900">--</span></span>
        </p>
      </div>
      <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:gap-3">
        <label class="flex items-center gap-2 rounded-lg border border-indigo-200 bg-indigo-50/70 px-3 py-1 text-xs font-semibold uppercase tracking-wide text-indigo-700">
          <span class="hidden sm:inline text-[0.7rem]">Academic Year</span>
          <select
            data-somap-year-select
            class="min-w-[120px] rounded-md border border-indigo-200 bg-white px-2 py-1 text-sm font-medium text-indigo-700 focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-200"
          >
          </select>
        </label>
        <button id="reloadBtn" class="px-3 py-1 bg-indigo-600 text-white rounded">Reload</button>
        <a href="index.html" class="px-3 py-1 border rounded text-sm">Back to Dashboard</a>
      </div>
    </header>

    <!-- KPIs -->
    <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-6">
      <div class="bg-white p-4 rounded shadow">
        <h3 class="text-sm text-gray-500">Total Due (All Students)</h3>
        <div id="totalDue" class="text-xl font-semibold mt-2">--</div>
      </div>
      <div class="bg-white p-4 rounded shadow">
        <h3 class="text-sm text-gray-500">Total Collected</h3>
        <div id="totalCollected" class="text-xl font-semibold mt-2">--</div>
      </div>
      <div class="bg-white p-4 rounded shadow">
        <h3 class="text-sm text-gray-500">Total Outstanding (Due – Collected)</h3>
        <div id="totalOutstanding" class="text-xl font-semibold mt-2">--</div>
      </div>
      <div class="bg-white p-4 rounded shadow">
        <h3 class="text-sm text-gray-500">Total Expenses</h3>
        <div id="totalExpenses" class="text-xl font-semibold mt-2">--</div>
      </div>
      <div class="bg-white p-4 rounded shadow">
        <h3 class="text-sm text-gray-500">Net Balance (Collected - Expenses)</h3>
        <div id="netBalance" class="text-xl font-semibold mt-2">--</div>
      </div>
      <a id="financialStatementsCard" href="Tofinancehtml/financialstatements/fs_dashboard.html" class="bg-gradient-to-br from-indigo-600 to-emerald-500 p-4 rounded shadow text-white flex flex-col justify-between">
        <div>
          <h3 class="text-sm font-semibold">Financial Statements</h3>
          <p class="text-xs text-indigo-50 mt-1">Prepare TRA-ready P&L, Balance Sheet, Cash Flow.</p>
        </div>
        <span class="mt-3 inline-flex items-center text-sm font-semibold">Open module <i class="fa fa-arrow-right ml-2"></i></span>
      </a>
    </div>

    <!-- Filters + actions -->
    <div class="flex items-center justify-between mb-4">
      <div class="flex items-center gap-3">
        <label class="text-sm text-gray-600">Filter by class</label>
        <select id="classFilter" class="p-2 border rounded"></select>
        <button id="showOnlyDebtors" class="px-3 py-1 bg-yellow-500 text-white rounded text-sm">Show Debtors</button>
      </div>
      <div class="flex items-center gap-2">
        <button id="downloadCsv" class="px-3 py-1 bg-indigo-600 text-white rounded"><i class="fa fa-file-excel mr-1"></i> Main CSV</button>
        <button id="downloadPdf" class="px-3 py-1 bg-red-600 text-white rounded"><i class="fa fa-file-pdf mr-1"></i> Main PDF</button>
        <button id="downloadDebtNowCsv" class="px-3 py-1 bg-amber-600 text-white rounded"><i class="fa fa-file-excel mr-1"></i> Debt (current) CSV</button>
        <button id="downloadDebtNowPdf" class="px-3 py-1 bg-amber-700 text-white rounded"><i class="fa fa-file-pdf mr-1"></i> Debt (current) PDF</button>
        <button id="downloadBreakdownCsv" class="px-3 py-1 bg-teal-600 text-white rounded"><i class="fa fa-file-excel mr-1"></i> Breakdown CSV</button>
        <button id="downloadBreakdownPdf" class="px-3 py-1 bg-teal-700 text-white rounded"><i class="fa fa-file-pdf mr-1"></i> Breakdown PDF</button>
      </div>
    </div>

    <!-- Table -->
    <div class="bg-white rounded shadow overflow-x-auto">
      <table id="financeTable" class="min-w-full text-sm">
        <thead>
          <tr class="table-header">
            <th class="p-2 border"></th>
            <th class="p-2 border">Admission No</th>
            <th class="p-2 border">Full Name</th>
            <th class="p-2 border">Class</th>
            <th class="p-2 border">Fee (year)</th>
            <th class="p-2 border">Payment Plan</th>
            <th class="p-2 border">Paid</th>
            <th class="p-2 border">Balance (Year)</th>
            <th class="p-2 border">Debt till …</th>
            <th class="p-2 border">Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Cashbook + Expenses -->
    <div class="grid grid-cols-1 xl:grid-cols-2 gap-6 mt-6">
      <div id="cashbookSection" class="bg-white rounded shadow p-4">
        <div class="flex items-start justify-between gap-3 mb-3">
          <h2 class="text-lg font-semibold text-indigo-700">School Cashbook</h2>
          <span id="cashbookTitleYear" class="text-xs px-2 py-1 rounded bg-indigo-50 border border-indigo-100 text-indigo-700"></span>
        </div>

        <div class="grid grid-cols-2 gap-3 mb-4">
          <div class="rounded border p-3 bg-slate-50">
            <div class="text-xs text-slate-500">Accountant Pocket</div>
            <div id="cashbookPocket" class="text-lg font-semibold mt-1">--</div>
          </div>
          <div class="rounded border p-3 bg-slate-50">
            <div class="text-xs text-slate-500">Total Cashbook Received</div>
            <div id="cashbookReceived" class="text-lg font-semibold mt-1">--</div>
          </div>
          <div class="rounded border p-3 bg-slate-50">
            <div class="text-xs text-slate-500">From Main Income</div>
            <div id="cashbookMainIncome" class="text-lg font-semibold mt-1">--</div>
          </div>
          <div class="rounded border p-3 bg-slate-50">
            <div class="text-xs text-slate-500">Refund Corner</div>
            <div id="cashbookRefundCorner" class="text-lg font-semibold mt-1">--</div>
          </div>
        </div>

        <form id="cashbookFundingForm" class="grid md:grid-cols-2 gap-3 mb-4">
          <input id="cashbookAmount" type="number" min="1" placeholder="Amount Received" required class="p-2 border rounded">
          <input id="cashbookDate" type="date" required class="p-2 border rounded">
          <input id="cashbookReceivedFrom" type="text" placeholder="Received From (e.g. Mnyore)" required class="p-2 border rounded">
          <input id="cashbookReceivedBy" type="text" placeholder="Received By (Accountant)" required class="p-2 border rounded">
          <select id="cashbookEntryType" required class="p-2 border rounded md:col-span-2">
            <option value="deduct_main_income">Deduct from school income</option>
            <option value="external_support">Do not deduct (Msaada/Support)</option>
            <option value="refundable">Refundable cash (put to refund corner)</option>
          </select>
          <input id="cashbookNote" type="text" placeholder="Short note (optional)" class="p-2 border rounded md:col-span-2">
          <button type="submit" class="px-4 py-2 bg-emerald-600 text-white rounded md:col-span-2">Record Cashbook Receipt</button>
        </form>

        <table id="cashbookTable" class="min-w-full text-sm border">
          <thead>
            <tr class="table-header">
              <th class="p-2 border">Date</th>
              <th class="p-2 border">From</th>
              <th class="p-2 border">Received By</th>
              <th class="p-2 border">Type</th>
              <th class="p-2 border">Amount</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="bg-white rounded shadow p-4">
        <h2 class="text-lg font-semibold text-indigo-700 mb-3">Expenses</h2>
        <p class="text-xs text-slate-500 mb-3">Expenses reduce accountant pocket cashbook balance only (not main collected directly).</p>
        <form id="expenseForm" class="grid md:grid-cols-2 gap-3 mb-4">
          <select id="expenseCategory" required class="p-2 border rounded">
            <option value="">Select Category</option>
            <option>FOOD</option>
            <option>SALARIES</option>
            <option>OFFICE</option>
            <option>EDUCATION</option>
            <option>WATER & ELECTRICITY</option>
            <option>SANITATION</option>
            <option>ENVIRONMENT</option>
            <option>HEALTH</option>
            <option>SECURITY</option>
            <option>CLOTHING</option>
            <option>SHELTER</option>
            <option>RECREATION</option>
            <option>PROJECTS</option>
            <option>TRANSPORT</option>
            <option>PURCHASES</option>
            <option>SIL</option>
            <option>MAINTENANCE</option>
            <option>BOOKS</option>
            <option>EMERGENCY</option>
            <option>MISCELLANEOUS</option>
          </select>
          <input id="expenseDescription" type="text" placeholder="Description" required class="p-2 border rounded">
          <input id="expenseAmount" type="number" min="1" placeholder="Amount" required class="p-2 border rounded">
          <input id="expenseDate" type="date" required class="p-2 border rounded">
          <button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded md:col-span-2">Add Expense</button>
        </form>
        <div class="flex items-center gap-2 mb-3">
          <button id="downloadExpenseCsv" class="px-3 py-1 bg-green-600 text-white rounded">Download Expense Report (CSV)</button>
          <button id="downloadExpensePdf" class="px-3 py-1 bg-red-600 text-white rounded">Download Expense Report (PDF)</button>
        </div>
        <table id="expenseTable" class="min-w-full text-sm border">
          <thead>
            <tr class="table-header">
              <th class="p-2 border">Category</th>
              <th class="p-2 border">Description</th>
              <th class="p-2 border">Amount</th>
              <th class="p-2 border">Date</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <!-- Payment modal -->
    <div id="paymentModal" class="modal">
      <div class="modal-content">
        <span id="closePaymentModal" class="float-right cursor-pointer text-2xl">&times;</span>
        <h2 class="text-lg font-semibold text-indigo-700 mb-3">Record Payment</h2>
        <form id="paymentForm" class="space-y-3">
          <div>
            <label class="text-sm text-gray-600">Student</label>
            <select id="studentSelect" class="w-full p-2 border rounded" required></select>
          </div>
          <div>
            <label class="text-sm text-gray-600">Amount</label>
            <input id="paymentAmount" type="number" step="1" min="1" class="w-full p-2 border rounded" required />
          </div>
          <div>
            <label class="text-sm text-gray-600">Payment Date</label>
            <input id="paymentDate" type="date" class="w-full p-2 border rounded" required />
          </div>
          <div>
            <label class="text-sm text-gray-600">Method</label>
            <select id="paymentMethod" class="w-full p-2 border rounded">
              <option>Cash</option>
              <option>MPesa</option>
              <option>Airtel Money</option>
              <option>TigoPesa</option>
              <option>Bank Transfer</option>
              <option>Other</option>
            </select>
          </div>
          <div>
            <label class="text-sm text-gray-600">Reference Code (MPesa / Receipt / Bank)</label>
            <input id="paymentReference" type="text" class="w-full p-2 border rounded" placeholder="e.g. MPESA1ABC23" />
          </div>
          <div>
            <label class="text-sm text-gray-600">Paid By (Name)</label>
            <input id="paymentPaidBy" type="text" class="w-full p-2 border rounded" placeholder="e.g. Parent name or Admin name" required />
          </div>
          <div>
            <label class="text-sm text-gray-600">Contact of Payer</label>
            <input id="paymentPayerContact" type="tel" class="w-full p-2 border rounded" placeholder="e.g. +255..." required />
          </div>
          <div>
            <label class="text-sm text-gray-600">Note (optional)</label>
            <input id="paymentNote" type="text" class="w-full p-2 border rounded" />
          </div>
          <div class="flex space-x-2">
            <button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded">Save Payment</button>
            <button id="cancelPayment" type="button" class="px-4 py-2 border rounded">Cancel</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Details modal -->
    <div id="detailsModal" class="modal">
      <div class="modal-content">
        <span id="closeDetailsModal" class="float-right cursor-pointer text-2xl">&times;</span>
        <h2 class="text-lg font-semibold text-indigo-700 mb-3">Student Finance Details</h2>
        <div id="detailsContent"></div>
      </div>
    </div>
  </div>

<script>
(function () {
  /* ===== Parent mode detection (non-destructive) ===== */
  const parentCtx = { enabled:false, studentId:null, adm:null, year:null, className:null };
  (function detectParentMode(){
    const q = new URLSearchParams(location.search);
    const scope = (q.get('scope')||'').toLowerCase();
    if (scope === 'parent') {
      parentCtx.enabled  = true;
      parentCtx.studentId= q.get('student');
      parentCtx.adm      = q.get('adm');
      parentCtx.year     = q.get('year');
      parentCtx.className= q.get('class');
      try {
        sessionStorage.setItem('parent_scope','1');
        if (parentCtx.studentId) sessionStorage.setItem('parent_student', parentCtx.studentId);
        if (parentCtx.adm)       sessionStorage.setItem('parent_adm', parentCtx.adm);
        if (parentCtx.year)      sessionStorage.setItem('parent_year', parentCtx.year);
        if (parentCtx.className) sessionStorage.setItem('parent_class', parentCtx.className);
      } catch(_) {}
    } else if (sessionStorage.getItem('parent_scope') === '1') {
      parentCtx.enabled   = true;
      parentCtx.studentId = sessionStorage.getItem('parent_student');
      parentCtx.adm       = sessionStorage.getItem('parent_adm');
      parentCtx.year      = sessionStorage.getItem('parent_year');
      parentCtx.className = sessionStorage.getItem('parent_class');
    }
  })();

  const SOMAP_DEFAULT_YEAR = 2025;
  const CARRY_FORWARD_START_YEAR = 2025;
  const FINANCE_ADMIN_EMAIL = 'socratesschool2020@gmail.com';
  const CLASS_ORDER = ['Baby Class','Middle Class','Pre Unit Class','Class 1','Class 2','Class 3','Class 4','Class 5','Class 6','Class 7'];
  const norm = (s) => String(s || '').trim().toLowerCase();
  function canonClass(name) {
    const n = norm(name);
    if (!n) return '';
    if (n === 'pre unit' || n === 'preunit' || n === 'pre-unit' || n === 'pre unit class') return 'Pre Unit Class';
    if (n === 'baby' || n === 'baby class') return 'Baby Class';
    if (n === 'middle' || n === 'middle class') return 'Middle Class';
    const m = n.match(/^class\s*(\d+)$/);
    if (m) return `Class ${m[1]}`;
    if (n === 'graduated') return 'GRADUATED';
    return String(name || '').trim();
  }
  function shiftClass(baseName, deltaYears) {
    const base = canonClass(baseName);
    const i = CLASS_ORDER.findIndex((c) => norm(c) === norm(base));
    if (i < 0) return base || '';
    const j = i + Number(deltaYears || 0);
    if (j < 0) return 'PRE-ADMISSION';
    if (j >= CLASS_ORDER.length) return 'GRADUATED';
    return CLASS_ORDER[j];
  }

  function resolveFinanceSchoolId() {
    if (window.currentSchoolId) return window.currentSchoolId;
    const params = new URLSearchParams(location.search || '');
    const candidate = params.get('school') || params.get('schoolId') || (function () {
      try { return localStorage.getItem('somap_school'); } catch (_) { return ''; }
    })() || 'socrates';
    const normalized = String(candidate || '').trim() || 'socrates';
    window.currentSchoolId = normalized;
    return normalized;
  }

  const db = window.db || null;
  const currentSchool = window.SOMAP && SOMAP.getSchool();
  if (!currentSchool || !currentSchool.id) {
    window.location.href = "somapappv1multischool/multischool.html";
  }
  const isSocratesSchool = String(currentSchool?.id || '').trim().toLowerCase() === 'socrates-school';
  window.currentSchoolId = currentSchool?.id;
  const financeSchoolLabel = document.getElementById('financeSchoolLabel');
  if (financeSchoolLabel) {
    financeSchoolLabel.textContent = currentSchool.name || currentSchool.code || currentSchool.id || 'School';
  }

  function schoolRef(subPath) {
    return db.ref(SOMAP.P(subPath));
  }
  const yearContext = window.somapYearContext || null;
  const yearSelectEl = document.querySelector('[data-somap-year-select]');
  const financeQuery = new URLSearchParams(location.search);
  let financeYear = financeQuery.get('year')
    || (yearContext?.getSelectedYear?.())
    || (() => { try { return sessionStorage.getItem('somap_selected_year'); } catch (_) { return null; } })()
    || SOMAP_DEFAULT_YEAR;
  financeYear = String(financeYear);
  let activeYear = financeYear;
  const activeSchoolId = resolveFinanceSchoolId();
  try { sessionStorage.setItem('somap_selected_year', financeYear); } catch (_) {}
  if (yearContext?.setSelectedYear) {
    yearContext.setSelectedYear(financeYear, { manual: false });
  }
  if (yearSelectEl) {
    yearSelectEl.value = financeYear;
    yearSelectEl.addEventListener('change', (e) => {
      const newYear = String(e.target.value || SOMAP_DEFAULT_YEAR);
      if (newYear === financeYear) return;
      financeYear = newYear;
      activeYear = newYear;
      try { sessionStorage.setItem('somap_selected_year', newYear); } catch (_) {}
      refreshFinanceData(newYear);
      window.somapYearContext?.setSelectedYear?.(newYear);
    });
  }

  function hasFinanceAdminAccess() {
    try {
      const role = sessionStorage.getItem('somap_role');
      if (role && String(role).toLowerCase() === 'admin') return true;
    } catch (_) {}
    const emails = [];
    if (window.currentUserEmail) emails.push(window.currentUserEmail);
    try {
      const stored = sessionStorage.getItem('somapUserEmail');
      if (stored) emails.push(stored);
    } catch (_) {}
    try {
      const storedLegacy = sessionStorage.getItem('userEmail');
      if (storedLegacy) emails.push(storedLegacy);
    } catch (_) {}
    try {
      const authEmail = firebase?.auth?.()?.currentUser?.email;
      if (authEmail) emails.push(authEmail);
    } catch (_) {}
    return emails.some((email) => String(email).toLowerCase() === FINANCE_ADMIN_EMAIL.toLowerCase());
  }

  const tbody = document.querySelector('#financeTable tbody');
  const studentSelect = document.getElementById('studentSelect');
  const paymentModal = document.getElementById('paymentModal');
  const closePaymentModal = document.getElementById('closePaymentModal');
  const paymentForm = document.getElementById('paymentForm');
  const cancelPayment = document.getElementById('cancelPayment');
  const detailsModal = document.getElementById('detailsModal');
  const closeDetailsModal = document.getElementById('closeDetailsModal');
  const detailsContent = document.getElementById('detailsContent');
  const CLASS_FILTERS = ['All Classes','Baby Class','Middle Class','Pre Unit','Pre Unit Class','Class 1','Class 2','Class 3','Class 4','Class 5','Class 6','Class 7'];
  const classFilter = document.getElementById('classFilter');
  const showOnlyDebtorsBtn = document.getElementById('showOnlyDebtors');
  const yearHint = document.getElementById('financeYearLabel');
  const downloadCsvBtn = document.getElementById('downloadCsv');
  const downloadPdfBtn = document.getElementById('downloadPdf');
  const downloadDebtNowCsvBtn = document.getElementById('downloadDebtNowCsv');
  const downloadDebtNowPdfBtn = document.getElementById('downloadDebtNowPdf');
  const downloadBreakdownCsvBtn = document.getElementById('downloadBreakdownCsv');
  const downloadBreakdownPdfBtn = document.getElementById('downloadBreakdownPdf');
  const reloadBtn = document.getElementById('reloadBtn');

  let cachedStudents = {};
  let financeDeadlineWatcher = null;
  let financeDeadlineWatcherYear = null;
  let financeAggregateSnapshot = { totalStudents: 0, totalDue: 0, totalCollected: 0, totalOutstanding: 0, totalExpenses: 0 };
  const cashbookToolkit = window.SomapFinanceCashbook || null;
  let baseCollectedFromFees = 0;
  let lastExpenseEntries = [];
  let lastCashbookFundingEntries = [];
  let cashbookSummary = {
    totalReceived: 0,
    deductFromMain: 0,
    externalSupport: 0,
    refundCorner: 0,
    totalExpenses: 0,
    inPocket: 0,
  };
  function lookupStudentByAdmission(adm) {
    const normalized = String(adm || '').trim();
    if (!normalized) return null;
    if (cachedStudents[normalized]) {
      return { id: normalized, student: cachedStudents[normalized] };
    }
    const matchKey = Object.keys(cachedStudents || {}).find((key) => {
      const entry = cachedStudents[key] || {};
      return String(entry.admissionNumber || entry.admissionNo || key).trim() === normalized;
    });
    if (!matchKey) return null;
    return { id: matchKey, student: cachedStudents[matchKey] };
  }
  window.__finance_lookupStudent = lookupStudentByAdmission;
  let showingDebtorsOnly = false;

  populateClassFilterDropdown();

  function populateClassFilterDropdown() {
    if (!classFilter) return;
    const currentValue = classFilter.value || '';
    classFilter.innerHTML = '';
    CLASS_FILTERS.forEach((label, idx) => {
      const option = document.createElement('option');
      option.value = idx === 0 ? '' : label;
      option.textContent = label;
      classFilter.appendChild(option);
    });
    if (currentValue) {
      const exists = Array.from(classFilter.options).some(opt => opt.value === currentValue);
      classFilter.value = exists ? currentValue : '';
    } else {
      classFilter.value = '';
    }
  }

  function updateYearHint() {
    if (yearHint) yearHint.textContent = `${financeYear}`;
  }

  if (!db) {
    console.error('DB not found.');
    alert('DB not ready. Ensure firebase.js initializes window.db.');
  }

  // ===== Helpers (kept as-is) =====
  function fmt(n) { n = Number(n) || 0; return n.toLocaleString(); }
  function parseMoney(value) {
    if (value == null) return 0;
    if (typeof value === 'number') return Number.isFinite(value) ? value : 0;
    if (typeof value === 'string') {
      const cleaned = value.replace(/[^\d.-]/g, '');
      const parsed = Number(cleaned);
      return Number.isFinite(parsed) ? parsed : 0;
    }
    return 0;
  }
  function clamp(n) { return Math.max(0, Math.round(parseMoney(n))); }
  function todayYMD() {
    const now = new Date();
    const selectedYear = Number(financeYear);
    return {
      y: Number.isFinite(selectedYear) ? selectedYear : now.getFullYear(),
      m: now.getMonth() + 1,
      d: now.getDate(),
    };
  }
  function dateFromYMD(y, m, d, endOfDay = false) {
    if (endOfDay) return new Date(y, m - 1, d, 23, 59, 59, 999).getTime();
    return new Date(y, m - 1, d, 0, 0, 0, 0).getTime();
  }
  function parseScheduleTS(raw, endOfDay = false, academicYear = Number(financeYear)) {
    if (raw == null) return 0;

    const toBoundary = (y, m, d) => endOfDay
      ? new Date(y, m - 1, d, 23, 59, 59, 999).getTime()
      : new Date(y, m - 1, d, 0, 0, 0, 0).getTime();

    if (typeof raw === 'number' && Number.isFinite(raw)) {
      return raw;
    }

    if (Array.isArray(raw) && raw.length >= 2) {
      const m = Number(raw[0]);
      const d = Number(raw[1]);
      if (Number.isFinite(m) && Number.isFinite(d) && m >= 1 && m <= 12 && d >= 1 && d <= 31 && Number.isFinite(academicYear)) {
        const y = m === 12 ? academicYear - 1 : academicYear;
        return toBoundary(y, m, d);
      }
      return 0;
    }

    const value = String(raw).trim();
    if (!value) return 0;

    // Explicit Y-M-D / Y/M/D
    const ymdMatch = value.match(/^(\d{4})[/-](\d{1,2})[/-](\d{1,2})$/);
    if (ymdMatch) {
      const y = Number(ymdMatch[1]);
      const m = Number(ymdMatch[2]);
      const d = Number(ymdMatch[3]);
      if (Number.isFinite(y) && Number.isFinite(m) && Number.isFinite(d)) {
        return toBoundary(y, m, d);
      }
    }

    // M-D or M-D-Y format; when year missing, bind to academic year
    const mdyMatch = value.match(/^(\d{1,2})[/-](\d{1,2})(?:[/-](\d{4}))?$/);
    if (mdyMatch) {
      const m = Number(mdyMatch[1]);
      const d = Number(mdyMatch[2]);
      let y = Number(mdyMatch[3]);
      if (!Number.isFinite(y) && Number.isFinite(academicYear)) {
        y = (m === 12) ? academicYear - 1 : academicYear;
      }
      if (Number.isFinite(y) && Number.isFinite(m) && Number.isFinite(d)) {
        return toBoundary(y, m, d);
      }
    }

    const ts = Date.parse(value);
    if (!Number.isFinite(ts)) return 0;
    const d = new Date(ts);
    return toBoundary(d.getFullYear(), d.getMonth() + 1, d.getDate());
  }
  function isPast(ts) { return Date.now() > ts; }
  function normalizeDeadlineExtensionRows(source) {
    if (!source || typeof source !== 'object') return [];
    return Object.entries(source).map(([id, raw]) => {
      const row = raw && typeof raw === 'object' ? raw : {};
      const oldDeadlineTs = Number(row.oldDeadlineTs || row.sourceOverdueTs || 0);
      const newDeadlineTs = Number(row.newDeadlineTs || row.extendedDeadlineTs || 0);
      const approvedAt = Number(row.approvedAt || row.createdAt || row.updatedAt || 0);
      const status = String(row.status || 'approved').trim().toLowerCase();
      return {
        id,
        ...row,
        oldDeadlineTs,
        newDeadlineTs,
        approvedAt,
        status,
      };
    }).filter((row) => row.newDeadlineTs > 0);
  }

  function getStudentDeadlineExtensions(student) {
    if (!student || typeof student !== 'object') return [];
    if (Array.isArray(student._deadlineExtensions)) return student._deadlineExtensions;
    return [];
  }

  function getNextInstallmentStartTs(scheduleItems, overdueThroughTs) {
    if (!Array.isArray(scheduleItems) || !scheduleItems.length || !(overdueThroughTs > 0)) return 0;
    const matchIndex = scheduleItems.findIndex((item) => Number(item?.toTS || 0) === Number(overdueThroughTs));
    if (matchIndex < 0) {
      const later = scheduleItems
        .map((item) => Number(item?.fromTS || 0))
        .filter((ts) => ts > Number(overdueThroughTs))
        .sort((a, b) => a - b);
      return later[0] || 0;
    }
    for (let idx = matchIndex + 1; idx < scheduleItems.length; idx++) {
      const fromTs = Number(scheduleItems[idx]?.fromTS || 0);
      if (fromTs > 0) return fromTs;
    }
    return 0;
  }

  function pickLatestDeadlineExtension(student, overdueThroughTs) {
    const list = getStudentDeadlineExtensions(student);
    if (!list.length || !(overdueThroughTs > 0)) return null;
    const matches = list
      .filter((row) => row.status === 'approved')
      .filter((row) => {
        if (Number(row.oldDeadlineTs || 0) > 0) {
          return Number(row.oldDeadlineTs) === Number(overdueThroughTs);
        }
        return true;
      })
      .sort((a, b) => Number(b.approvedAt || b.createdAt || 0) - Number(a.approvedAt || a.createdAt || 0));
    return matches[0] || null;
  }

  function decorateStudentsWithDeadlineExtensions(students, extensionBuckets) {
    if (!students || typeof students !== 'object') return students || {};
    const buckets = extensionBuckets && typeof extensionBuckets === 'object' ? extensionBuckets : {};
    const byAdmission = {};
    Object.entries(students).forEach(([sid, student]) => {
      const adm = String(student?.admissionNumber || student?.admissionNo || '').trim();
      if (adm) byAdmission[adm] = sid;
    });
    Object.entries(students).forEach(([sid, student]) => {
      const adm = String(student?.admissionNumber || student?.admissionNo || '').trim();
      const fromId = normalizeDeadlineExtensionRows(buckets[sid] || {});
      const fromAdm = adm ? normalizeDeadlineExtensionRows(buckets[adm] || {}) : [];
      student._deadlineExtensions = [...fromId, ...fromAdm]
        .sort((a, b) => Number(a.createdAt || a.approvedAt || 0) - Number(b.createdAt || b.approvedAt || 0));
    });
    Object.keys(buckets).forEach((bucketKey) => {
      if (students[bucketKey]) return;
      const mapped = byAdmission[String(bucketKey).trim()];
      if (!mapped) return;
      const target = students[mapped];
      if (!target) return;
      const merged = [
        ...(Array.isArray(target._deadlineExtensions) ? target._deadlineExtensions : []),
        ...normalizeDeadlineExtensionRows(buckets[bucketKey] || {}),
      ];
      target._deadlineExtensions = merged
        .sort((a, b) => Number(a.createdAt || a.approvedAt || 0) - Number(b.createdAt || b.approvedAt || 0));
    });
    return students;
  }

  function armDeadlineExtensionWatcher(year) {
    if (!db) return;
    const targetYear = String(year || financeYear || activeYear || SOMAP_DEFAULT_YEAR);
    if (financeDeadlineWatcher && financeDeadlineWatcherYear === targetYear) return;
    if (financeDeadlineWatcher && financeDeadlineWatcherYear) {
      try {
        schoolRef(`financeDeadlineExtensions/${financeDeadlineWatcherYear}`).off('value', financeDeadlineWatcher);
      } catch (_) {}
    }
    financeDeadlineWatcherYear = targetYear;
    financeDeadlineWatcher = (snapshot) => {
      try {
        if (String(activeYear) === targetYear || String(financeYear) === targetYear) {
          decorateStudentsWithDeadlineExtensions(cachedStudents, snapshot?.val?.() || {});
        }
        financeYearDataCache.delete(targetYear);
      } catch (_) {}
      renderTable();
    };
    try {
      schoolRef(`financeDeadlineExtensions/${targetYear}`).on('value', financeDeadlineWatcher);
    } catch (err) {
      console.warn('Finance: failed to watch deadline extensions', err?.message || err);
    }
  }
  function apportion(total, weights) {
    if (!weights.length) return [];
    const sumW = weights.reduce((a, b) => a + b, 0);
    let amounts = weights.map(w => Math.floor((w * total) / sumW));
    let sumA = amounts.reduce((a, b) => a + b, 0);
    let rem = total - sumA;
    if (rem > 0) {
      const sortedIdx = [...weights.keys()].sort((a, b) => weights[b] - weights[a]);
      for (let i = 0; i < rem; i++) amounts[sortedIdx[i % sortedIdx.length]]++;
    }
    return amounts;
  }

  // ===== Installment config (DISCOUNTS REMOVED) =====
  const installmentConfigs = {
    lower: {
      type: '6',
      weights: [44, 13, 12, 22, 22, 16],
      labels: ['Inst 1', 'Inst 2', 'Inst 3', 'Inst 4', 'Inst 5', 'Inst 6'],
      windows: [
        { from: [12, 1], to: [1, 10] },
        { from: [3, 1], to: [3, 15] },
        { from: [4, 1], to: [4, 15] },
        { from: [5, 1], to: [5, 15] },
        { from: [7, 1], to: [7, 15] },
        { from: [9, 1], to: [9, 15] },
      ]
    },
    class4_7: {
      type: '4',
      weights: [27, 20, 20, 15],
      labels: ['Inst 1', 'Inst 2', 'Inst 3', 'Inst 4'],
      windows: [
        { from: [12, 1], to: [1, 10] },
        { from: [3, 1], to: [3, 15] },
        { from: [4, 1], to: [4, 15] },
        { from: [5, 1], to: [5, 15] },
      ]
    },
    class5: {
      type: '6',
      weights: [44, 23, 22, 32, 26, 17],
      labels: ['Inst 1', 'Inst 2', 'Inst 3', 'Inst 4', 'Inst 5', 'Inst 6'],
      windows: [
        { from: [12, 1], to: [1, 10] },
        { from: [3, 1], to: [3, 15] },
        { from: [4, 1], to: [4, 15] },
        { from: [5, 1], to: [5, 15] },
        { from: [7, 1], to: [7, 15] },
        { from: [9, 1], to: [9, 15] },
      ]
    },
    class6: {
      type: '6',
      weights: [236, 115, 110, 160, 160, 100],
      labels: ['Inst 1', 'Inst 2', 'Inst 3', 'Inst 4', 'Inst 5', 'Inst 6'],
      windows: [
        { from: [12, 1], to: [1, 10] },
        { from: [3, 1], to: [3, 15] },
        { from: [4, 1], to: [4, 15] },
        { from: [5, 1], to: [5, 15] },
        { from: [7, 1], to: [7, 15] },
        { from: [9, 1], to: [9, 15] },
      ]
    },
    monthly: {
      type: 'monthly',
      weights: [2, 1, 1, 1, 1, 1, 2, 1, 1, 1],
      labels: ['Jan (2 months)', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul (2 months)', 'Aug', 'Sep', 'Oct'],
      // Use 1st–10th windows to match payment.html and typical "due by 10th" plans.
      // Previously used end-of-month (1/31, 2/28) which caused wrong debt (e.g. 30,400 vs 58,000).
      windows: [
        { from: [1, 1], to: [1, 10] },
        { from: [2, 1], to: [2, 10] },
        { from: [3, 1], to: [3, 10] },
        { from: [4, 1], to: [4, 10] },
        { from: [5, 1], to: [5, 10] },
        { from: [6, 1], to: [6, 10] },
        { from: [7, 1], to: [7, 10] },
        { from: [8, 1], to: [8, 10] },
        { from: [9, 1], to: [9, 10] },
        { from: [10, 1], to: [10, 10] },
      ]
    },
    '2inst': {
      type: '2',
      // discount removed
      weights: [1, 1],
      labels: ['1st Half', '2nd Half'],
      windows: [
        { from: [1, 1], to: [1, 10] },
        { from: [7, 1], to: [7, 5] },
      ]
    },
    full: {
      type: 'full',
      // discount removed
      weights: [1],
      labels: ['Full Year'],
      windows: [
        { from: [1, 1], to: [1, 10] },
      ]
    }
  };

  function getConfig(student) {
    const plan = (student.paymentPlan || '').toLowerCase();
    const c = (student.classLevel || '').toLowerCase();
    const isFourInst = plan.includes('(4)') || /\b4\s*inst/.test(plan) || /mku\.?\s*4/.test(plan);
    const isSixInst = plan.includes('(6)') || /\b6\s*inst/.test(plan) || /dirisha la malipo\s*\(6\)/.test(plan);
    if (plan.includes('monthly') || plan.includes('mwezi')) return installmentConfigs.monthly;
    if (plan.includes('2')) return installmentConfigs['2inst'];
    if (plan.includes('full')) return installmentConfigs.full;
    if (isFourInst || (plan.includes('inst') && (c === 'class 4' || c === 'class 7'))) return installmentConfigs.class4_7;
    if (isSixInst || plan.includes('inst')) {
      if (c === 'class 1' || c === 'class 2' || c === 'class 3') return installmentConfigs.lower;
      if (c === 'class 5') return installmentConfigs.class5;
      if (c === 'class 6') return installmentConfigs.class6;
    }
    if (c === 'class 1' || c === 'class 2' || c === 'class 3') return installmentConfigs.lower;
    if (c === 'class 4' || c === 'class 7') return installmentConfigs.class4_7;
    if (c === 'class 5') return installmentConfigs.class5;
    if (c === 'class 6') return installmentConfigs.class6;
    return installmentConfigs.lower;
  }

  function buildSchedule(student) {
    if (!student || student.isGraduated) {
      return { items: [], periodLabelNow: '-', expectedToDate: 0 };
    }
    const { y } = todayYMD();
    const academicYear = Number.isFinite(y) ? y : Number(financeYear);

    // 1) Student-level custom schedule wins
    if (Array.isArray(student._customSchedule) && student._customSchedule.length) {
      const sc = student._customSchedule
        .filter(it => it && it.label && it.from && it.to)
        .map((it, idx) => ({
          key: `custom${idx+1}`,
          label: String(it.label || 'Item'),
          fromTS: parseScheduleTS(it.from, false, academicYear),
          toTS: parseScheduleTS(it.to, true, academicYear),
          amount: Math.max(0, Math.round(Number(it.amount) || 0)),
          carryComponent: Math.max(0, Number(it.carryComponent || 0)),
          paidAllocated: 0,
          status: 'Pending'
        }));
      let lastDueIndex = -1, periodLabel = '-', expectedToDate = 0;
      const now = Date.now();
      sc.forEach((it, idx) => { if (it.toTS < now) { lastDueIndex = idx; expectedToDate += it.amount; } });
      if (lastDueIndex >= 0) periodLabel = sc[lastDueIndex].label;
      return { items: sc, periodLabelNow: periodLabel, expectedToDate };
    }

    const classDefaultPlanId = String(student?._classDefaults?.defaultPlanId || student?._classDefaults?.defaultPlan || '').trim();
    const overridePlanId = String(student?.override?.planId || '').trim();
    const hasExplicitPlanOverride = Boolean(overridePlanId) && (!classDefaultPlanId || overridePlanId !== classDefaultPlanId);
    const hasPlanSchedule = Array.isArray(student._planSchedule) && student._planSchedule.length > 0;
    const planName = String(student.paymentPlan || '').toLowerCase();
    const isDifferentPlanType = planName.includes('monthly') || planName.includes('mwezi') || planName.includes('full year');

    // 2) Class default edited installments (paymentedits) if present.
    // Use class installments for ALL students in the class unless: custom schedule, or plan override to Monthly/Full Year.
    // "4 INSTALLMENT" vs "Dirisha la Malipo (4)" are same-type plans; class installments are the source of truth.
    if (student._classInstallments && typeof student._classInstallments === 'object' &&
        (!hasExplicitPlanOverride || !isDifferentPlanType)) {
      const rawRows = Array.isArray(student._classInstallments)
        ? student._classInstallments
        : Object.values(student._classInstallments || {});
      const rows = rawRows.filter((row) => row && row.active !== false);
      if (rows.length) {
        const sorted = rows.slice().sort((a, b) => {
          const aw = a?.window?.from || [];
          const bw = b?.window?.from || [];
          const am = Number(aw[0] || 0), bm = Number(bw[0] || 0);
          const ad = Number(aw[1] || 0), bd = Number(bw[1] || 0);
          if (am !== bm) return am - bm;
          return ad - bd;
        });

        const planName = String(student.paymentPlan || '').toLowerCase();
        const isMonthlyPlan = planName.includes('monthly') || planName.includes('mwezi') ||
          sorted.some(r => String(r?.label || '').includes('Monthly:'));
        const sc = sorted.map((row, idx) => {
          const fromPair = Array.isArray(row?.window?.from) ? row.window.from : null;
          const toPair = Array.isArray(row?.window?.to) ? row.window.to : null;
          const fallback = getConfig(student).windows?.[idx] || { from: [1, 1], to: [1, 10] };
          const fromTS = parseScheduleTS(fromPair || fallback.from, false, academicYear);
          let toTS = parseScheduleTS(toPair || fallback.to, true, academicYear);
          if (isMonthlyPlan && toTS > 0 && new Date(toTS).getDate() !== 10) {
            const d = new Date(toTS);
            toTS = dateFromYMD(d.getFullYear(), d.getMonth() + 1, 10, true);
          }
          return {
            key: row.id || `classinst${idx + 1}`,
            label: row.label || `Inst ${idx + 1}`,
            fromTS,
            toTS,
            amount: Math.max(0, Math.round(Number(row.amount) || 0)),
            carryComponent: 0,
            paidAllocated: 0,
            status: 'Pending'
          };
        });

        const carryAmount = Math.max(0, Number(student.carryAmount || 0));
        if (carryAmount > 0 && sc.length) {
          sc[0].amount += carryAmount;
          sc[0].carryComponent = Math.max(0, Number(sc[0].carryComponent || 0)) + carryAmount;
        }

        // If class installments were saved as explicit amounts for the class default fee,
        // but this student has a fee override, scale installments to the student's base fee.
        // This prevents impossible debts (e.g. debt 228,000 while yearly fee is 84,000).
        const studentBaseFee = Math.max(0, Math.round(Number(student.baseFee ?? (student.feePerYear - carryAmount)) || 0));
        const plannedTotal = sc.reduce((sum, row) => sum + Math.max(0, Number(row.amount || 0)), 0);
        const plannedBase = Math.max(0, plannedTotal - carryAmount);
        if (studentBaseFee > 0 && plannedBase > 0) {
          const tolerance = Math.max(100, Math.round(studentBaseFee * 0.01));
          if (Math.abs(plannedBase - studentBaseFee) > tolerance) {
            const ratio = studentBaseFee / plannedBase;
            sc.forEach((row) => {
              const carryPart = Math.max(0, Number(row.carryComponent || 0));
              const basePart = Math.max(0, Number(row.amount || 0) - carryPart);
              row.amount = Math.max(0, Math.floor(basePart * ratio) + carryPart);
            });
            // Fix rounding remainder on last row
            const afterTotal = sc.reduce((sum, row) => sum + Math.max(0, Number(row.amount || 0)), 0);
            const targetTotal = studentBaseFee + carryAmount;
            const diff = targetTotal - afterTotal;
            if (sc.length) sc[sc.length - 1].amount = Math.max(0, Number(sc[sc.length - 1].amount || 0) + diff);
          }
        }

        let lastDueIndex = -1, periodLabel = '-', expectedToDate = 0;
        const now = Date.now();
        sc.forEach((it, idx) => { if (it.toTS < now) { lastDueIndex = idx; expectedToDate += it.amount; } });
        if (lastDueIndex >= 0) periodLabel = sc[lastDueIndex].label;
        return { items: sc, periodLabelNow: periodLabel, expectedToDate };
      }
    }

    // 3) Year plan schedule (from installmentPlans/{y})
    if (hasPlanSchedule) {
      const baseFee = Math.max(0, Math.round(Number(student.baseFee ?? (student.feePerYear - (student.carryAmount || 0))) || 0));
      const carryAmount = Math.max(0, Number(student.carryAmount || 0));

      // IMPORTANT:
      // - Newer plans (especially Monthly plans from paymentedits.html) store explicit `amount` per row.
      // - Older plans store only `weight` and we must apportion by weight.
      // Finance.html MUST mirror payment.html logic, otherwise you get wrong "debt till now"
      // (e.g. 30,400 instead of 58,000) and can send kids home wrongly.
      const rawExplicit = student._planSchedule.map(s => Math.max(0, Number(s?.amount) || 0));
      const explicitSum = rawExplicit.reduce((a, b) => a + b, 0);
      const hasExplicitAmounts = rawExplicit.some(a => a > 0) && explicitSum > 0;

      let amounts = [];
      if (hasExplicitAmounts) {
        // Use plan's explicit amounts, but scale to baseFee if it was built for a different class fee.
        amounts = rawExplicit.slice();
        if (baseFee > 0) {
          const tolerance = Math.max(100, Math.round(baseFee * 0.01));
          if (Math.abs(explicitSum - baseFee) > tolerance) {
            const ratio = baseFee / explicitSum;
            amounts = amounts.map(a => Math.floor(a * ratio));
            let rem = baseFee - amounts.reduce((a, b) => a + b, 0);
            for (let i = 0; i < amounts.length && rem > 0; i++) {
              amounts[i] += 1;
              rem -= 1;
            }
          }
        }
      } else {
        // Weight-based plan: apportion the student's baseFee using the row weights (fallback).
        let weights = student._planSchedule.map(s => Math.max(0, Number(s?.weight) || 0));
        if (!weights.some(w => w > 0)) weights = weights.map(() => 1);
        amounts = apportion(baseFee, weights);
      }

      // Add carry forward on top of the first period
      if (carryAmount > 0) {
        if (amounts.length) amounts[0] += carryAmount;
        else amounts = [carryAmount];
      }

      const planName = String(student.paymentPlan || '').toLowerCase();
      const isMonthlyPlan = planName.includes('monthly') || planName.includes('monthyl') || planName.includes('mwezi') ||
        student._planSchedule.some(s => String(s.label || '').includes('Monthly:'));

      const sc = student._planSchedule.map((s, i) => {
        let toTS = parseScheduleTS(s.to, true, academicYear);
        if (isMonthlyPlan && toTS > 0) {
          const d = new Date(toTS);
          const day = d.getDate();
          if (day !== 10) {
            toTS = dateFromYMD(d.getFullYear(), d.getMonth() + 1, 10, true);
          }
        }
        return {
          key: (s && (s.id || s.key)) ? (s.id || s.key) : `inst${i + 1}`,
          label: s.label || `Inst ${i + 1}`,
          fromTS: parseScheduleTS(s.from, false, academicYear),
          toTS,
          amount: Math.max(0, Number(amounts[i] || 0)),
          carryComponent: 0,
          paidAllocated: 0,
          status: 'Pending'
        };
      });

      if (carryAmount > 0 && sc.length) {
        sc[0].carryComponent = Math.max(0, Number(sc[0].carryComponent || 0)) + carryAmount;
      }

      let lastDueIndex = -1, periodLabel = '-', expectedToDate = 0;
      const now = Date.now();
      sc.forEach((it, idx) => { if (it.toTS < now) { lastDueIndex = idx; expectedToDate += it.amount; } });
      if (lastDueIndex >= 0) periodLabel = sc[lastDueIndex].label;
      return { items: sc, periodLabelNow: periodLabel, expectedToDate };
    }

    // 4) Fallback to existing static configs by class/plan
    const config = getConfig(student);
    const baseFee = Math.max(0, Math.round(Number(student.baseFee ?? (student.feePerYear - (student.carryAmount || 0))) || 0));
    const carryAmount = Math.max(0, Number(student.carryAmount || 0));
    const amounts = apportion(baseFee, config.weights);
    if (carryAmount > 0) {
      if (amounts.length) amounts[0] += carryAmount;
      else amounts.push(carryAmount);
    }
    const sc = [];
    config.labels.forEach((label, i) => {
      let fromY = y, toY = y;
      const fromM = config.windows[i].from[0], fromD = config.windows[i].from[1];
      const toM = config.windows[i].to[0], toD = config.windows[i].to[1];
      if (fromM === 12) fromY = y - 1;
      if (toM === 12) toY = y - 1;
      const fromTS = dateFromYMD(fromY, fromM, fromD, false);
      const toTS = dateFromYMD(toY, toM, toD, true);
      sc.push({ key: `inst${i + 1}`, label, fromTS, toTS, amount: amounts[i] || 0, carryComponent: 0, paidAllocated:0, status:'Pending' });
    });
    if (carryAmount > 0 && sc.length) {
      sc[0].carryComponent = Math.max(0, Number(sc[0].carryComponent || 0)) + carryAmount;
    }
    let lastDueIndex = -1, periodLabel = '-', expectedToDate = 0;
    const now = Date.now();
    sc.forEach((it, idx) => { if (it.toTS < now) { lastDueIndex = idx; expectedToDate += it.amount; } });
    if (lastDueIndex >= 0) periodLabel = sc[lastDueIndex].label;
    return { items: sc, periodLabelNow: periodLabel, expectedToDate };
  }

  function allocatePayments(student, schedule) {
    const payList = [];
    if (student.payments) {
      Object.values(student.payments).forEach(p => {
        payList.push({ amount: clamp(p.amount), ts: Number(p.timestamp) || 0 });
      });
    }
    payList.sort((a, b) => a.ts - b.ts);
    let pot = payList.reduce((s, p) => s + p.amount, 0);
    const totalPaid = pot;
    let prevDebt = clamp(student.previousDebt || 0);
    let toPrev = Math.min(prevDebt, pot); prevDebt -= toPrev; pot -= toPrev;

    for (const it of schedule.items) {
      const need = Math.max(0, it.amount - it.paidAllocated);
      if (need <= 0) continue;
      if (pot <= 0) break;
      const use = Math.min(need, pot);
      it.paidAllocated += use;
      pot -= use;
    }
    const credit = Math.max(0, pot);
    const now = Date.now();
    for (const it of schedule.items) {
      const a = it.paidAllocated, need = it.amount;
      if (a >= need) it.status = 'Cleared';
      else if (isPast(it.toTS)) it.status = a > 0 ? 'Partially Paid (Overdue)' : 'Overdue';
      else it.status = a > 0 ? 'Partially Paid' : 'Pending';
    }
    const expectedToDate = schedule.items.filter(it => it.toTS < now).reduce((s, it) => s + it.amount, 0);
    const paidConsumed = totalPaid - credit;
    const debtTillNow = Math.max(0, expectedToDate - paidConsumed);
    return { scheduleItems: schedule.items, prevDebtAfter: prevDebt, credit, totalPaid, debtTillNow };
  }

  function computeStudentFinancials(student) {
    const feePerYear = Math.max(0, Number(student.feePerYear) || 0);
    const previousDebt = 0;
    const schedule = buildSchedule(student);
    const alloc = allocatePayments(student, schedule);
    const paidAfterPrev = Math.max(0, alloc.totalPaid - (previousDebt - alloc.prevDebtAfter));
    const yearBalance = Math.max(0, feePerYear - paidAfterPrev);
    const carryAmount = Math.max(0, Number(student.carryAmount || 0));
    const totalPaid = Math.max(0, Number(alloc.totalPaid || 0));
    const carryOutstanding = Math.max(0, carryAmount - totalPaid);
    const hasCarryOutstanding = carryOutstanding > 0;
    const paidAfterCarry = Math.max(0, totalPaid - carryAmount);
    const nowTs = Date.now();
    const overdueRowsForBase = (alloc.scheduleItems || [])
      .filter((it) => Number(it.toTS || 0) > 0 && Number(it.toTS || 0) < nowTs)
      .sort((a, b) => Number(a.toTS || 0) - Number(b.toTS || 0));
    const overdueBaseExpected = overdueRowsForBase.reduce((sum, it) => {
      const totalExpected = Math.max(0, Number(it.amount || 0));
      const carryPart = Math.max(0, Number(it.carryComponent || 0));
      const installmentPart = Math.max(0, totalExpected - carryPart);
      return sum + installmentPart;
    }, 0);
    const overdueBaseOutstanding = Math.max(0, overdueBaseExpected - paidAfterCarry);
    const overdueRows = (alloc.scheduleItems || []).filter((it) => {
      const remaining = Math.max(0, Number(it.amount || 0) - Number(it.paidAllocated || 0));
      return Number(it.toTS || 0) > 0 && isPast(Number(it.toTS)) && remaining > 0;
    });
    const latestOverdue = overdueRows.length
      ? overdueRows.reduce((latest, row) => (Number(row.toTS || 0) > Number(latest.toTS || 0) ? row : latest), overdueRows[0])
      : null;
    const overdueThroughTsRaw = latestOverdue ? Number(latestOverdue.toTS || 0) : 0;
    const isOverdueDebtBase = overdueThroughTsRaw > 0 && alloc.debtTillNow > 0;
    const nextInstallmentStartTs = getNextInstallmentStartTs(alloc.scheduleItems || [], overdueThroughTsRaw);
    const extensionRecord = isOverdueDebtBase ? pickLatestDeadlineExtension(student, overdueThroughTsRaw) : null;
    let overdueThroughTs = overdueThroughTsRaw;
    if (extensionRecord && Number(extensionRecord.newDeadlineTs || 0) > 0) {
      overdueThroughTs = Number(extensionRecord.newDeadlineTs);
      if (nextInstallmentStartTs > 0) {
        overdueThroughTs = Math.min(overdueThroughTs, nextInstallmentStartTs - 1);
      }
    }
    const extensionActive = isOverdueDebtBase && overdueThroughTs > 0 && Date.now() <= overdueThroughTs;
    const isOverdueDebt = isOverdueDebtBase && !extensionActive;
    const prevYearNum = Number.isFinite(Number(financeYear)) ? Number(financeYear) - 1 : new Date().getFullYear() - 1;
    const carryOverdueTs = new Date(prevYearNum, 11, 31, 23, 59, 59, 999).getTime();
    const effectivelyCarryDebt = (hasCarryOutstanding || (carryAmount > 0 && yearBalance > 0 && yearBalance <= carryAmount + 100)) && !isOverdueDebt;
    const periodDebtLabel = (isOverdueDebtBase && overdueThroughTs > 0)
      ? new Date(overdueThroughTs).toLocaleDateString()
      : (effectivelyCarryDebt ? new Date(carryOverdueTs).toLocaleDateString() : '-');
    const overdueWindowLabel = ((isOverdueDebtBase || extensionActive) && latestOverdue)
      ? `${new Date(Number(latestOverdue.fromTS || 0)).toLocaleDateString()} - ${new Date(Number(overdueThroughTs || latestOverdue.toTS || 0)).toLocaleDateString()}`
      : (effectivelyCarryDebt
          ? `Carry from ${prevYearNum} — due by ${new Date(carryOverdueTs).toLocaleDateString()}`
          : '-');
    // Always use alloc.debtTillNow for overdue debt: it correctly sums expected-to-date minus
    // allocated payments per period. overdueBaseOutstanding used a flawed formula that
    // could show wrong amounts (e.g. 30,400 instead of 58,000) and risk wrong send-home decisions.
    // When there are overdue periods with remaining balance, debt = alloc.debtTillNow (never overdueBaseOutstanding).
    const debtTillNowCapped = Math.min(
      Math.max(0, Number(alloc.debtTillNow || 0)),
      Math.max(0, Number(yearBalance || 0))
    );
    const debtForCollection = (isOverdueDebt || overdueRows.length > 0)
      ? debtTillNowCapped
      : Math.max(0, (hasCarryOutstanding ? carryOutstanding : 0) + overdueBaseOutstanding);
    const debtForDisplay = debtForCollection > 0 ? debtForCollection : (effectivelyCarryDebt && yearBalance > 0 ? yearBalance : 0);
    const finalPeriodDebtLabel = (debtForDisplay > 0 && effectivelyCarryDebt) ? new Date(carryOverdueTs).toLocaleDateString() : periodDebtLabel;
    const finalOverdueWindowLabel = (debtForDisplay > 0 && effectivelyCarryDebt) ? `Carry from ${prevYearNum} — due by ${new Date(carryOverdueTs).toLocaleDateString()}` : overdueWindowLabel;
    return {
      feePerYear,
      previousDebt,
      paidAmount: alloc.totalPaid,
      balance: yearBalance,
      periodDebtLabel: finalPeriodDebtLabel,
      periodDebtValue: debtForDisplay,
      isOverdueDebt,
      extensionActive,
      extensionRecord: extensionRecord || null,
      extensionCappedByNextInstallment: Boolean(extensionRecord && nextInstallmentStartTs > 0 && Number(extensionRecord.newDeadlineTs || 0) >= nextInstallmentStartTs),
      nextInstallmentStartTs,
      overdueThroughTs,
      originalOverdueThroughTs: overdueThroughTsRaw,
      overdueWindowLabel: finalOverdueWindowLabel,
      hasCarryOutstanding: hasCarryOutstanding || effectivelyCarryDebt,
      carryOutstanding,
      credit: alloc.credit,
      scheduleItems: alloc.scheduleItems
    };
  }
  window.__finance_computeStudentFinancials = computeStudentFinancials;

  function normalizePayments(source, targetYear) {
    if (!source) return {};
    let bucket = source;
    if (source && typeof source === 'object' && !Array.isArray(source) && source.payments) {
      bucket = source.payments;
    }
    if (!bucket || typeof bucket !== 'object') return {};
    const normalized = {};
    const desiredYear = Number(targetYear);
    Object.entries(bucket).forEach(([key, raw]) => {
      if (raw == null) return;
      if (typeof raw === 'number' || typeof raw === 'string') {
        const amount = parseMoney(raw);
        if (!(amount > 0)) return;
        normalized[key] = {
          amount,
          timestamp: Date.now(),
          academicYear: Number.isFinite(desiredYear) ? desiredYear : undefined,
        };
        return;
      }
      const amount = parseMoney(raw.amount ?? raw.value ?? raw.paid ?? raw.payment ?? raw.total ?? 0);
      if (!(amount > 0)) return;
      const timestamp = Number(
        raw.timestamp ?? raw.datePaid ?? raw.createdAt ?? raw.updatedAt ?? raw.recordedAt ?? raw.time ?? Date.now()
      );
      let paymentYear = Number(
        raw.academicYear ??
        raw.financeYear ??
        raw.feeYear ??
        raw.year ??
        raw._year ??
        raw.academic_session
      );
      if (!Number.isFinite(paymentYear)) {
        const tsDate = new Date(timestamp);
        if (!Number.isNaN(tsDate.getTime())) paymentYear = tsDate.getFullYear();
      }
      if (Number.isFinite(desiredYear) && Number.isFinite(paymentYear) && paymentYear !== desiredYear) return;
      const payload = { ...raw, amount, timestamp };
      if (Number.isFinite(paymentYear)) payload.academicYear = paymentYear;
      else if (Number.isFinite(desiredYear)) payload.academicYear = desiredYear;
      normalized[key] = payload;
    });
    return normalized;
  }

function buildFinanceStudents(
  baseStudents = {},
  anchorEnrollments = {},
  enrollments = {},
  classFees = {},
  overrides = {},
  plans = {},
  ledgers = {},
  carryForward = {},
  studentFees = {},
  approvalsByStudent = {},
  year = activeYear
) {
    const targetYear = String(year || activeYear || SOMAP_DEFAULT_YEAR);
    const targetYearNum = Number(targetYear);
    const BASE_YEAR = Number(SOMAP_DEFAULT_YEAR);

    const isNonEmptyObj = (o) => o && typeof o === 'object' && !Array.isArray(o) && Object.keys(o).length > 0;
    const toMs = (value) => {
      if (value === null || value === undefined) return null;
      if (typeof value === 'number' && Number.isFinite(value)) {
        if (value > 1e12) return value;
        if (value > 1e10) return value;
        if (value > 1e9) return value * 1000;
        return value;
      }
      const s = String(value).trim();
      if (!s) return null;
      if (/^\d{10,13}$/.test(s)) {
        const n = Number(s);
        if (!Number.isFinite(n)) return null;
        return n > 1e12 ? n : n * 1000;
      }
      const parsed = Date.parse(s);
      return Number.isFinite(parsed) ? parsed : null;
    };
    const getRegistrationMs = (stu) => {
      if (!stu || typeof stu !== 'object') return null;
      return (
        toMs(stu.timestamp) ??
        toMs(stu.createdAt) ??
        toMs(stu.registeredAt) ??
        toMs(stu.regTimestamp) ??
        toMs(stu.dateRegistered) ??
        toMs(stu.dateOfRegistration) ??
        null
      );
    };
    const getRegistrationYear = (stu) => {
      const ms = getRegistrationMs(stu);
      if (!ms) return null;
      const d = new Date(ms);
      const y = d.getFullYear();
      return Number.isFinite(y) ? y : null;
    };
    const looksDeleted = (stu) => {
      const status = String(stu?.status || '').trim().toLowerCase();
      return Boolean(
        stu?.deleted === true ||
        stu?.isDeleted === true ||
        stu?.archived === true ||
        stu?.isArchived === true ||
        stu?.removed === true ||
        stu?.isRemoved === true ||
        stu?.active === false ||
        status === 'deleted' ||
        status === 'archived' ||
        status === 'removed' ||
        status === 'shifted'
      );
    };
    const isCompleteStudent = (stu) => {
      if (!stu || typeof stu !== 'object') return false;
      if (looksDeleted(stu)) return false;
      const sid = String(stu.schoolId || '').trim();
      if (sid && sid !== String(currentSchool?.id || '')) return false;
      const admission = String(stu.admissionNumber || '').trim();
      const first = String(stu.firstName || '').trim();
      const last = String(stu.lastName || '').trim();
      if (!admission || norm(admission) === 'n/a' || norm(admission) === 'na') return false;
      if (!first || norm(first) === 'n/a' || norm(first) === 'na') return false;
      if (!last || norm(last) === 'n/a' || norm(last) === 'na') return false;
      return Number.isFinite(getRegistrationYear(stu));
    };
    const belongsToSelectedYear = (stu, selectedYear) => {
      const regYear = getRegistrationYear(stu);
      if (!regYear || !Number.isFinite(selectedYear)) return false;
      return regYear >= BASE_YEAR && regYear <= selectedYear;
    };
    const hasPaymentsForYear = (paymentsObj, yNum) => {
      if (!paymentsObj || typeof paymentsObj !== 'object') return false;
      return Object.values(paymentsObj).some((p) => {
        if (!p) return false;
        const ay = Number(p.academicYear ?? p.financeYear ?? p.year);
        if (Number.isFinite(ay) && ay === yNum) return true;
        const ts = Number(p.timestamp ?? p.datePaid ?? p.createdAt);
        if (Number.isFinite(ts)) {
          const dt = new Date(ts);
          if (!Number.isNaN(dt.getTime()) && dt.getFullYear() === yNum) return true;
        }
        return false;
      });
    };

    const ids = new Set([
      ...Object.keys(anchorEnrollments || {}),
      ...Object.keys(enrollments || {}),
      ...Object.keys(overrides || {}),
      ...Object.keys(ledgers || {}),
      ...Object.keys(carryForward || {}),
      ...Object.keys(studentFees || {}),
      ...Object.keys(baseStudents || {}),
    ]);

    const map = {};
    ids.forEach((id) => {
      const base = baseStudents[id] || {};
      const anchor = anchorEnrollments[id] || {};
      const enrollment = enrollments[id] || {};
      const override = overrides[id] || {};
      const ledgerEntry = ledgers[id] || {};
      const carry = carryForward[id] || {};
      const registrationYear = getRegistrationYear(base);

      if (!isCompleteStudent(base)) return;
      if (!belongsToSelectedYear(base, targetYearNum)) return;

      const hasTargetEnroll = isNonEmptyObj(enrollment);
      const carryAmount = Math.max(0, Number(carry.amount ?? carry.balance ?? 0));

      let studentFeeOverride = studentFees[id];
      if (!studentFeeOverride) {
        const admKey =
          base.admissionNumber || base.admissionNo ||
          anchor.admissionNumber || anchor.admissionNo ||
          enrollment.admissionNumber || enrollment.admissionNo || '';
        if (admKey && studentFees[admKey]) studentFeeOverride = studentFees[admKey];
      }

      const coerceFee = (value) => {
        if (value == null) return null;
        if (typeof value === 'number') return Number.isFinite(value) ? value : null;
        if (typeof value === 'string') {
          const cleaned = value.replace(/[^\d.-]/g, '');
          if (!cleaned) return null;
          const parsed = Number(cleaned);
          return Number.isFinite(parsed) ? parsed : null;
        }
        if (typeof value === 'object') {
          const maybe = value.feePerYear ?? value.baseFee ?? value.amount ?? value.total ?? value.value;
          return coerceFee(maybe);
        }
        return null;
      };
      const explicitStudentFee = coerceFee(studentFeeOverride);

      const baseHasYearPayments = hasPaymentsForYear(base.payments, targetYearNum);

      let baseClass = '';
      if (hasTargetEnroll) {
        baseClass = enrollment.className || enrollment.classLevel || enrollment.class || '';
      } else {
        baseClass = base.classLevel || base.class || anchor.className || anchor.classLevel || anchor.class || '';
      }
      baseClass = canonClass(baseClass);

      let delta = 0;
      if (!hasTargetEnroll) {
        if (Number.isFinite(registrationYear) && Number.isFinite(targetYearNum)) {
          delta = targetYearNum - registrationYear;
        }
      }
      const classLevel = shiftClass(baseClass, delta);
      const classDefaults = classFees[classLevel] || classFees[baseClass] || {};
      const resolvedPlanId = override.planId || classDefaults.defaultPlanId || null;
      const resolvedPlan = resolvedPlanId ? plans[resolvedPlanId] : null;
      const classDefaultPlanId = classDefaults.defaultPlanId || classDefaults.defaultPlan || '';
      const hasPlanOverride = Boolean(override.planId) &&
        (!classDefaultPlanId || String(override.planId) !== String(classDefaultPlanId));

      const isMonthlyPlan = resolvedPlan?.schedule && Array.isArray(resolvedPlan.schedule) &&
        resolvedPlan.schedule.some((row) => String(row.label || '').includes('Monthly:'));

      let paymentPlan =
        (resolvedPlan && resolvedPlan.name) ||
        override.planName ||
        override.paymentPlan ||
        enrollment.planName ||
        enrollment.paymentPlan ||
        classDefaults.defaultPlan ||
        base.paymentPlan ||
        '6-instalments';
      if (isMonthlyPlan) paymentPlan = 'Malipo kwa mwezi';

      const admissionNumber =
        enrollment.admissionNumber ||
        enrollment.admissionNo ||
        base.admissionNumber ||
        id;

      let baseFeeCandidate =
        (explicitStudentFee != null ? explicitStudentFee : undefined) ??
        override.feePerYear ??
        classDefaults.feePerYear ??
        base.feePerYear ??
        base.feeDue ??
        base.requiredFee ??
        0;
      if (isMonthlyPlan && (!baseFeeCandidate || baseFeeCandidate === 0) && resolvedPlan?.schedule) {
        const totalFromSchedule = resolvedPlan.schedule.reduce((sum, row) => sum + (Number(row.amount) || 0), 0);
        if (totalFromSchedule > 0) baseFeeCandidate = totalFromSchedule;
      }

      const baseFee = Math.max(0, Math.round(Number(baseFeeCandidate) || 0));
      const effectiveFee = Math.max(0, baseFee + carryAmount);

      let paymentsSource = {};
      if (ledgerEntry && typeof ledgerEntry === 'object') {
        const yearBucket =
          ledgerEntry[targetYear] ||
          ledgerEntry[String(targetYear)] ||
          ledgerEntry[Number(targetYear)];
        if (yearBucket && typeof yearBucket === 'object') {
          if (yearBucket.payments) paymentsSource = yearBucket.payments;
          else if (yearBucket.entries) paymentsSource = yearBucket.entries;
          else if (yearBucket.records) paymentsSource = yearBucket.records;
          else paymentsSource = yearBucket;
        } else if (ledgerEntry.payments || ledgerEntry.entries || ledgerEntry.records) {
          paymentsSource = ledgerEntry.payments || ledgerEntry.entries || ledgerEntry.records;
        } else {
          paymentsSource = ledgerEntry;
        }
      } else if (ledgerEntry != null) {
        paymentsSource = ledgerEntry;
      }
      if (!Object.keys(paymentsSource || {}).length && base.payments) {
        const approvedFallback = {};
        Object.entries(base.payments).forEach(([key, entry]) => {
          if (!entry) return;
          const approvedMarker = Number(entry.approvedAt || entry.approved || 0);
          if (approvedMarker > 0) approvedFallback[key] = entry;
        });
        if (Object.keys(approvedFallback).length) paymentsSource = approvedFallback;
      }
      if (!Object.keys(paymentsSource || {}).length) {
        const fallbackEntries = approvalsByStudent[id] || [];
        if (fallbackEntries.length) {
          paymentsSource = {};
          fallbackEntries.forEach((entry, idx) => {
            const entryKey = entry.approvalId || `appr-${id}-${idx}`;
            paymentsSource[entryKey] = {
              amount: Number(entry.amount || 0),
              timestamp: Number(entry.timestamp || entry.approvedAt || Date.now()),
              method: entry.method || '',
              note: entry.note || '',
              referenceCode: entry.referenceCode || '',
              academicYear: Number(targetYear),
              approvedAt: Number(entry.approvedAt || entry.timestamp || Date.now()),
            };
          });
        }
      }

      const dedupedPayments = window.SOMAP_FINANCE?.dedupePaymentMap
        ? window.SOMAP_FINANCE.dedupePaymentMap(paymentsSource, targetYear, admissionNumber || id)
        : paymentsSource;
      const payments = normalizePayments(dedupedPayments, targetYear);

      const parentContact =
        enrollment.parentPhone ||
        enrollment.guardianPhone ||
        base.primaryParentContact ||
        base.parentPhone ||
        base.guardianPhone ||
        base.contact ||
        '';

      const record = {
        ...base,
        classLevel,
        classLevelRaw: baseClass || '',
        paymentPlan,
        feePerYear: effectiveFee,
        baseFee,
        carryAmount,
        payments,
        financeYear: targetYear,
        academicYear: targetYear,
        primaryParentContact: parentContact || base.primaryParentContact,
        admissionNumber: admissionNumber || id,
        hasYearData: Boolean(
          isNonEmptyObj(enrollment) ||
          isNonEmptyObj(override) ||
          isNonEmptyObj(classDefaults) ||
          carryAmount > 0 ||
          effectiveFee > 0 ||
          Object.keys(payments || {}).length > 0 ||
          baseHasYearPayments
        ),
        isGraduated: classLevel === 'GRADUATED',
      };

      if (Array.isArray(override.customSchedule) && override.customSchedule.length) {
        record._customSchedule = override.customSchedule;
      } else if (resolvedPlan && Array.isArray(resolvedPlan.schedule)) {
        record._planSchedule = resolvedPlan.schedule;
      }
      if (classDefaults && classDefaults.installments && typeof classDefaults.installments === 'object') {
        record._classInstallments = classDefaults.installments;
      }

      record.previousDebt = 0;
      if (!record.firstName && enrollment.firstName) record.firstName = enrollment.firstName;
      if (!record.lastName && enrollment.lastName) record.lastName = enrollment.lastName;
      if (!record.middleName && enrollment.middleName) record.middleName = enrollment.middleName;
      if (override && Object.keys(override).length) record.override = override;
      record._hasPlanOverride = hasPlanOverride;
      record._classDefaults = classDefaults;
      map[id] = record;
    });

    return map;
  }

  const financeYearDataCache = new Map();
  const financeApprovalsCache = new Map();
  const financeBalanceCache = new Map();

  async function loadApprovedFinanceApprovals(year, force = false) {
    if (!db) return {};
    const targetYear = String(year || financeYear || SOMAP_DEFAULT_YEAR);
    if (!force && financeApprovalsCache.has(targetYear)) return financeApprovalsCache.get(targetYear);
    try {
      const snapshot = await schoolRef('approvalsHistory').once('value');
      const tree = snapshot.val() || {};
      const grouped = {};
      const normalizedTargetYear = Number(targetYear);
      Object.entries(tree).forEach(([_, months]) => {
        Object.entries(months || {}).forEach(([__, records]) => {
          Object.entries(records || {}).forEach(([key, record]) => {
            if (!record) return;
            const recordYear = Number(record.forYear ?? record.academicYear ?? record.year);
            if (!Number.isFinite(recordYear) || recordYear !== normalizedTargetYear) return;
            const finalStatus = String(record.finalStatus || record.status || '').toLowerCase();
            if (!['approved', 'completed'].includes(finalStatus)) return;
            const moduleSource = String(record.sourceModule || record.module || '').toLowerCase();
            if (!moduleSource.includes('finance')) return;
            const studentKey = record.studentId || record.modulePayload?.studentKey || record.studentAdm;
            if (!studentKey) return;
            const amount = Number(record.amountPaidNow ?? record.amount ?? record.paidAmount ?? 0);
            if (!(amount > 0)) return;
            const timestamp = Number(record.approvedAt || record.datePaid || record.createdAt || Date.now());
            if (!grouped[studentKey]) grouped[studentKey] = [];
            grouped[studentKey].push({
              approvalId: key,
              amount,
              timestamp,
              method: record.method || record.paymentMethod || record.modulePayload?.payment?.method || '',
              note: record.note || record.modulePayload?.payment?.note || '',
              referenceCode: record.referenceCode || record.paymentReferenceCode || record.modulePayload?.payment?.referenceCode || '',
              academicYear: normalizedTargetYear,
              approvedAt: timestamp,
            });
          });
        });
      });
      financeApprovalsCache.set(targetYear, grouped);
      return grouped;
    } catch (err) {
      console.warn('Finance: approvals history read failed', err?.message || err);
      financeApprovalsCache.set(targetYear, {});
      return {};
    }
  }

  async function loadFinanceStudentsForYearCached(year) {
    const key = String(year || activeYear || SOMAP_DEFAULT_YEAR);
    if (!db) return {};
    if (key === String(activeYear) || key === String(financeYear)) {
      return cachedStudents || {};
    }
    if (financeYearDataCache.has(key)) {
      return financeYearDataCache.get(key);
    }

    const promise = (async () => {
      try {
        const [
          baseSnap,
          anchorEnrollSnap,
          enrollmentSnap,
          classFeesSnap,
          stOverridesSnap,
          studentFeesSnap,
          plansSnap,
          ledgerSnap,
          carrySnap,
          deadlineExtensionsSnap,
          studentPlansSnap,
          financePlansSnap,
        ] = await Promise.all([
        schoolRef('students').once('value'),
        schoolRef(`enrollments/${SOMAP_DEFAULT_YEAR}`).once('value'),
        schoolRef(`enrollments/${key}`).once('value'),
        schoolRef(`feesStructure/${key}`).once('value'),
        schoolRef(`studentOverrides/${key}`).once('value'),
        schoolRef(`studentFees/${key}`).once('value'),
        schoolRef(`installmentPlans/${key}`).once('value'),
        schoolRef(`financeLedgers/${key}`).once('value'),
        schoolRef(`financeCarryForward/${key}`).once('value'),
        schoolRef(`financeDeadlineExtensions/${key}`).once('value'),
        schoolRef(`finance/${key}/studentPlans`).once('value'),
        schoolRef(`finance/${key}/plans`).once('value'),
        ]);

        let baseStudents = baseSnap.val() || {};
        let anchorEnrollments = anchorEnrollSnap.val() || {};
        let yearEnrollments = enrollmentSnap.val() || {};
        if (isSocratesSchool) {
          try {
            const [legacyBaseSnap, legacyAnchorEnrollSnap, legacyYearEnrollSnap] = await Promise.all([
              db.ref('students').once('value'),
              db.ref(`enrollments/${SOMAP_DEFAULT_YEAR}`).once('value'),
              db.ref(`enrollments/${key}`).once('value'),
            ]);
            baseStudents = { ...(legacyBaseSnap.val() || {}), ...(baseStudents || {}) };
            anchorEnrollments = { ...(legacyAnchorEnrollSnap.val() || {}), ...(anchorEnrollments || {}) };
            yearEnrollments = { ...(legacyYearEnrollSnap.val() || {}), ...(yearEnrollments || {}) };
          } catch (legacyReadErr) {
            console.warn('Legacy students/enrollments read failed (helper)', legacyReadErr?.message || legacyReadErr);
          }
        }
        let ledgerData = ledgerSnap.val() || {};
        try {
          const legacyLedgerSnap = await schoolRef('financeLedgers').once('value');
          const legacyLedgerData = legacyLedgerSnap.val() || {};
          if (isSocratesSchool) {
            ledgerData = { ...(legacyLedgerData || {}), ...(ledgerData || {}) };
          } else if (!Object.keys(ledgerData || {}).length) {
            ledgerData = legacyLedgerData;
          }
        } catch (legacyErr) {
          console.warn('Legacy financeLedgers read failed (helper)', legacyErr?.message || legacyErr);
        }

        let studentFeesData = studentFeesSnap.val() || {};
        try {
          const legacyStudentFeesSnap = await schoolRef(`finance/${key}/studentFees`).once('value');
          const legacyStudentFeesData = legacyStudentFeesSnap.val() || {};
          if (isSocratesSchool) {
            studentFeesData = { ...(legacyStudentFeesData || {}), ...(studentFeesData || {}) };
          } else if (!Object.keys(studentFeesData || {}).length) {
            studentFeesData = legacyStudentFeesData;
          }
        } catch (studentFeesErr) {
          console.warn('Student fee override read failed (helper)', studentFeesErr?.message || studentFeesErr);
        }

        // Merge studentPlans (finance/{year}/studentPlans) into overrides so plan overrides
        // from paymentedits.html "Save + Apply" are reflected in finance.html and payment.html
        const stOverridesRaw = stOverridesSnap.val() || {};
        const studentPlansRaw = studentPlansSnap.val() || {};
        const mergedOverrides = { ...stOverridesRaw };
        Object.keys(studentPlansRaw || {}).forEach((sid) => {
          const sp = studentPlansRaw[sid];
          if (sp && (sp.planId || sp.id)) {
            mergedOverrides[sid] = { ...(mergedOverrides[sid] || {}), planId: sp.planId || sp.id };
          }
        });

        // Merge finance/{year}/plans with installmentPlans so new plans from monthly modal appear
        const legacyPlans = plansSnap.val() || {};
        const financePlansRaw = financePlansSnap.val() || {};
        const mergedPlans = { ...legacyPlans, ...(financePlansRaw || {}) };

        const approvalsByStudent = await loadApprovedFinanceApprovals(key);
        const built = buildFinanceStudents(
          baseStudents,
          anchorEnrollments,
          yearEnrollments,
          classFeesSnap.val() || {},
          mergedOverrides,
          mergedPlans,
          ledgerData,
          carrySnap.val() || {},
          studentFeesData,
          approvalsByStudent,
          key
        );
        return decorateStudentsWithDeadlineExtensions(built || {}, deadlineExtensionsSnap.val() || {});
      } catch (err) {
        console.warn('Carry-forward helper failed to load year dataset', key, err);
        return {};
      }
    })();

    financeYearDataCache.set(key, promise);
    return promise;
  }

  window.__finance_getBalanceForYearAdmission = async function (year, admissionNo) {
    const normalizedYear = String(year || '');
    const normalizedAdm = String(admissionNo || '').trim();
    if (!normalizedAdm) return 0;
    const cacheKey = `${normalizedYear}::${normalizedAdm}`;
    if (financeBalanceCache.has(cacheKey)) {
      return financeBalanceCache.get(cacheKey);
    }
    try {
      const dataset = await loadFinanceStudentsForYearCached(normalizedYear);
      if (!dataset || !Object.keys(dataset).length) {
        financeBalanceCache.set(cacheKey, 0);
        return 0;
      }
      let student = dataset[normalizedAdm];
      if (!student) {
        const matchKey = Object.keys(dataset).find((key) => {
          const entry = dataset[key] || {};
          return String(entry.admissionNumber || entry.admissionNo || key).trim() === normalizedAdm;
        });
        if (matchKey) student = dataset[matchKey];
      }
      if (!student) {
        financeBalanceCache.set(cacheKey, 0);
        return 0;
      }
      const previousFinanceYear = financeYear;
      const previousActiveYear = activeYear;
      try {
        financeYear = normalizedYear;
        activeYear = normalizedYear;
        const fin = computeStudentFinancials(student);
        const balanceValue = Math.max(0, Number(fin?.balance) || 0);
        financeBalanceCache.set(cacheKey, balanceValue);
        return balanceValue;
      } finally {
        financeYear = previousFinanceYear;
        activeYear = previousActiveYear;
      }
    } catch (err) {
      console.warn('Carry-forward helper balance lookup failed', year, admissionNo, err);
      financeBalanceCache.set(cacheKey, 0);
      return 0;
    }
  };

  // Expose a summary getter so child iframes (payment.html) can stay in sync with the finance table.
  window.__finance_getStudentFinanceSummary = async function (year, studentIdOrAdm) {
    const targetYear = String(year || financeYear || activeYear || SOMAP_DEFAULT_YEAR);
    const identifier = String(studentIdOrAdm || '').trim();
    if (!identifier) return null;
    try {
      const dataset = await loadFinanceStudentsForYearCached(targetYear);
      let student = dataset[identifier];
      let resolvedStudentId = student ? identifier : '';
      if (!student) {
        const matchKey = Object.keys(dataset).find((key) => {
          const entry = dataset[key] || {};
          return String(entry.admissionNumber || entry.admissionNo || key).trim() === identifier;
        });
        if (matchKey) {
          student = dataset[matchKey];
          resolvedStudentId = matchKey;
        }
      }
      if (!student) return null;
      if (!resolvedStudentId) {
        resolvedStudentId = Object.keys(dataset).find((key) => dataset[key] === student) || '';
      }

      const prevFinanceYear = financeYear;
      const prevActiveYear = activeYear;
      try {
        financeYear = targetYear;
        activeYear = targetYear;
        const fin = computeStudentFinancials(student);
        const baseFee = Math.max(0, Number(student.baseFee || student.feePerYear || 0));
        const carry = Math.max(0, Number(student.carryAmount || 0));
        const totalDue = Math.max(0, baseFee + carry);
        const parentContact = String(
          student.primaryParentContact ||
          student.parentPhone ||
          student.guardianPhone ||
          student.contact ||
          ''
        ).trim();
        return {
          studentId: resolvedStudentId || student.id || student.studentId || identifier,
          admissionNumber: String(student.admissionNumber || student.admissionNo || ''),
          fullName: `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.replace(/\s+/g, ' ').trim(),
          classLevel: student.classLevel || student.className || '',
          parentContact,
          due: totalDue,
          baseFee,
          carry,
          paid: Math.max(0, Number(fin.paidAmount || 0)),
          balance: Math.max(0, Number(fin.balance || 0)),
          credit: Math.max(0, Number(fin.credit || 0)),
          periodDebtLabel: fin.periodDebtLabel || '-',
          periodDebtValue: Math.max(0, Number(fin.periodDebtValue || 0)),
          isOverdueDebt: Boolean(fin.isOverdueDebt),
          overdueThroughTs: Number(fin.overdueThroughTs || 0),
          originalOverdueThroughTs: Number(fin.originalOverdueThroughTs || fin.overdueThroughTs || 0),
          extensionActive: Boolean(fin.extensionActive),
          nextInstallmentStartTs: Number(fin.nextInstallmentStartTs || 0),
          scheduleItems: Array.isArray(fin.scheduleItems) ? fin.scheduleItems : [],
        };
      } finally {
        financeYear = prevFinanceYear;
        activeYear = prevActiveYear;
      }
    } catch (err) {
      console.warn('Finance: summary export failed', err?.message || err);
      return null;
    }
  };

  // Expose finance-scoped student list for other hubs (e.g. extension hub).
  // This keeps year/class visibility consistent with finance.html rules.
  window.__finance_getStudentsForYear = async function (year) {
    const targetYear = String(year || financeYear || activeYear || SOMAP_DEFAULT_YEAR);
    try {
      let dataset = await loadFinanceStudentsForYearCached(targetYear);
      // If finance bridge is queried before initial table load completes,
      // force a direct year load once so external hubs do not get empty results.
      if (!dataset || !Object.keys(dataset).length) {
        try {
          await loadStudents(targetYear);
        } catch (_) {}
        dataset = await loadFinanceStudentsForYearCached(targetYear);
      }
      const rows = Object.entries(dataset || {}).map(([id, student]) => {
        const fullName = `${student?.firstName || ''} ${student?.middleName || ''} ${student?.lastName || ''}`
          .replace(/\s+/g, ' ')
          .trim();
        const admissionNumber = String(student?.admissionNumber || student?.admissionNo || id || '').trim();
        const classLevel = String(student?.classLevel || student?.className || '').trim();
        const parentContact = String(
          student?.primaryParentContact ||
          student?.parentPhone ||
          student?.guardianPhone ||
          student?.contact ||
          ''
        ).trim();
        const hasPayments = Object.keys(student?.payments || {}).length > 0;
        const hasFinanceData = Boolean(student?.hasYearData) || Number(student?.feePerYear || 0) > 0 || hasPayments;
        return {
          id,
          admissionNumber,
          fullName,
          classLevel,
          parentContact,
          isGraduated: Boolean(student?.isGraduated || String(classLevel).toUpperCase() === 'GRADUATED'),
          hasFinanceData,
        };
      });
      return rows
        .filter((row) => !row.isGraduated)
        .sort((a, b) => String(a.fullName || a.admissionNumber).localeCompare(String(b.fullName || b.admissionNumber)));
    } catch (err) {
      console.warn('Finance: failed to export student list', err?.message || err);
      return [];
    }
  };

  // ====== SPEED FIX: placeholder breakdown row (no iframe yet) ======
  function breakdownRowHTML(id) {
    return `
      <tr id="br-${id}" class="hidden bg-slate-50">
        <td class="p-2 border-t" colspan="10">
          <div class="breakdown-slot" data-id="${id}">
            <div class="p-3 text-xs text-slate-500 skel rounded">Loading area…</div>
          </div>
        </td>
      </tr>
    `;
  }

  // ===== Render table (unchanged except: uses placeholder breakdown row) =====
  function renderTable() {
    tbody.innerHTML = '';
    let totalDue = 0, totalCollected = 0;
    let shown = 0;
    const filterClass = classFilter.value;
    const isParentScope = parentCtx.enabled;

    Object.entries(cachedStudents).forEach(([id, student]) => {
      if (filterClass && student.classLevel !== filterClass) return;
      if (!isParentScope && student.isGraduated) return;

      let fin = computeStudentFinancials(student);
      if (student.isGraduated) {
        const effectiveFee = 0;
        fin = {
          feePerYear: isParentScope ? 0 : effectiveFee,
          previousDebt: 0,
          paidAmount: 0,
          balance: isParentScope ? 0 : effectiveFee,
          periodDebtLabel: '-',
          periodDebtValue: 0,
          credit: 0,
          scheduleItems: []
        };
      }

      if (showingDebtorsOnly && (fin.balance <= 0 && fin.periodDebtValue <= 0)) return;

      totalDue += fin.feePerYear;
      totalCollected += fin.paidAmount;

      const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
      const debtIsOverdue = Boolean(fin.isOverdueDebt && fin.periodDebtValue > 0);
      const debtIsCarry = Boolean(fin.hasCarryOutstanding && fin.periodDebtValue > 0);
      const debtNeedsAction = debtIsOverdue || debtIsCarry;
      const debtLabel = (debtIsOverdue || debtIsCarry)
        ? `Overdue till ${fin.periodDebtLabel}`
        : '-';
      const prevYearNum = Number(financeYear) - 1;
      const carryYearLabel = Number.isFinite(prevYearNum) ? prevYearNum : `${financeYear}-1`;
      const carryNote = student.carryAmount > 0
        ? `<div class="text-xs text-slate-500 text-right mt-1">Includes carry-forward from ${carryYearLabel}: ${fmt(student.carryAmount)}</div>`
        : '';
      const statusNote = student.isGraduated
        ? `<div class="mt-1 text-xs font-semibold text-emerald-600 uppercase">Graduated</div>`
        : (!student.hasYearData && Object.keys(student.payments || {}).length === 0
            ? `<div class="mt-1 text-xs text-slate-500">No finance records captured for ${financeYear} yet.</div>`
            : '');

      const disablePay = student.isGraduated;
      const payBtnHtml = disablePay
        ? `<button class="payBtn px-2 py-1 text-xs bg-slate-200 text-slate-500 rounded ml-1 cursor-not-allowed" data-id="${id}" disabled>Pay</button>`
        : `<button class="payBtn px-2 py-1 text-xs bg-indigo-600 text-white rounded ml-1" data-id="${id}">Pay</button>`;

      const tr = document.createElement('tr');
      tr.className = debtNeedsAction ? 'table-row table-row-overdue' : 'table-row';
      tr.dataset.studentId = id;
      tr.innerHTML = `
        <td class="p-2 border text-center align-top">
          <button class="expander text-indigo-600 hover:text-indigo-800" data-id="${id}" title="Expand/Collapse">
            <i class="fa fa-chevron-down"></i>
          </button>
        </td>
        <td class="p-2 border align-top">${student.admissionNumber || ''}</td>
        <td class="p-2 border align-top">${fullName}</td>
        <td class="p-2 border align-top">${student.classLevel || ''}${statusNote}</td>
        <td class="p-2 border align-top text-right">${fmt(fin.feePerYear)}${carryNote}</td>
        <td class="p-2 border align-top">${student.paymentPlan || ''}</td>
        <td class="p-2 border align-top text-right">${fmt(fin.paidAmount)}</td>
        <td class="p-2 border align-top text-right">${fmt(fin.balance)}</td>
        <td class="p-2 border align-top">
          <div class="flex items-center justify-between gap-2">
            <span>${debtLabel}${(debtIsOverdue || debtIsCarry) && fin.overdueWindowLabel && fin.overdueWindowLabel !== '-' ? `<div class="text-xs text-red-700">${fin.overdueWindowLabel}</div>` : ''}</span>
            <span class="font-semibold ${debtNeedsAction ? 'text-red-700' : ''}">${fmt(fin.periodDebtValue)}</span>
          </div>
        </td>
        <td class="p-2 border align-top">
          <button class="viewBtn px-2 py-1 text-xs border rounded" data-id="${id}">View</button>
          ${payBtnHtml}
        </td>
      `;
      tbody.appendChild(tr);
      shown++;

      const brWrap = document.createElement('tbody');
      brWrap.innerHTML = breakdownRowHTML(id);
      tbody.appendChild(brWrap.firstElementChild);
    });

    const totalOutstanding = totalDue - totalCollected;
    const studentCountEl = document.getElementById('financeStudentCount');
    if (studentCountEl) {
      studentCountEl.textContent = String(shown);
    }
    const totalDueEl = document.getElementById('totalDue');
    if (totalDueEl) {
      totalDueEl.textContent = fmt(totalDue);
      totalDueEl.dataset.amount = String(totalDue);
    }
    const totalCollectedEl = document.getElementById('totalCollected');
    if (totalCollectedEl) {
      totalCollectedEl.textContent = fmt(totalCollected);
      totalCollectedEl.dataset.amount = String(totalCollected);
    }
    baseCollectedFromFees = Number(totalCollected) || 0;
    const totalOutstandingEl = document.getElementById('totalOutstanding');
    if (totalOutstandingEl) {
      totalOutstandingEl.textContent = fmt(totalOutstanding);
      totalOutstandingEl.dataset.amount = String(totalOutstanding);
    }

    tbody.querySelectorAll('.payBtn').forEach(btn => btn.addEventListener('click', (e) => {
      if (btn.disabled) return;
      openPaymentModalFor(e.currentTarget.dataset.id);
    }));
    tbody.querySelectorAll('.viewBtn').forEach(btn => btn.addEventListener('click', e => openDetailsModal(e.target.dataset.id)));
    try {
      document.dispatchEvent(new CustomEvent('finance:tableRendered', { detail: { year: financeYear } }));
    } catch (eventErr) {
      console.warn('finance:tableRendered dispatch failed', eventErr);
    }
    // NOTE: no per-row expander listeners added here (we use a single global delegated listener below)

    updateFinanceAggregates();
    recomputeMainKpis();
  }

  function computeAggregateTotals() {
    const totals = { totalStudents: 0, totalDue: 0, totalCollected: 0, totalOutstanding: 0, totalExpenses: 0 };
    if (!cachedStudents || !Object.keys(cachedStudents).length) return totals;
    Object.values(cachedStudents).forEach((student) => {
      if (!parentCtx.enabled && student.isGraduated) return;
      let fin = computeStudentFinancials(student);
      if (!student.hasYearData || student.isGraduated) {
        const effectiveFee = student.isGraduated ? 0 : Number(student.feePerYear) || 0;
        fin = {
          feePerYear: effectiveFee,
          paidAmount: 0,
        };
      }
      totals.totalStudents += 1;
      totals.totalDue += Number(fin.feePerYear) || 0;
      totals.totalCollected += Number(fin.paidAmount) || 0;
    });
    totals.totalOutstanding = totals.totalDue - totals.totalCollected;
    const totalExpensesEl = document.getElementById('totalExpenses');
    totals.totalExpenses = Number(totalExpensesEl?.dataset.amount || 0);
    const totalCollectedEl = document.getElementById('totalCollected');
    const totalOutstandingEl = document.getElementById('totalOutstanding');
    if (totalCollectedEl?.dataset?.amount) {
      totals.totalCollected = Number(totalCollectedEl.dataset.amount || 0);
    }
    if (totalOutstandingEl?.dataset?.amount) {
      totals.totalOutstanding = Number(totalOutstandingEl.dataset.amount || 0);
    }
    return totals;
  }

  async function updateFinanceAggregates() {
    if (parentCtx.enabled) return;
    financeAggregateSnapshot = computeAggregateTotals();
    if (!activeSchoolId || !db) return;
    try {
      const summaryRef = schoolRef(`financials/${financeYear}/financeAggregates`);
      await summaryRef.update({
        totalStudents: financeAggregateSnapshot.totalStudents,
        totalFeesExpected: financeAggregateSnapshot.totalDue,
        totalFeesCollected: financeAggregateSnapshot.totalCollected,
        totalFeesBalance: financeAggregateSnapshot.totalOutstanding,
        totalExpenses: financeAggregateSnapshot.totalExpenses,
        updatedAt: Date.now()
      });
    } catch (err) {
      console.warn('Failed to sync financeAggregates', err);
    }
  }

  // ====== SPEED FIX: lazy-load a single iframe when clicked, and close others ======
  function injectIframeIfNeeded(id) {
    const row = document.getElementById(`br-${id}`);
    if (!row) return;
    const slot = row.querySelector('.breakdown-slot');
    if (!slot || slot.dataset.loaded) return;

    const scopeParam = parentCtx.enabled ? '&scope=parent' : '';
    slot.innerHTML = `
      <div class="p-3 text-xs text-slate-500">Loading breakdown…</div>
      <iframe
        src="Tofinancehtml/payment.html?student=${encodeURIComponent(id)}&year=${encodeURIComponent(financeYear)}${scopeParam}"
        class="w-full h-[360px] rounded border"
        loading="lazy"
      ></iframe>
    `;
    slot.dataset.loaded = '1';
  }

  document.addEventListener('click', (e) => {
    const btn = e.target.closest('button.expander');
    if (!btn) return;

    const id = btn.dataset.id;
    const row = document.getElementById(`br-${id}`);
    if (!row) return;

    // Close any other open breakdown rows
    document.querySelectorAll('tr[id^="br-"]:not(.hidden)').forEach(r => {
      if (r !== row) r.classList.add('hidden');
    });
    // Reset other chevrons
    document.querySelectorAll('button.expander.open').forEach(b => {
      if (b !== btn) {
        b.classList.remove('open');
        const ic = b.querySelector('i'); if (ic) ic.classList.remove('fa-chevron-up'); if (ic) ic.classList.add('fa-chevron-down');
      }
    });

    const wasHidden = row.classList.contains('hidden');
    row.classList.toggle('hidden');

    const icon = btn.querySelector('i');
    if (wasHidden) {
      btn.classList.add('open');
      if (icon) { icon.classList.remove('fa-chevron-down'); icon.classList.add('fa-chevron-up'); }
      injectIframeIfNeeded(id);
    } else {
      btn.classList.remove('open');
      if (icon) { icon.classList.remove('fa-chevron-up'); icon.classList.add('fa-chevron-down'); }
    }
  });

  // Auto-resize when child posts its height
  window.addEventListener('message', (e) => {
    const d = e.data || {};
    if (d.type === 'resizeIframe' && d.id) {
      const frame = document.querySelector(`#br-${d.id} iframe`);
      if (frame) frame.style.height = Math.max(360, Number(d.height) || 0) + 'px';
    }
  });

  // ===== Cashbook + expenses =====
  const cashbookTitleYearEl = document.getElementById('cashbookTitleYear');
  const cashbookPocketEl = document.getElementById('cashbookPocket');
  const cashbookReceivedEl = document.getElementById('cashbookReceived');
  const cashbookMainIncomeEl = document.getElementById('cashbookMainIncome');
  const cashbookRefundCornerEl = document.getElementById('cashbookRefundCorner');
  const cashbookTableBody = document.querySelector('#cashbookTable tbody');
  const cashbookFundingForm = document.getElementById('cashbookFundingForm');

  const expenseForm = document.getElementById('expenseForm');
  const expenseTableBody = document.querySelector('#expenseTable tbody');

  function getCashbookTypeLabel(entryType) {
    const type = cashbookToolkit?.sanitizeType(entryType);
    if (type === cashbookToolkit?.ENTRY_TYPES?.DEDUCT_MAIN) return 'Deduct Main Income';
    if (type === cashbookToolkit?.ENTRY_TYPES?.REFUNDABLE) return 'Refundable';
    return 'Msaada/Support';
  }

  function recomputeMainKpis() {
    const dueEl = document.getElementById('totalDue');
    const outstandingEl = document.getElementById('totalOutstanding');
    const collectedEl = document.getElementById('totalCollected');
    const expensesEl = document.getElementById('totalExpenses');
    const netEl = document.getElementById('netBalance');

    const due = Number(dueEl?.dataset.amount || 0);
    const deductFromMain = Number(cashbookSummary?.deductFromMain || 0);
    const adjustedCollected = Math.max(0, Number(baseCollectedFromFees || 0) - deductFromMain);
    const adjustedOutstanding = Math.max(0, due - adjustedCollected);
    const adjustedNet = adjustedCollected;

    if (collectedEl) {
      collectedEl.textContent = fmt(adjustedCollected);
      collectedEl.dataset.amount = String(adjustedCollected);
    }
    if (outstandingEl) {
      outstandingEl.textContent = fmt(adjustedOutstanding);
      outstandingEl.dataset.amount = String(adjustedOutstanding);
    }
    if (expensesEl) {
      expensesEl.textContent = fmt(deductFromMain);
      expensesEl.dataset.amount = String(deductFromMain);
    }
    if (netEl) {
      netEl.textContent = fmt(adjustedNet);
      netEl.dataset.amount = String(adjustedNet);
    }
  }

  function recomputeCashbookSummary() {
    if (!cashbookToolkit) return;
    cashbookSummary = cashbookToolkit.summarize({
      fundingEntries: lastCashbookFundingEntries,
      expenseEntries: lastExpenseEntries,
    });
    if (cashbookPocketEl) cashbookPocketEl.textContent = fmt(cashbookSummary.inPocket);
    if (cashbookReceivedEl) cashbookReceivedEl.textContent = fmt(cashbookSummary.totalReceived);
    if (cashbookMainIncomeEl) cashbookMainIncomeEl.textContent = fmt(cashbookSummary.deductFromMain);
    if (cashbookRefundCornerEl) cashbookRefundCornerEl.textContent = fmt(cashbookSummary.refundCorner);
    recomputeMainKpis();
  }

  async function loadCashbookFunding(year = activeYear) {
    if (!cashbookToolkit || !cashbookTableBody) return;
    try {
      const targetYear = String(year || activeYear);
      const snap = await schoolRef(`cashbook/${targetYear}/funding`).once('value');
      const raw = snap.val() || {};
      const values = Array.isArray(raw) ? raw.filter(Boolean) : Object.entries(raw || {}).map(([id, row]) => cashbookToolkit.normalizeFundingEntry(row, id));
      values.sort((a, b) => (Number(a.timestamp || a.createdAt || 0) - Number(b.timestamp || b.createdAt || 0)));
      lastCashbookFundingEntries = values;
      cashbookTableBody.innerHTML = '';

      if (!values.length) {
        cashbookTableBody.innerHTML = `
          <tr>
            <td colspan="5" class="p-2 border text-center text-slate-500">No cashbook receipts for ${targetYear} yet.</td>
          </tr>
        `;
      } else {
        values.forEach((entry) => {
          const dateLabel = entry.timestamp ? new Date(entry.timestamp).toLocaleDateString() : (entry.date || '');
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td class="p-2 border">${dateLabel}</td>
            <td class="p-2 border">${entry.receivedFrom || ''}</td>
            <td class="p-2 border">${entry.receivedBy || ''}</td>
            <td class="p-2 border">${getCashbookTypeLabel(entry.entryType)}</td>
            <td class="p-2 border text-right">${fmt(entry.amount)}</td>
          `;
          cashbookTableBody.appendChild(tr);
        });
      }

      if (cashbookTitleYearEl) {
        const schoolName = currentSchool?.name || currentSchool?.code || currentSchool?.id || 'School';
        cashbookTitleYearEl.textContent = `${schoolName} Cashbook ${targetYear}`;
      }
      recomputeCashbookSummary();
    } catch (err) {
      console.error('Error loading cashbook funding:', err);
      alert('Error loading cashbook funding: ' + err.message);
    }
  }

  if (cashbookFundingForm) {
    cashbookFundingForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      if (!cashbookToolkit) return;
      const amount = Number(document.getElementById('cashbookAmount')?.value || 0);
      const date = (document.getElementById('cashbookDate')?.value || '').trim();
      const receivedFrom = (document.getElementById('cashbookReceivedFrom')?.value || '').trim();
      const receivedBy = (document.getElementById('cashbookReceivedBy')?.value || '').trim();
      const entryType = (document.getElementById('cashbookEntryType')?.value || '').trim();
      const note = (document.getElementById('cashbookNote')?.value || '').trim();

      if (!amount || amount <= 0 || !date || !receivedFrom || !receivedBy || !entryType) {
        alert('Fill all cashbook fields');
        return;
      }
      const normalizedType = cashbookToolkit.sanitizeType(entryType);
      if (normalizedType === cashbookToolkit.ENTRY_TYPES.DEDUCT_MAIN) {
        const availableInBank = Math.max(0, Number(baseCollectedFromFees || 0) - Number(cashbookSummary?.deductFromMain || 0));
        if (amount > availableInBank) {
          alert(`You can only deduct up to ${fmt(availableInBank)} from main collected.`);
          return;
        }
      }

      const year = String(activeYear || yearContext?.getSelectedYear?.() || new Date().getFullYear());
      const timestamp = new Date(`${date}T00:00:00`).getTime();
      await schoolRef(`cashbook/${year}/funding`).push({
        amount: cashbookToolkit.toAmount(amount),
        date,
        receivedFrom,
        receivedBy,
        entryType: normalizedType,
        note,
        timestamp: Number.isFinite(timestamp) ? timestamp : Date.now(),
        createdAt: Date.now(),
      });

      cashbookFundingForm.reset();
      const entryTypeEl = document.getElementById('cashbookEntryType');
      if (entryTypeEl) entryTypeEl.value = 'deduct_main_income';
      await loadCashbookFunding(year);
      updateFinanceAggregates();
    });
  }

  async function loadExpenses(year = activeYear) {
    try {
      const targetYear = String(year || activeYear);
      const snap = await schoolRef(`expenses/${targetYear}`).once('value');
      const raw = snap.val() || {};
      // Year-scoped only: do NOT fall back to unscoped /expenses, otherwise year switching shows wrong data.
      const expenseValues = Array.isArray(raw) ? raw.filter(Boolean) : Object.values(raw || {});
      lastExpenseEntries = expenseValues;
      expenseTableBody.innerHTML = '';
      if (!expenseValues.length) {
        expenseTableBody.innerHTML = `
          <tr>
            <td colspan="4" class="p-2 border text-center text-slate-500">No expenses for ${targetYear} yet.</td>
          </tr>
        `;
      }
      expenseValues.forEach(exp => {
        const dateLabel = exp.timestamp
          ? new Date(exp.timestamp).toLocaleDateString()
          : (exp.date || '');
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="p-2 border">${exp.category || ''}</td>
          <td class="p-2 border">${exp.description || ''}</td>
          <td class="p-2 border text-right">${fmt(exp.amount)}</td>
          <td class="p-2 border">${dateLabel}</td>
        `;
        expenseTableBody.appendChild(tr);
      });
      recomputeCashbookSummary();
      updateFinanceAggregates();
    } catch (err) {
      console.error('Error loading expenses:', err);
      alert('Error loading expenses: ' + err.message);
    }
  }

  if (expenseForm) {
    expenseForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const category = (document.getElementById('expenseCategory')?.value || '').trim();
      const description = (document.getElementById('expenseDescription')?.value || '').trim();
      const amount = Number(document.getElementById('expenseAmount')?.value || 0);
      const date = (document.getElementById('expenseDate')?.value || '').trim();

      if (!category || !description || !amount || !date) {
        alert('Fill all fields');
        return;
      }
      const inPocket = Number(cashbookSummary?.inPocket || 0);
      if (amount > inPocket) {
        alert(`Cashbook balance is only ${fmt(inPocket)}. Record cashbook receipt first.`);
        return;
      }

      const year = String(activeYear || yearContext?.getSelectedYear?.() || new Date().getFullYear());
      const timestamp = new Date(`${date}T00:00:00`).getTime();
      await schoolRef(`expenses/${year}`).push({
        category,
        description,
        amount,
        date,
        timestamp: Number.isFinite(timestamp) ? timestamp : Date.now(),
        createdAt: Date.now(),
      });

      expenseForm.reset();
      await loadExpenses(year);
    });
  }

  async function refreshFinanceData(year = activeYear) {
    await loadStudents(year);
    await loadCashbookFunding(year);
    await loadExpenses(year);
  }

  // ===== CSV/PDF downloaders (parent-scoped) =====
  // IMPORTANT: Exports must read exactly what the UI table displays to avoid mismatches
  // (e.g. PDF showing debt 356,000 while UI shows 0 — causes parent complaints and lost customers).
  function getStudentContact(student) {
    return (
      student?.primaryParentContact ||
      student?.parentPhone ||
      student?.guardianPhone ||
      student?.contact ||
      student?.phone ||
      '--'
    );
  }

  function parseNumberFromCell(el) {
    if (!el) return 0;
    const raw = (el.innerText || el.textContent || '').replace(/\s/g, '');
    const cleaned = raw.replace(/[^\d]/g, '');
    return Math.max(0, parseInt(cleaned, 10) || 0);
  }

  function parseDebtAmountFromCell(debtCell) {
    if (!debtCell) return 0;
    const spans = debtCell.querySelectorAll('span');
    const amountSpan = Array.from(spans).find((s) => {
      const t = (s.innerText || s.textContent || '').trim();
      return /^\d[\d,]*$/.test(t.replace(/\s/g, ''));
    });
    if (amountSpan) return parseNumberFromCell(amountSpan);
    const fullText = (debtCell.innerText || '').trim();
    const lastNumMatch = fullText.match(/(\d[\d,]*)\s*$/);
    return lastNumMatch ? parseNumberFromCell({ innerText: lastNumMatch[1] }) : 0;
  }

  function getTableRowsForExport() {
    const table = document.getElementById('financeTable');
    if (!table) return [];
    const result = [];
    const allRows = table.querySelectorAll('tbody tr');
    allRows.forEach((tr) => {
      const tds = tr.querySelectorAll('td');
      if (tds.length < 10) return;
      const adm = (tds[1]?.innerText || '').trim();
      if (!adm) return;
      const fullName = (tds[2]?.innerText || '').trim();
      const classVal = (tds[3]?.innerText || '').replace(/\s*No finance records.*|\s*Graduated\s*/gi, '').trim();
      const feeVal = tr.dataset.carryForwardTotal ? Number(tr.dataset.carryForwardTotal) || 0 : parseNumberFromCell(tds[4]);
      const plan = (tds[5]?.innerText || '').trim();
      const paidVal = parseNumberFromCell(tds[6]);
      const balanceVal = parseNumberFromCell(tds[7]);
      const debtCellText = (tds[8]?.innerText || '').trim();
      const debtAmountVal = parseDebtAmountFromCell(tds[8]);
      let debtLabel = '-';
      if (debtAmountVal > 0 && debtCellText) {
        const dateMatch = debtCellText.match(/\d{1,2}\/\d{1,2}\/\d{2,4}/);
        debtLabel = dateMatch ? dateMatch[0] : debtCellText.replace(/\d[\d,]*\s*$/, '').replace(/^Overdue till\s*/i, '').trim() || new Date().toLocaleDateString();
      }
      const lookup = lookupStudentByAdmission(adm);
      const parentContact = lookup?.student ? getStudentContact(lookup.student) : '--';
      result.push({
        admissionNumber: adm,
        fullName,
        parentContact,
        classLevel: classVal,
        feePerYear: feeVal,
        paymentPlan: plan,
        paidAmount: paidVal,
        balance: balanceVal,
        periodDebtLabel: debtLabel,
        periodDebtValue: debtAmountVal
      });
    });
    return result;
  }

  function downloadCSV_Main() {
    const headerRow = ['Admission No', 'Full Name', 'Parent Contact', 'Class', 'Fee (Year)', 'Plan', 'Paid', 'Balance (Year)', 'Debt till …', 'Debt Amount'];
    const rows = [headerRow];
    const tableRows = getTableRowsForExport();
    let totalFee = 0, totalPaid = 0, totalBal = 0, totalDebt = 0;
    tableRows.forEach((r) => {
      rows.push([r.admissionNumber, r.fullName, r.parentContact, r.classLevel, fmt(r.feePerYear), r.paymentPlan, fmt(r.paidAmount), fmt(r.balance), r.periodDebtLabel, fmt(r.periodDebtValue)]);
      totalFee += r.feePerYear;
      totalPaid += r.paidAmount;
      totalBal += r.balance;
      totalDebt += r.periodDebtValue;
    });
    rows.push(['TOTAL', '', '', '', fmt(totalFee), '', fmt(totalPaid), fmt(totalBal), '', fmt(totalDebt)]);
    const ws = XLSX.utils.aoa_to_sheet(rows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Finance');
    
    // Parent mode: use child-specific filename
    let filename = `finance_export_${Date.now()}.xlsx`;
    if (parentCtx.enabled) {
      const onlyId = Object.keys(cachedStudents||{})[0];
      const only = cachedStudents[onlyId] || {};
      const adm = only.admissionNumber || onlyId;
      filename = `finance_${adm}_${(parentCtx.year||financeYear)}.xlsx`;
    }
    XLSX.writeFile(wb, filename);
  }

  function downloadPDF_Main() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: 'landscape' });
    const headers = [['Admission No', 'Full Name', 'Parent Contact', 'Class', 'Fee (Year)', 'Plan', 'Paid', 'Balance (Year)', 'Debt till …', 'Debt Amount']];
    const tableRows = getTableRowsForExport();
    const body = tableRows.map((r) => [r.admissionNumber, r.fullName, r.parentContact, r.classLevel, fmt(r.feePerYear), r.paymentPlan, fmt(r.paidAmount), fmt(r.balance), r.periodDebtLabel, fmt(r.periodDebtValue)]);
    const totalFee = tableRows.reduce((s, r) => s + r.feePerYear, 0);
    const totalPaid = tableRows.reduce((s, r) => s + r.paidAmount, 0);
    const totalBal = tableRows.reduce((s, r) => s + r.balance, 0);
    const totalDebt = tableRows.reduce((s, r) => s + r.periodDebtValue, 0);
    body.push(['TOTAL', '', '', '', fmt(totalFee), '', fmt(totalPaid), fmt(totalBal), '', fmt(totalDebt)]);
    doc.setFontSize(14); doc.text('SoMAp Finance Report', 14, 14);
    doc.autoTable({ head: headers, body, startY: 20, styles: { fontSize: 8 } });
    
    // Parent mode: use child-specific filename
    let filename = `finance_report_${Date.now()}.pdf`;
    if (parentCtx.enabled) {
      const onlyId = Object.keys(cachedStudents||{})[0];
      const only = cachedStudents[onlyId] || {};
      const adm = only.admissionNumber || onlyId;
      filename = `finance_${adm}_${(parentCtx.year||financeYear)}.pdf`;
    }
    doc.save(filename);
  }

  function _gatherDebtNow() {
    const tableRows = getTableRowsForExport();
    const debtorRows = tableRows.filter((r) => r.periodDebtValue > 0);
    const rows = debtorRows.map((r) => [r.admissionNumber, r.fullName, r.parentContact, r.classLevel, r.paymentPlan, r.periodDebtLabel, fmt(r.periodDebtValue)]);
    const totalDebt = debtorRows.reduce((s, r) => s + r.periodDebtValue, 0);
    return { rows, totalDebt: fmt(totalDebt) };
  }

  function downloadCSV_DebtNow() {
    const header = ['Admission No', 'Full Name', 'Parent Contact', 'Class', 'Plan', 'Debt till …', 'Debt Amount'];
    const { rows, totalDebt } = _gatherDebtNow();
    const data = [header, ...rows, ['TOTAL', '', '', '', '', '', totalDebt]];
    const ws = XLSX.utils.aoa_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Debt Now');
    XLSX.writeFile(wb, `debt_now_${Date.now()}.xlsx`);
  }

  function downloadPDF_DebtNow() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: 'landscape' });
    const header = [['Admission No', 'Full Name', 'Parent Contact', 'Class', 'Plan', 'Debt till …', 'Debt Amount']];
    const { rows, totalDebt } = _gatherDebtNow();
    const body = [...rows, ['TOTAL', '', '', '', '', '', totalDebt]];
    doc.setFontSize(14); doc.text('Debt List (Current Period)', 14, 14);
    doc.autoTable({ head: header, body: body, startY: 20, styles: { fontSize: 8 } });
    doc.save(`debt_now_${Date.now()}.pdf`);
  }

  function _gatherBreakdown() {
    const sheets = [];
    const filterClass = classFilter.value;
    Object.entries(cachedStudents).forEach(([id, s]) => {
      if (filterClass && s.classLevel !== filterClass) return;
      const fin = computeStudentFinancials(s);
      const fullName = `${s.firstName || ''} ${s.middleName || ''} ${s.lastName || ''}`.trim();
      const rows = [['Period', 'Expected', 'Allocated Paid', 'Remaining', 'Status', 'Window']];
      let totalExp = 0, totalPaid = 0;
      fin.scheduleItems.forEach(it => {
        const need = it.amount, got = it.paidAllocated, rem = Math.max(0, need - got);
        totalExp += need; totalPaid += got;
        rows.push([it.label, need, got, rem, it.status, `${new Date(it.fromTS).toLocaleDateString()} – ${new Date(it.toTS).toLocaleDateString()}`]);
      });
      const totalRem = Math.max(0, totalExp - totalPaid);
      rows.push(['TOTAL', totalExp, totalPaid, totalRem, '', '']);
      sheets.push({
        title: `${fullName} (${s.admissionNumber || ''})`,
        contact: getStudentContact(s),
        rows
      });
    });
    return sheets;
  }

  function downloadCSV_Breakdown() {
    const wb = XLSX.utils.book_new();
    const sheets = _gatherBreakdown();
    if (!sheets.length) return alert('No students to export.');
    sheets.forEach(sh => {
      const sheetRows = [
        ['Student', sh.title || ''],
        ['Parent Contact', sh.contact || '--'],
        [],
        ...sh.rows
      ];
      const ws = XLSX.utils.aoa_to_sheet(sheetRows);
      XLSX.utils.book_append_sheet(wb, ws, sh.title.slice(0, 31));
    });
    
    // Parent mode: use child-specific filename
    let filename = `breakdowns_${Date.now()}.xlsx`;
    if (parentCtx.enabled) {
      const onlyId = Object.keys(cachedStudents||{})[0];
      const only = cachedStudents[onlyId] || {};
      const adm = only.admissionNumber || onlyId;
      filename = `breakdown_${adm}_${(parentCtx.year||financeYear)}.xlsx`;
    }
    XLSX.writeFile(wb, filename);
  }

  function downloadPDF_Breakdown() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: 'landscape' });
    const sheets = _gatherBreakdown();
    if (!sheets.length) return alert('No students to export.');
    sheets.forEach((sh, idx) => {
      if (idx > 0) doc.addPage();
      doc.setFontSize(14);
      doc.text(`Installment Breakdown — ${sh.title}`, 14, 14);
      doc.setFontSize(10);
      doc.text(`Parent Contact: ${sh.contact || '--'}`, 14, 20);
      doc.autoTable({ head: [['Period', 'Expected', 'Allocated Paid', 'Remaining', 'Status', 'Window']], body: sh.rows.slice(1), startY: 24, styles: { fontSize: 8 } });
    });
    
    // Parent mode: use child-specific filename
    let filename = `breakdowns_${Date.now()}.pdf`;
    if (parentCtx.enabled) {
      const onlyId = Object.keys(cachedStudents||{})[0];
      const only = cachedStudents[onlyId] || {};
      const adm = only.admissionNumber || onlyId;
      filename = `breakdown_${adm}_${(parentCtx.year||financeYear)}.pdf`;
    }
    doc.save(filename);
  }

  // ===== Payments & modals (unchanged) =====
  function populateStudentSelect() {
    studentSelect.innerHTML = '<option value="">-- Select student --</option>';
    Object.entries(cachedStudents).forEach(([id, s]) => {
      const fullName = `${s.firstName || ''} ${s.middleName || ''} ${s.lastName || ''}`.trim();
      const opt = document.createElement('option');
      opt.value = id;
      opt.textContent = `${fullName} — ${s.classLevel || ''} — ${s.admissionNumber || ''}`;
      studentSelect.appendChild(opt);
    });
  }

  function openPaymentModalFor(id) {
    if (!cachedStudents[id]) return alert('Student not found');
    studentSelect.value = id;
    // Set default date to today
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('paymentDate').value = today;
    paymentModal.style.display = 'block';
  }
  function closePaymentModalFn() { paymentModal.style.display = 'none'; paymentForm.reset(); }

  const LEDGER_ACTION_PASSWORD = 'REHEMam!';

  function confirmLedgerAction(actionLabel) {
    const input = prompt(`Enter password to ${actionLabel}:`);
    if (input === null) return false;
    if (input !== LEDGER_ACTION_PASSWORD) {
      alert('Incorrect password.');
      return false;
    }
    return true;
  }

  function parseLedgerTimestampInput(input, fallback) {
    const raw = String(input || '').trim();
    if (!raw) return fallback;
    const normalized = raw.replace(' ', 'T');
    const ts = Date.parse(normalized);
    if (!Number.isFinite(ts)) return null;
    return ts;
  }

  async function handleLedgerEdit(studentId, paymentId) {
    if (!confirmLedgerAction('edit this payment')) return;
    const student = cachedStudents[studentId];
    if (!student) return alert('Student not found');
    const payment = student.payments?.[paymentId];
    if (!payment) return alert('Payment not found');

    const amountInput = prompt('Edit amount (TSh)', payment.amount != null ? String(payment.amount) : '');
    if (amountInput === null) return;
    const amount = Number(amountInput);
    if (!Number.isFinite(amount) || amount < 0) {
      alert('Enter a valid non-negative amount.');
      return;
    }
    const methodInput = prompt('Edit method', payment.method || '');
    if (methodInput === null) return;
    const noteInput = prompt('Edit note', payment.note || '');
    if (noteInput === null) return;
    const currentStamp = payment.timestamp ? new Date(payment.timestamp) : null;
    const defaultStamp = currentStamp ? currentStamp.toISOString().slice(0, 16).replace('T', ' ') : '';
    const dateInput = prompt('Edit date/time (YYYY-MM-DD or YYYY-MM-DD HH:mm). Leave blank to keep.', defaultStamp);
    if (dateInput === null) return;
    const nextTimestamp = parseLedgerTimestampInput(dateInput, payment.timestamp || Date.now());
    if (nextTimestamp === null) {
      alert('Invalid date/time format.');
      return;
    }

    try {
      await schoolRef(`financeLedgers/${financeYear}/${studentId}/payments/${paymentId}`).update({
        amount: Math.round(amount),
        method: (methodInput || '').trim(),
        note: (noteInput || '').trim(),
        timestamp: nextTimestamp,
      });
      await refreshFinanceData(financeYear);
      await openDetailsModal(studentId);
    } catch (err) {
      console.error('Failed to edit payment', err);
      alert('Failed to edit payment: ' + (err?.message || err));
    }
  }

  async function handleLedgerDelete(studentId, paymentId) {
    if (!confirmLedgerAction('delete this payment')) return;
    if (!confirm('Delete this payment permanently?')) return;
    try {
      await schoolRef(`financeLedgers/${financeYear}/${studentId}/payments/${paymentId}`).remove();
      await refreshFinanceData(financeYear);
      await openDetailsModal(studentId);
    } catch (err) {
      console.error('Failed to delete payment', err);
      alert('Failed to delete payment: ' + (err?.message || err));
    }
  }

  async function promptEditYearFee(studentId) {
    if (!db) return alert('Database connection not ready.');
    if (!hasFinanceAdminAccess()) return alert('Not authorized to edit fees.');
    const student = cachedStudents[studentId];
    if (!student) return alert('Student not found');
    const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim() || (student.admissionNumber || studentId);
    const currentBase = Math.max(0, Number(student.baseFee || 0));
    const input = prompt(`Set base fee for ${fullName} (${financeYear})`, currentBase ? String(currentBase) : '');
    if (input === null) return;
    const parsed = Number(input);
    if (!Number.isFinite(parsed) || parsed < 0) {
      alert('Enter a valid non-negative amount.');
      return;
    }
    const rounded = Math.round(parsed);
    try {
      await schoolRef(`studentFees/${financeYear}/${studentId}`).update({ feePerYear: rounded });
      await loadStudents(financeYear);
      openDetailsModal(studentId);
      alert(`Base fee updated for ${financeYear}.`);
    } catch (err) {
      console.error('Failed to update fee', err);
      alert('Failed to update fee: ' + (err?.message || err));
    }
  }

  async function openDetailsModal(id) {
    const s = cachedStudents[id]; if (!s) return alert('Student not found');
    let fin = computeStudentFinancials(s);
    if (s.isGraduated) {
      fin = {
        feePerYear: 0,
        previousDebt: 0,
        paidAmount: 0,
        balance: 0,
        periodDebtLabel: '-',
        periodDebtValue: 0,
        credit: 0,
        scheduleItems: [],
      };
    }
    const fullName = `${s.firstName || ''} ${s.middleName || ''} ${s.lastName || ''}`.trim();
    const targetYearNum = Number(financeYear);
    const admission = s.admissionNumber || id;
    let carryForwardPrev = 0;
    if (Number.isFinite(targetYearNum)) {
      const prevYear = targetYearNum - 1;
      if (prevYear >= CARRY_FORWARD_START_YEAR) {
        const safeId = (typeof CSS !== 'undefined' && CSS.escape) ? CSS.escape(String(id)) : String(id).replace(/"/g, '\\"');
        const rowEl = document.querySelector(`#financeTable tbody tr[data-student-id="${safeId}"]`);
        const rowCarry = Number(rowEl?.dataset?.carryForward || 0);
        if (rowCarry > 0) {
          carryForwardPrev = rowCarry;
        } else {
          const key = `${targetYearNum}::${admission}`;
          const sharedCarry = window.__financeCarryForwardVisual?.[key]?.carry;
          if (sharedCarry) carryForwardPrev = Number(sharedCarry) || 0;
        }
        if (carryForwardPrev <= 0 && typeof window.__finance_getBalanceForYearAdmission === 'function') {
          try {
            const bal = await window.__finance_getBalanceForYearAdmission(prevYear, admission);
            carryForwardPrev = Math.max(0, Number(bal) || 0);
          } catch (err) {
            console.warn('Carry-forward (details modal) lookup failed', admission, prevYear, err);
          }
        }
      }
    }
    carryForwardPrev = Math.max(0, Number(carryForwardPrev) || 0);
    const dbCarry = Math.max(0, Number(s.carryAmount || 0));
    const baseFeeRaw = s.baseFee != null ? Number(s.baseFee) : Number(s.feePerYear || 0) - dbCarry;
    const baseFee = Math.max(0, Number.isFinite(baseFeeRaw) ? baseFeeRaw : 0);
    const prevYearLabel = Number.isFinite(targetYearNum) ? targetYearNum - 1 : 'Prev';
    const effectiveCarry = Math.max(dbCarry, carryForwardPrev);
    const totalDue = baseFee + effectiveCarry;
    const paidTotal = Math.max(0, Number(fin.paidAmount || 0));
    const balanceDisplay = Math.max(0, totalDue - paidTotal);
    const carryNotYetMerged = Math.max(0, Number(carryForwardPrev || 0) - Math.max(0, Number(s.carryAmount || 0)));
    const debtWithCarry = Math.max(0, Number(fin.periodDebtValue || 0) + carryNotYetMerged);

    let carryLine = '';
    if (carryForwardPrev > 0 || dbCarry > 0) {
      const parts = [];
      if (carryForwardPrev > 0) {
        parts.push(`${fmt(carryForwardPrev)}${dbCarry > 0 && dbCarry !== carryForwardPrev ? '' : ''}`);
      }
      if (dbCarry > 0 && dbCarry !== carryForwardPrev) {
        parts.push(`Existing carry-in: ${fmt(dbCarry)}`);
      }
      const combined = parts.length ? parts.join(' + ') : fmt(effectiveCarry);
      carryLine = `<p><strong>Carry Forward (${prevYearLabel}):</strong> ${combined}</p>`;
    }

    const carrySummaryNote = (carryForwardPrev > 0 && dbCarry > 0 && dbCarry === carryForwardPrev)
      ? `<span class="text-xs text-slate-500">(Already captured in ${financeYear} record)</span>`
      : '';

    let html = `
      <p><strong>Name:</strong> ${fullName}</p>
      <p><strong>Admission No:</strong> ${s.admissionNumber || ''}</p>
      <p><strong>Class:</strong> ${s.classLevel || ''}</p>
      <p><strong>Fee (base):</strong> ${fmt(baseFee)}</p>
      ${carryLine || ''}
      ${carrySummaryNote ? `<p class="mt-0">${carrySummaryNote}</p>` : ''}
      <p><strong>Total Due (incl. carry):</strong> ${fmt(totalDue)}</p>
      <p><strong>Payment Plan:</strong> ${s.paymentPlan || ''}</p>
      <p><strong>Debt till:</strong> ${fin.periodDebtLabel} - <strong>${fmt(debtWithCarry)}</strong></p>
      <p><strong>Paid:</strong> ${fmt(paidTotal)}</p>
      <p><strong>Balance (incl. carry):</strong> ${fmt(balanceDisplay)}</p>
    `;
    if (hasFinanceAdminAccess()) {
      html += `
        <div class="mt-3 flex flex-col gap-2">
          <button class="px-3 py-1.5 text-sm bg-amber-500 text-white rounded-md hover:bg-amber-600 transition" data-action="edit-fee-year" data-id="${id}">
            Edit Fee (year)
          </button>
          <span class="text-xs text-slate-500">Updates apply only to ${financeYear} and adjust the base before carry-forward.</span>
        </div>
      `;
    }
    if (!s.hasYearData) {
      html += `
        <div class="mt-2 text-xs text-slate-500">No finance data recorded for ${financeYear}. All totals show as 0 until this year's structure or receipts are captured.</div>
      `;
    }
    html += `
      <hr class="my-3"/>
      <h4 class="font-semibold">Payments Ledger</h4>
    `;
    const paymentEntries = Object.entries(s.payments || {}).filter(([, p]) => p);
    if (!paymentEntries.length) {
      html += '<div class="text-sm text-gray-500">No payments recorded yet.</div>';
    } else {
      const escapeAttr = (value) => String(value).replace(/"/g, '&quot;');
      html += `<div class="overflow-auto"><table class="min-w-full text-xs mt-2"><thead><tr class="table-header"><th class="p-1 border">Date</th><th class="p-1 border">Amount</th><th class="p-1 border">Method</th><th class="p-1 border">Note</th><th class="p-1 border">Actions</th></tr></thead><tbody>`;
      paymentEntries.sort((a, b) => (a[1]?.timestamp || 0) - (b[1]?.timestamp || 0)).forEach(([paymentId, p]) => {
        const d = new Date(p.timestamp || 0).toLocaleString();
        const safeId = escapeAttr(paymentId);
        html += `<tr><td class="p-1 border">${d}</td><td class="p-1 border">${fmt(p.amount)}</td><td class="p-1 border">${p.method || ''}</td><td class="p-1 border">${p.note || ''}</td><td class="p-1 border"><div class="flex gap-1"><button class="px-2 py-0.5 text-[11px] bg-amber-500 text-white rounded" data-action="edit-payment" data-payment-id="${safeId}">Edit</button><button class="px-2 py-0.5 text-[11px] bg-rose-600 text-white rounded" data-action="delete-payment" data-payment-id="${safeId}">Delete</button></div></td></tr>`;
      });
      html += `</tbody></table></div>`;
    }
    detailsContent.innerHTML = html;
    if (hasFinanceAdminAccess()) {
      const editBtn = detailsContent.querySelector('[data-action="edit-fee-year"]');
      if (editBtn) editBtn.addEventListener('click', () => promptEditYearFee(id));
    }
    detailsContent.querySelectorAll('[data-action="edit-payment"]').forEach((btn) => {
      const paymentId = btn.getAttribute('data-payment-id');
      btn.addEventListener('click', () => handleLedgerEdit(id, paymentId));
    });
    detailsContent.querySelectorAll('[data-action="delete-payment"]').forEach((btn) => {
      const paymentId = btn.getAttribute('data-payment-id');
      btn.addEventListener('click', () => handleLedgerDelete(id, paymentId));
    });
    detailsModal.style.display = 'block';
  }
  function closeDetailsModalFn() { detailsModal.style.display = 'none'; detailsContent.innerHTML = ''; }

  function resolveRecorderEmail() {
    if (window.currentUserEmail) return window.currentUserEmail;
    try {
      if (window.sessionStorage) {
        const stored = sessionStorage.getItem('somapUserEmail') || sessionStorage.getItem('userEmail');
        if (stored) return stored;
      }
    } catch (_) {}
    try {
      if (firebase.auth) {
        const user = firebase.auth().currentUser;
        if (user && user.email) return user.email;
      }
    } catch (_) {}
    return 'unknown';
  }

  paymentForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const studentId = studentSelect.value;
    const amount = Number(document.getElementById('paymentAmount').value || 0);
    const paymentDateInput = document.getElementById('paymentDate').value;
    const method = document.getElementById('paymentMethod').value || 'Cash';
    const reference = (document.getElementById('paymentReference').value || '').trim();
    const paidBy = (document.getElementById('paymentPaidBy').value || '').trim();
    const payerContact = (document.getElementById('paymentPayerContact').value || '').trim();
    const note = document.getElementById('paymentNote').value || '';
    if (!studentId) return alert('Choose a student');
    if (amount <= 0) return alert('Enter a valid amount');
    if (!paymentDateInput) return alert('Please select payment date');
    if (!paidBy) return alert('Please enter who made the payment');
    if (!payerContact) return alert('Please enter contact of payer');
    try {
      const studentRef = schoolRef(`students/${studentId}`);
      const snap = await studentRef.once('value');
      const student = snap.val();
      if (!student) throw new Error('Student not found');

      const fin = computeStudentFinancials(student);
      const totalRequired = Number(fin.feePerYear || 0);
      const totalPaidBefore = Number(fin.paidAmount || 0);
      const newBalance = Math.max(0, totalRequired - Math.min(totalRequired, totalPaidBefore + amount));
      const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.replace(/\s+/g, ' ').trim();
      const recorder = resolveRecorderEmail();
      const paymentTimestamp = new Date(paymentDateInput).getTime() || Date.now();
      const parentContact = student.primaryParentContact || student.parentPhone || student.guardianPhone || student.emergencyPhone || '--';

      const pendingRef = schoolRef('approvalsPending').push();
      await pendingRef.set({
        approvalId: pendingRef.key,
        sourceModule: 'finance',
        studentAdm: student.admissionNumber || studentId,
        studentName: fullName || (student.admissionNumber || studentId),
        className: student.classLevel || '',
        parentContact,
        amountPaidNow: Math.round(amount),
        paymentMethod: method,
        paymentReferenceCode: reference || 'N/A',
        datePaid: paymentTimestamp,
        paidBy: paidBy,
        payerContact: payerContact,
        recordedBy: recorder,
        status: 'pending',
        academicYear: financeYear,
        notes: note,
        totalRequired,
        totalPaidBefore,
        newBalanceAfterThis: newBalance,
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        modulePayload: {
          studentKey: studentId,
          payment: {
            amount: Math.round(amount),
            method,
            note,
            timestamp: paymentTimestamp,
            recordedBy: recorder,
            referenceCode: reference || null,
            paidBy: paidBy,
            payerContact: payerContact,
          },
          breakdown: [
            { label: 'Academic Year', value: financeYear },
            { label: 'Plan', value: student.paymentPlan || '--' },
            { label: 'Fee (Year)', value: `TSh ${fmt(totalRequired)}` },
            { label: 'Paid Before', value: `TSh ${fmt(totalPaidBefore)}` },
            { label: 'Balance After Approval', value: `TSh ${fmt(newBalance)}` },
            { label: 'Paid By', value: paidBy },
            { label: 'Payer Contact', value: payerContact },
          ],
        },
      });

      alert('Payment sent for admin approval. Student will update once approved.');
      paymentForm.reset();
      closePaymentModalFn();
      await loadStudents();
    } catch (err) {
      console.error('Error recording payment', err);
      alert('Error recording payment: ' + err.message);
    }
  });

  // ===== Parent mode UI lockdown =====
  function applyParentModeUI(){
    if (!parentCtx.enabled) return;
    
    const fsCard = document.getElementById('financialStatementsCard');
    if (fsCard) fsCard.style.display = 'none';
    
    // Hide filters & bulk exports that could reveal other students
    ['classFilter','showOnlyDebtors','downloadDebtNowCsv','downloadDebtNowPdf',
     'downloadBreakdownCsv','downloadBreakdownPdf'].forEach(id=>{
      const el = document.getElementById(id); 
      if (el) el.style.display = 'none';
    });
    
    // Hide expenses KPIs (parents don't need to see school expenses)
    const kpiCards = document.querySelectorAll('.bg-white.p-4.rounded.shadow');
    if (kpiCards[3]) kpiCards[3].style.display = 'none'; // Total Expenses
    if (kpiCards[4]) kpiCards[4].style.display = 'none'; // Net Balance
    
    // Hide entire expenses section (form, table, reports)
    const expenseSections = document.querySelectorAll('.bg-white.rounded.shadow.p-4, #cashbookSection');
    expenseSections.forEach(section => {
      if (section.querySelector('#expenseForm') || section.querySelector('#expenseTable') || section.id === 'cashbookSection') {
        section.style.display = 'none';
      }
    });
    
    // Rename finance KPIs to parent-friendly labels
    const kpiHeaders = document.querySelectorAll('.bg-white.p-4.rounded.shadow h3');
    if (kpiHeaders[0]) kpiHeaders[0].textContent = 'Your Total Due (Year)';
    if (kpiHeaders[1]) kpiHeaders[1].textContent = 'Paid (Total)';
    if (kpiHeaders[2]) kpiHeaders[2].textContent = 'Balance';
    
    // Auto-open the lone breakdown row (there is exactly one row in parent mode)
    setTimeout(() => {
      const onlyId = Object.keys(cachedStudents||{})[0];
      if (onlyId) {
        const br = document.getElementById(`br-${onlyId}`);
        if (br) {
          br.classList.remove('hidden');
          injectIframeIfNeeded(onlyId);
          // Also rotate the chevron
          const expandBtn = document.querySelector(`button.expander[data-id="${onlyId}"]`);
          if (expandBtn) {
            expandBtn.classList.add('open');
            const icon = expandBtn.querySelector('i');
            if (icon) { 
              icon.classList.remove('fa-chevron-down'); 
              icon.classList.add('fa-chevron-up'); 
            }
          }
        }
      }
    }, 100);
  }

  // ===== Data loading and UI wiring =====
  async function loadStudents(year = activeYear) {
    if (!db) return;
    const targetYear = String(year || activeYear);
    activeYear = targetYear;
    financeYear = targetYear;
    try { sessionStorage.setItem('somap_selected_year', targetYear); } catch (_) {}
    updateYearHint();
    if (yearSelectEl && yearSelectEl.value !== targetYear) {
      yearSelectEl.value = targetYear;
    }
    try {
      const [
        baseSnap,
        anchorEnrollSnap,
        enrollmentSnap,
        classFeesSnap,
        stOverridesSnap,
        plansSnap,
        ledgerSnap,
        carrySnap,
        deadlineExtensionsSnap,
        studentFeesSnap,
        studentPlansSnap,
        financePlansSnap,
      ] = await Promise.all([
        schoolRef('students').once('value'),
        schoolRef(`enrollments/${SOMAP_DEFAULT_YEAR}`).once('value'),
        schoolRef(`enrollments/${targetYear}`).once('value'),
        schoolRef(`feesStructure/${targetYear}`).once('value'),
        schoolRef(`studentOverrides/${targetYear}`).once('value'),
        schoolRef(`installmentPlans/${targetYear}`).once('value'),
        schoolRef(`financeLedgers/${targetYear}`).once('value'),
        schoolRef(`financeCarryForward/${targetYear}`).once('value'),
        schoolRef(`financeDeadlineExtensions/${targetYear}`).once('value'),
        schoolRef(`studentFees/${targetYear}`).once('value'),
        schoolRef(`finance/${targetYear}/studentPlans`).once('value'),
        schoolRef(`finance/${targetYear}/plans`).once('value'),
      ]);
      let baseStudents = baseSnap.val() || {};
      let anchorEnrollments = anchorEnrollSnap.val() || {};
      let yearEnrollments = enrollmentSnap.val() || {};
      if (isSocratesSchool) {
        try {
          const [legacyBaseSnap, legacyAnchorEnrollSnap, legacyYearEnrollSnap] = await Promise.all([
            db.ref('students').once('value'),
            db.ref(`enrollments/${SOMAP_DEFAULT_YEAR}`).once('value'),
            db.ref(`enrollments/${targetYear}`).once('value'),
          ]);
          baseStudents = { ...(legacyBaseSnap.val() || {}), ...(baseStudents || {}) };
          anchorEnrollments = { ...(legacyAnchorEnrollSnap.val() || {}), ...(anchorEnrollments || {}) };
          yearEnrollments = { ...(legacyYearEnrollSnap.val() || {}), ...(yearEnrollments || {}) };
        } catch (legacyReadErr) {
          console.warn('Legacy students/enrollments read failed', legacyReadErr?.message || legacyReadErr);
        }
      }
      let ledgerData = ledgerSnap.val() || {};
      try {
        const legacyLedgerSnap = await schoolRef('financeLedgers').once('value');
        const legacyLedgerData = legacyLedgerSnap.val() || {};
        if (isSocratesSchool) {
          ledgerData = { ...(legacyLedgerData || {}), ...(ledgerData || {}) };
        } else if (!Object.keys(ledgerData || {}).length) {
          ledgerData = legacyLedgerData;
        }
      } catch (legacyErr) {
        console.warn('Legacy financeLedgers read failed', legacyErr?.message || legacyErr);
      }
      let studentFeesData = studentFeesSnap.val() || {};
      try {
        const legacyStudentFeesSnap = await schoolRef(`finance/${targetYear}/studentFees`).once('value');
        const legacyStudentFeesData = legacyStudentFeesSnap.val() || {};
        if (isSocratesSchool) {
          studentFeesData = { ...(legacyStudentFeesData || {}), ...(studentFeesData || {}) };
        } else if (!Object.keys(studentFeesData || {}).length) {
          studentFeesData = legacyStudentFeesData;
        }
      } catch (studentFeesErr) {
        console.warn('Student fee override read failed', studentFeesErr?.message || studentFeesErr);
      }
      const stOverridesRaw = stOverridesSnap.val() || {};
      const studentPlansRaw = studentPlansSnap.val() || {};
      const mergedOverrides = { ...stOverridesRaw };
      Object.keys(studentPlansRaw || {}).forEach((sid) => {
        const sp = studentPlansRaw[sid];
        if (sp && (sp.planId || sp.id)) {
          mergedOverrides[sid] = { ...(mergedOverrides[sid] || {}), planId: sp.planId || sp.id };
        }
      });
      const legacyPlans = plansSnap.val() || {};
      const financePlansRaw = financePlansSnap.val() || {};
      const mergedPlans = { ...legacyPlans, ...(financePlansRaw || {}) };
      const approvalsByStudent = await loadApprovedFinanceApprovals(targetYear, true);
      cachedStudents = buildFinanceStudents(
        baseStudents,
        anchorEnrollments,
        yearEnrollments,
        classFeesSnap.val() || {},
        mergedOverrides,
        mergedPlans,
        ledgerData,
        carrySnap.val() || {},
        studentFeesData,
        approvalsByStudent,
        targetYear
      );
      decorateStudentsWithDeadlineExtensions(cachedStudents, deadlineExtensionsSnap.val() || {});
      armDeadlineExtensionWatcher(targetYear);

      // ===== Parent mode: filter to single learner =====
      if (parentCtx.enabled) {
        let targetId = parentCtx.studentId;
        if (!targetId && parentCtx.adm) {
          targetId = Object.keys(cachedStudents||{}).find(k =>
            String(cachedStudents[k]?.admissionNumber||'') === String(parentCtx.adm)
          );
        }
        if (!targetId || !cachedStudents[targetId]) {
          // Clear table and show a friendly message; do not leak other records
          const tbodyEl = document.querySelector('#financeTable tbody');
          if (tbodyEl) tbodyEl.innerHTML =
            `<tr><td colspan="10" class="p-4 text-center text-sm text-slate-600">
              No finance record found for this learner.
            </td></tr>`;
          // Also lock KPIs to 0
          ['totalDue','totalCollected','totalOutstanding'].forEach(id=>{
            const el = document.getElementById(id);
            if (el){ el.textContent = '0'; el.dataset.amount = '0'; }
          });
          const countEl = document.getElementById('financeStudentCount');
          if (countEl) countEl.textContent = '0';
          // Stop further rendering in parent scope
          populateStudentSelect();
          applyParentModeUI();
          return;
        }
        // Reduce dataset to the single learner
        cachedStudents = { [targetId]: cachedStudents[targetId] };
      }

      populateStudentSelect();
      renderTable();
      if (parentCtx.enabled) {
        applyParentModeUI();
      }
    } catch (err) {
      console.error('Error loading students:', err);
      alert('Error loading students: ' + err.message);
    }
  }

  document.getElementById("downloadExpenseCsv").addEventListener("click", () => {
    const rows = [["Category", "Description", "Amount", "Date"]];
    document.querySelectorAll("#expenseTable tbody tr").forEach(tr => {
      const cells = [...tr.querySelectorAll("td")].map(td => td.innerText);
      rows.push(cells);
    });
    const ws = XLSX.utils.aoa_to_sheet(rows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Expenses");
    XLSX.writeFile(wb, "expenses_report.xlsx");
  });

  document.getElementById("downloadExpensePdf").addEventListener("click", () => {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    doc.text("Expense Report", 14, 10);
    const rows = [];
    document.querySelectorAll("#expenseTable tbody tr").forEach(tr => {
      const cells = [...tr.querySelectorAll("td")].map(td => td.innerText);
      rows.push(cells);
    });
    doc.autoTable({ head: [["Category", "Description", "Amount", "Date"]], body: rows, startY: 20 });
    doc.save("expenses_report.pdf");
  });

  closePaymentModal.addEventListener('click', closePaymentModalFn);
  cancelPayment.addEventListener('click', closePaymentModalFn);
  closeDetailsModal.addEventListener('click', closeDetailsModalFn);
  showOnlyDebtorsBtn.addEventListener('click', () => {
    showingDebtorsOnly = !showingDebtorsOnly;
    showOnlyDebtorsBtn.textContent = showingDebtorsOnly ? 'Showing Debtors' : 'Show Debtors';
    renderTable();
  });
  downloadCsvBtn.addEventListener('click', downloadCSV_Main);
  downloadPdfBtn.addEventListener('click', downloadPDF_Main);
  downloadDebtNowCsvBtn.addEventListener('click', downloadCSV_DebtNow);
  downloadDebtNowPdfBtn.addEventListener('click', downloadPDF_DebtNow);
  downloadBreakdownCsvBtn.addEventListener('click', downloadCSV_Breakdown);
  downloadBreakdownPdfBtn.addEventListener('click', downloadPDF_Breakdown);
  reloadBtn.addEventListener('click', async () => { await refreshFinanceData(financeYear); });

  if (yearContext) {
    yearContext.onYearChanged((year) => {
      const normalized = String(year);
      if (normalized === financeYear) return;
      financeYear = normalized;
      activeYear = normalized;
      try { sessionStorage.setItem('somap_selected_year', normalized); } catch (_) {}
      if (yearSelectEl && yearSelectEl.value !== normalized) {
        yearSelectEl.value = normalized;
      }
      refreshFinanceData(normalized);
    });
  }
  window.addEventListener('click', ev => {
    if (ev.target === paymentModal) closePaymentModalFn();
    if (ev.target === detailsModal) closeDetailsModalFn();
  });
  classFilter.addEventListener('change', renderTable);
  document.addEventListener('DOMContentLoaded', () => {
    updateYearHint();
    refreshFinanceData(activeYear);
  });
})();
</script>

<script>
/** SoMAp v2.1 — Carry-Forward Debts (2025→)
 *  Non-invasive decorator for finance.html
 *  - Adds previous-year (>=2025) unpaid balance to current year's Fee (year)
 *  - Exposes data-carry-forward for payment.html (iframe) to pick for January
 */
(function carryForwardPatch() {
  const START_YEAR = 2025;
  const sharedCache = window.__financeCarryForwardVisual || (window.__financeCarryForwardVisual = {});
  let scheduled = false;
  let running = false;

  function detectTargetYear() {
    if (window.currentAcademicYear && Number(window.currentAcademicYear)) return Number(window.currentAcademicYear);
    if (window.somapYearContext?.getSelectedYear) {
      const ctxYear = Number(window.somapYearContext.getSelectedYear());
      if (!Number.isNaN(ctxYear)) return ctxYear;
    }
    const sel = document.querySelector('#yearSelect, select[name="year"], [data-somap-year-select]');
    if (sel) {
      const v = Number(sel.value || sel.textContent);
      if (!Number.isNaN(v)) return v;
    }
    const maybe = (document.title || '').match(/\b(20\d{2})\b/);
    if (maybe) return Number(maybe[1]);
    return new Date().getFullYear();
  }

  async function getPrevYearBalance(adm, prevYear) {
    if (!adm) return 0;
    if (typeof window.__finance_getBalanceForYearAdmission === 'function') {
      return Number(await window.__finance_getBalanceForYearAdmission(prevYear, adm)) || 0;
    }
    if (window.firebase?.database) {
      try {
        const ref = window.firebase.database().ref(`finance/${prevYear}/students/${adm}`);
        const snap = await ref.get();
        if (snap.exists()) {
          const d = snap.val();
          if (d.balance !== undefined) return Number(d.balance) || 0;
          const feeYear = Number(String(d.feeYear || d.fee || 0).replace(/[^\d]/g, '')) || 0;
          const paid = Number(String(d.paid || 0).replace(/[^\d]/g, '')) || 0;
          return Math.max(feeYear - paid, 0);
        }
      } catch (err) {
        console.warn('CarryForward fallback fetch failed', adm, prevYear, err);
      }
    }
    return 0;
  }

  function parseNumberLike(x) {
    if (typeof x === 'number') return x;
    return Number(String(x || '0').replace(/[^\d]/g, '')) || 0;
  }

  function formatTSh(n) {
    const value = Number(n) || 0;
    try {
      return new Intl.NumberFormat('en-KE', {
        style: 'currency',
        currency: 'TZS',
        maximumFractionDigits: 0,
      }).format(value);
    } catch (err) {
      return 'TSh ' + value.toLocaleString('en-US');
    }
  }

  function formatNumber(n) {
    return (Number(n) || 0).toLocaleString('en-US');
  }

  function adjustKpis(delta) {
    if (!delta) return;
    const targets = ['totalDue', 'totalOutstanding'];
    targets.forEach((id) => {
      const el = document.getElementById(id);
      if (!el) return;
      const current = parseNumberLike(el.dataset.amount || el.textContent);
      const next = current + delta;
      el.dataset.amount = String(next);
      el.textContent = formatNumber(next);
    });
  }

  function findFinanceTableRows() {
    const table = document.getElementById('financeTable');
    if (!table) return [];
    const rows = Array.from(table.querySelectorAll('tbody tr')).filter(tr => tr.children.length >= 10);
    return rows.map(tr => {
      const tds = Array.from(tr.children);
      const adm = (tds[1]?.innerText || '').trim();
      const feeYearCell = tds[4] || null;
      const feeYear = parseNumberLike(tds[4]?.innerText);
      return { tr, tds, adm, feeYearCell, feeYear };
    }).filter(entry => entry.adm);
  }

  async function decorateWithCarryForward() {
    if (running) {
      scheduled = true;
      return;
    }
    running = true;
    const targetYear = detectTargetYear();
    const prevYear = targetYear - 1;
    if (!Number.isFinite(prevYear) || prevYear < START_YEAR) {
      running = false;
      return;
    }
    const rows = findFinanceTableRows();
    if (!rows.length) {
      running = false;
      return;
    }
    const uniqueAdms = [...new Set(rows.map(r => r.adm))];
    const cfMap = new Map();
    if (typeof window.__finance_getBalanceForYearAdmission === 'function') {
      await Promise.all(uniqueAdms.map(async (adm) => {
        const carry = await window.__finance_getBalanceForYearAdmission(prevYear, adm);
        cfMap.set(adm, Math.max(0, Number(carry) || 0));
      }));
    } else if (window.firebase?.database && uniqueAdms.length > 2) {
      try {
        const baseRef = window.firebase.database().ref(`finance/${prevYear}/students`);
        const snap = await baseRef.once('value');
        const students = snap.val() || {};
        uniqueAdms.forEach((adm) => {
          let carry = 0;
          const lookup = typeof window.__finance_lookupStudent === 'function' ? window.__finance_lookupStudent(adm) : null;
          const id = lookup?.id || adm;
          const d = students[id] || students[adm];
          if (d) {
            if (d.balance !== undefined) carry = Number(d.balance) || 0;
            else {
              const feeYear = Number(String(d.feeYear || d.fee || 0).replace(/[^\d]/g, '')) || 0;
              const paid = Number(String(d.paid || 0).replace(/[^\d]/g, '')) || 0;
              carry = Math.max(feeYear - paid, 0);
            }
          }
          cfMap.set(adm, Math.max(0, carry));
        });
      } catch (err) {
        await Promise.all(uniqueAdms.map(async (adm) => {
          const carry = await getPrevYearBalance(adm, prevYear);
          cfMap.set(adm, Math.max(0, Number(carry) || 0));
        }));
      }
    } else {
      await Promise.all(uniqueAdms.map(async (adm) => {
        const carry = await getPrevYearBalance(adm, prevYear);
        cfMap.set(adm, Math.max(0, Number(carry) || 0));
      }));
    }

    rows.forEach(row => {
      const carry = cfMap.get(row.adm) || 0;
      const hasCF = carry > 0;
      row.tr.dataset.carryForward = hasCF ? String(carry) : '0';
      row.tr.dataset.carryForwardYear = String(prevYear);
      const storeKey = `${targetYear}::${row.adm}`;
      const lookup = typeof window.__finance_lookupStudent === 'function'
        ? window.__finance_lookupStudent(row.adm)
        : null;
      const student = lookup?.student || null;

      let originalDisplayedDue = row.feeYear;
      let newTotalDue = originalDisplayedDue;
      let appliedCarry = 0;

      if (student) {
        const existingCarry = Math.max(0, Number(student.carryAmount || 0));
        const currentFeePerYear = Math.max(0, Number(student.feePerYear || 0));
        const inferredBase = Math.max(0, Number(
          student.baseFee ??
          (currentFeePerYear > existingCarry ? currentFeePerYear - existingCarry : 0)
        ));

        student.__carryOverlayAmount = carry;
        student.__carryOverlayPrevYear = prevYear;
        student.__carryOverlayYear = targetYear;

        appliedCarry = Math.max(0, carry - existingCarry);
        if (appliedCarry > 0) {
          student.baseFee = inferredBase;
          student.carryAmount = existingCarry + appliedCarry;
          student.feePerYear = Math.max(0, currentFeePerYear || inferredBase + existingCarry) + appliedCarry;
          student.__carryOverlayMerged = true;
        }

        newTotalDue = Math.max(0, Number(student.feePerYear || inferredBase + existingCarry + appliedCarry));
      } else if (hasCF) {
        appliedCarry = carry;
        newTotalDue = row.feeYear + appliedCarry;
      }

      if (hasCF) {
        sharedCache[storeKey] = { carry, prevYear, total: newTotalDue };
        try {
          sessionStorage.setItem(`somap_cf_${targetYear}_${row.adm}`, String(carry));
        } catch (_) {}
      } else {
        delete sharedCache[storeKey];
        try {
          sessionStorage.removeItem(`somap_cf_${targetYear}_${row.adm}`);
        } catch (_) {}
      }

      row.tr.dataset.carryForwardTotal = String(newTotalDue);

      const delta = Math.max(0, newTotalDue - originalDisplayedDue);
      if (delta > 0) {
        adjustKpis(delta);
      }

      if (row.feeYearCell) {
        if (row.feeYearCell.firstChild && row.feeYearCell.firstChild.nodeType === Node.TEXT_NODE) {
          row.feeYearCell.firstChild.textContent = formatNumber(newTotalDue);
        } else {
          row.feeYearCell.textContent = formatNumber(newTotalDue);
        }
        row.feeYearCell.querySelectorAll('[data-cf-badge]').forEach(el => el.remove());
      }

      if (hasCF && row.feeYearCell) {
        const badge = document.createElement('div');
        badge.dataset.cfBadge = 'badge';
        badge.className = 'text-xs mt-1';
        badge.innerHTML = `<span class="px-2 py-0.5 rounded bg-yellow-100 text-yellow-700">Carry Forward (${prevYear}): ${formatTSh(carry)}</span>`;
        const totalLine = document.createElement('div');
        totalLine.dataset.cfBadge = 'total';
        totalLine.className = 'text-sm font-semibold mt-1';
        totalLine.textContent = `Total Due (incl. CF): ${formatTSh(newTotalDue)}`;
        row.feeYearCell.appendChild(badge);
        row.feeYearCell.appendChild(totalLine);
      }

      const paidCell = row.tds[6];
      const balanceCell = row.tds[7];
      const debtCell = row.tds[8];
      const paidAmount = parseNumberLike(paidCell?.innerText || '0');
      const newBalance = Math.max(0, newTotalDue - paidAmount);
      if (balanceCell) {
        balanceCell.textContent = formatNumber(newBalance);
      }

      if (student && debtCell && typeof window.__finance_computeStudentFinancials === 'function') {
        const finNow = window.__finance_computeStudentFinancials(student);
        const debtIsOverdue = Boolean(finNow.isOverdueDebt && finNow.periodDebtValue > 0);
        const debtIsCarry = Boolean(finNow.hasCarryOutstanding && finNow.periodDebtValue > 0);
        const debtNeedsAction = debtIsOverdue || debtIsCarry;
        const debtLabel = (debtIsOverdue || debtIsCarry)
          ? `Overdue till ${finNow.periodDebtLabel}`
          : '-';
        const windowLine = (debtIsOverdue || debtIsCarry) && finNow.overdueWindowLabel && finNow.overdueWindowLabel !== '-'
          ? `<div class="text-xs text-red-700">${finNow.overdueWindowLabel}</div>`
          : '';
        debtCell.innerHTML = `
          <div class="flex items-center justify-between gap-2">
            <span>${debtLabel}${windowLine}</span>
            <span class="font-semibold ${debtNeedsAction ? 'text-red-700' : ''}">${formatNumber(finNow.periodDebtValue || 0)}</span>
          </div>
        `;
        row.tr.classList.toggle('table-row-overdue', debtNeedsAction);
      }

      row.feeYear = newTotalDue;
    });
    running = false;
    if (scheduled) {
      scheduled = false;
      decorateWithCarryForward();
    }
  }

  function queueRun() {
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(decorateWithCarryForward, 0);
    } else {
      document.addEventListener('DOMContentLoaded', () => setTimeout(decorateWithCarryForward, 0), { once: true });
    }
  }

  document.addEventListener('finance:tableRendered', () => setTimeout(decorateWithCarryForward, 0));
  queueRun();
})();
</script>
</body>
</html>
