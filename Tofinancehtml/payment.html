<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Installment Breakdown</title>

  <!-- Firebase (v9 compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
  <script src="../shared/finance_math.js"></script>
  <script src="../js/finance_core.js"></script>
  <script src="../somapappv1multischool/js/yearContext.js"></script>
  <script src="../somapappv1multischool/js/context.js"></script>

  <!-- Tailwind for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>

  <style>
    .status-pill { padding:2px 8px; border-radius:999px; font-size: 11px; font-weight:600; }
    .status-cleared { background:#dcfce7; color:#166534; }
    .status-partial { background:#fef9c3; color:#854d0e; }
    .status-overdue { background:#fee2e2; color:#991b1b; }
    .table-header { background:#eef2ff; color:#1f2937; }
  </style>
</head>
<body class="bg-white">
  <div id="breakdownContent" class="text-sm p-4">
    <!-- skeleton loader -->
    <div id="skel" class="animate-pulse">
      <div class="h-4 bg-slate-200 rounded w-2/3 mb-3"></div>
      <div class="h-3 bg-slate-200 rounded w-full mb-2"></div>
      <div class="h-3 bg-slate-200 rounded w-5/6"></div>
    </div>
  </div>

  <script type="module">
    import { resolveEffectiveFinance, resolveEffectiveInstallments, getPlan } from '../js/financeplans.js';
    (function () {
      const SOMAP_DEFAULT_YEAR = 2025;
      const CLASS_ORDER = ['Baby Class','Middle Class','Pre Unit Class','Class 1','Class 2','Class 3','Class 4','Class 5','Class 6','Class 7'];
      const norm = (s) => String(s || '').trim().toLowerCase();
      function shiftClass(baseName, deltaYears) {
        const i = CLASS_ORDER.findIndex((c) => norm(c) === norm(baseName));
        if (i < 0) return baseName || '';
        const j = i + Number(deltaYears || 0);
        if (j < 0) return 'PRE-ADMISSION';
        if (j >= CLASS_ORDER.length) return 'GRADUATED';
        return CLASS_ORDER[j];
      }

      // ---- Parent scope detection ----
      const q = new URL(location.href).searchParams;
      const isParentScope = (q.get('scope')||'').toLowerCase() === 'parent';
      const contextYearNum = Number(window.somapYearContext?.getSelectedYear?.());
      const targetYearNum = Number(q.get('year') || (Number.isFinite(contextYearNum) ? contextYearNum : SOMAP_DEFAULT_YEAR));
      const targetYear = Number.isFinite(targetYearNum) ? targetYearNum : SOMAP_DEFAULT_YEAR;
      const targetYearStr = String(targetYear);
      const anchorYear = Number.isFinite(targetYear) ? Math.max(SOMAP_DEFAULT_YEAR, targetYear - 1) : SOMAP_DEFAULT_YEAR;
      const anchorYearStr = String(anchorYear);
      const CARRY_FORWARD_START_YEAR = 2025;

      const carryForwardCache = new Map();
      async function fetchPrevYearCarry(admRaw) {
        const normalized = String(admRaw || '').trim();
        if (!normalized) return 0;
        const cacheKey = `${targetYearStr}::${normalized}`;
        if (carryForwardCache.has(cacheKey)) return carryForwardCache.get(cacheKey);
        const prevYear = targetYear - 1;
        if (!Number.isFinite(prevYear) || prevYear < CARRY_FORWARD_START_YEAR) {
          carryForwardCache.set(cacheKey, 0);
          return 0;
        }
        let amount = 0;
        try {
          const shared = window.parent && window.parent.__financeCarryForwardVisual
            ? window.parent.__financeCarryForwardVisual[cacheKey]
            : null;
          if (shared && shared.carry) amount = Number(shared.carry) || 0;
        } catch (_) {}
        if (!amount) {
          try {
            const stored = sessionStorage.getItem(`somap_cf_${targetYearStr}_${normalized}`);
            if (stored) amount = Number(stored) || 0;
          } catch (_) {}
        }
        if (!amount && window.parent && typeof window.parent.__finance_getBalanceForYearAdmission === 'function') {
          try {
            const val = await window.parent.__finance_getBalanceForYearAdmission(prevYear, normalized);
            amount = Number(val) || 0;
          } catch (_) {}
        }
        if (!amount && typeof window.__finance_getBalanceForYearAdmission === 'function') {
          try {
            const val = await window.__finance_getBalanceForYearAdmission(prevYear, normalized);
            amount = Number(val) || 0;
          } catch (_) {}
        }
        if (!amount && window.firebase?.database) {
          try {
            const snap = await window.firebase.database().ref(`finance/${prevYear}/students/${normalized}`).get();
            if (snap.exists()) {
              const data = snap.val() || {};
              if (data.balance !== undefined) amount = Number(data.balance) || 0;
              else {
                const feeYear = Number(String(data.feeYear || data.fee || 0).replace(/[^\d]/g, '')) || 0;
                const paid = Number(String(data.paid || 0).replace(/[^\d]/g, '')) || 0;
                amount = Math.max(0, feeYear - paid);
              }
            }
          } catch (err) {
            console.warn('Carry-forward fetch fallback failed', normalized, prevYear, err);
          }
        }
        amount = Math.max(0, Number(amount) || 0);
        carryForwardCache.set(cacheKey, amount);
        return amount;
      }

      window.__somap_fetchCarryForward = async function(year, adm) {
        const y = Number(year);
        if (Number.isFinite(y) && y === targetYear) {
          return fetchPrevYearCarry(adm);
        }
        if (window.parent && typeof window.parent.__somap_fetchCarryForward === 'function') {
          return window.parent.__somap_fetchCarryForward(year, adm);
        }
        return 0;
      };

      // ---- Firebase init (inline, so the iframe never depends on ../firebase.js) ----
      const firebaseConfig = {
        apiKey: "AIzaSyBhONntRE_aRsU0y1YcPZzWud3CBfwH_a8",
        authDomain: "somaptestt.firebaseapp.com",
        databaseURL: "https://somaptestt-default-rtdb.firebaseio.com",
        projectId: "somaptestt",
        storageBucket: "somaptestt.appspot.com",
        messagingSenderId: "105526245138",
        appId: "1:105526245138:web:b8e7c0cb82a46e861965cb",
        measurementId: "G-4HKX7KN6Q3"
      };
      try { if (!firebase?.apps?.length) firebase.initializeApp(firebaseConfig); }
      catch (e) { console.error('Firebase init error', e); }
      const db = (() => { try { return firebase.database(); } catch { return null; }})();
      const P = (subPath) => (window.SOMAP && typeof SOMAP.P === 'function') ? SOMAP.P(subPath) : subPath;
      const ref = (subPath) => db.ref(P(subPath));
      const financeCore = window.SOMAP_FINANCE || {};

      const mount = (html) => {
        const el = document.getElementById('breakdownContent');
        el.innerHTML = html;
        // ask parent to resize this iframe
        const h = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        try { window.parent.postMessage({ type:'resizeIframe', id: window.__STUDENT_ID__, height: h }, '*'); } catch {}
      };
      const err = (msg) => mount(`<div class="p-3 rounded bg-rose-50 text-rose-700 border border-rose-200">${msg}</div>`);

      if (!db) { err('Error: Database not initialized. Please check Firebase credentials or internet connection.'); return; }

      // ---- helpers ----
      const fmt = (n) => (Number(n) || 0).toLocaleString();
      const nowTS = () => Date.now();
      function ymdToTS(academicYear, m, d, endOfDay = false) {
        const y = (m === 12) ? (Number(academicYear) - 1) : Number(academicYear);
        return endOfDay
          ? new Date(y, m - 1, d, 23, 59, 59, 999).getTime()
          : new Date(y, m - 1, d, 0, 0, 0, 0).getTime();
      }
      function apportion(total, weights) {
        if (!Array.isArray(weights) || !weights.length) return [];
        const sumW = weights.reduce((a, b) => a + b, 0);
        let amounts = weights.map(w => Math.floor((w * total) / sumW));
        let sumA = amounts.reduce((a, b) => a + b, 0);
        let rem = total - sumA;
        if (rem > 0) {
          const sortedIdx = [...weights.keys()].sort((a, b) => weights[b] - weights[a]);
          for (let i = 0; i < rem; i++) amounts[sortedIdx[i % sortedIdx.length]]++;
        }
        return amounts;
      }

      function coercePaymentMap(raw) {
        if (!raw) return {};
        if (Array.isArray(raw)) {
          return raw.reduce((acc, entry, idx) => {
            if (entry != null) acc[`idx-${idx}`] = entry;
            return acc;
          }, {});
        }
        if (typeof raw === 'object') return { ...raw };
        return {};
      }

      function extractPaymentsMap(raw, targetYear) {
        if (!raw || typeof raw !== 'object') return {};
        const yearKey = String(targetYear);
        const numericYear = Number(targetYear);

        if (raw.payments || raw.entries || raw.records) {
          return coercePaymentMap(raw.payments || raw.entries || raw.records);
        }

        const possibleBucket =
          raw[yearKey] ??
          raw[String(numericYear)] ??
          raw[numericYear];
        if (possibleBucket && typeof possibleBucket === 'object') {
          if (possibleBucket.payments || possibleBucket.entries || possibleBucket.records) {
            return coercePaymentMap(possibleBucket.payments || possibleBucket.entries || possibleBucket.records);
          }
          return coercePaymentMap(possibleBucket);
        }

        return coercePaymentMap(raw);
      }

      function normalizeLedgerPayments(source, targetYear) {
        const normalized = {};
        if (!source) return normalized;
        const desiredYear = Number(targetYear);
        Object.entries(source).forEach(([key, raw]) => {
          if (!raw) return;
          const amount = Number(raw.amount ?? raw.value ?? raw.paid ?? raw.payment ?? raw.total ?? 0);
          if (!Number.isFinite(amount) || amount <= 0) return;
          const timestamp = Number(
            raw.timestamp ?? raw.datePaid ?? raw.createdAt ?? raw.recordedAt ?? raw.updatedAt ?? raw.time ?? Date.now()
          );
          let paymentYear = Number(
            raw.academicYear ??
            raw.financeYear ??
            raw.feeYear ??
            raw.year ??
            raw._year ??
            raw.academic_session
          );
          if (!Number.isFinite(paymentYear) && Number.isFinite(timestamp)) {
            const ts = new Date(timestamp);
            if (!Number.isNaN(ts.getTime())) paymentYear = ts.getFullYear();
          }
          if (Number.isFinite(desiredYear) && Number.isFinite(paymentYear) && paymentYear !== desiredYear) return;
          const payload = { ...raw, amount: Math.round(Math.max(0, amount)), timestamp };
          if (Number.isFinite(paymentYear)) payload.academicYear = paymentYear;
          else if (Number.isFinite(desiredYear)) payload.academicYear = desiredYear;
          normalized[key] = payload;
        });
        return normalized;
      }

      async function loadApprovedSummary(studentKey, year) {
        // 1) Prefer the finance page's live summary if we're in an iframe with the parent loaded.
        try {
          if (window.parent && typeof window.parent.__finance_getStudentFinanceSummary === 'function') {
            const live = await window.parent.__finance_getStudentFinanceSummary(year, studentKey);
            if (live) {
              return {
                feeTotal: live.due,
                paidTotal: live.paid,
                balanceTotal: live.balance,
                baseFee: live.baseFee,
                carry: live.carry,
                credit: live.credit,
              };
            }
          }
        } catch (err) {
          console.warn('installment breakdown: parent summary lookup failed', err?.message || err);
        }

        // 2) Otherwise, use the shared helper (may fall back to ledger math).
        if (!financeCore || typeof financeCore.loadStudentYearSummary !== 'function') return null;
        try {
          return await financeCore.loadStudentYearSummary(studentKey, year);
        } catch (err) {
          console.warn('installment breakdown: summary load failed', err?.message || err);
          return null;
        }
      }

      function buildBreakdownFromSummary(scheduleItems, feeForYear, paidTotal) {
        const items = Array.isArray(scheduleItems) ? scheduleItems : [];
        const paid = Math.max(0, Number(paidTotal) || 0);
        const fee = Math.max(0, Number(feeForYear) || 0);
        let remainingPaid = paid;
        const now = nowTS();

        const rows = items.map((it) => {
          const expected = Math.max(0, Number(it.amount) || 0);
          const allocate = Math.min(expected, remainingPaid);
          remainingPaid -= allocate;

          let status = 'Pending';
          if (allocate >= expected) status = 'Cleared';
          else if (now > it.toTS) status = allocate > 0 ? 'Partially Paid (Overdue)' : 'Overdue';
          else if (allocate > 0) status = 'Partially Paid';

          return {
            label: it.label,
            expected,
            allocated: allocate,
            remaining: Math.max(0, expected - allocate),
            status,
            fromTS: it.fromTS,
            toTS: it.toTS,
          };
        });

        const allocatedTotalRaw = rows.reduce((s, r) => s + r.allocated, 0);
        const usedForFee = Math.min(allocatedTotalRaw, fee);
        const expectedToDate = rows
          .filter((r) => Number(r.toTS || 0) > 0 && Number(r.toTS || 0) < now)
          .reduce((s, r) => s + r.expected, 0);
        const paidConsumedToDate = Math.min(expectedToDate, allocatedTotalRaw);
        const debtTillNow = Math.max(0, expectedToDate - paidConsumedToDate);
        const remainingForYear = Math.max(0, fee - usedForFee);
        const credit = Math.max(0, paid - fee);

        return {
          rows,
          allocated: usedForFee,
          paidTotal: paid,
          remainingForYear,
          credit,
          debtTillNow,
        };
      }

      // ---- installment configs (DISCOUNTS REMOVED) ----
      const installmentConfigs = {
        lower: {
          type: '6', weights: [44, 13, 12, 22, 22, 16],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4','Inst 5','Inst 6'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] },
            { from:[5,1], to:[5,15] }, { from:[7,1], to:[7,15] }, { from:[9,1], to:[9,15] },
          ]
        },
        class4_7: {
          type: '4', weights: [328, 180, 176, 132],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] }, { from:[5,1], to:[5,15] }
          ]
        },
        class5: {
          type: '6', weights: [44, 23, 22, 32, 26, 17],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4','Inst 5','Inst 6'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] },
            { from:[5,1], to:[5,15] }, { from:[7,1], to:[7,15] }, { from:[9,1], to:[9,15] },
          ]
        },
        class6: {
          type: '6', weights: [236, 115, 110, 160, 160, 100],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4','Inst 5','Inst 6'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] },
            { from:[5,1], to:[5,15] }, { from:[7,1], to:[7,15] }, { from:[9,1], to:[9,15] },
          ]
        },
        monthly: {
          type: 'monthly',
          weights: [2,1,1,1,1,1,2,1,1,1],
          labels: ['Jan (2 months)','Feb','Mar','Apr','May','Jun','Jul (2 months)','Aug','Sep','Oct'],
          windows: [
            { from:[1,1], to:[1,31] }, { from:[2,1], to:[2,28] }, { from:[3,1], to:[3,31] }, { from:[4,1], to:[4,30] },
            { from:[5,1], to:[5,31] }, { from:[6,1], to:[6,30] }, { from:[7,1], to:[7,31] },
            { from:[8,1], to:[8,31] }, { from:[9,1], to:[9,30] }, { from:[10,1], to:[10,31] },
          ]
        },
        '2inst': {
          type: '2',
          weights: [1,1], labels: ['1st Half','2nd Half'],
          windows: [ { from:[1,1], to:[1,10] }, { from:[7,1], to:[7,5] } ]
        },
        full: {
          type: 'full',
          weights: [1], labels: ['Full Year'],
          windows: [ { from:[1,1], to:[1,10] } ]
        }
      };

      function getConfig(student) {
        const plan = String(student.paymentPlan || '').toLowerCase();
        const c = String(student.classLevel || '').toLowerCase();
        if (plan.includes('monthly')) return installmentConfigs.monthly;
        if (plan.includes('2')) return installmentConfigs['2inst'];
        if (plan.includes('full') || plan.includes('year')) return installmentConfigs.full;
        if (plan.includes('inst')) {
          if (c === 'class 1' || c === 'class 2' || c === 'class 3') return installmentConfigs.lower;
          if (c === 'class 5') return installmentConfigs.class5;
          if (c === 'class 6') return installmentConfigs.class6;
          if (c === 'class 4' || c === 'class 7') return installmentConfigs.class4_7;
        }
        return installmentConfigs.lower;
      }

      function buildLegacySchedule(student) {
        if (!student || student.isGraduated) {
          return { items: [], academicYear: targetYear, feeBase: 0, planName: student?.paymentPlan || '' };
        }
        const config = getConfig(student);
        const feeBase = Math.max(0, Math.round(Number(student.baseFee ?? (student.feePerYear - (student.carryAmount || 0))) || 0));
        const carryAmount = Math.max(0, Number(student.carryAmount || 0));
        const weights = Array.isArray(config?.weights) ? config.weights : [];
        const labels = Array.isArray(config?.labels) ? config.labels : [];
        const windows = Array.isArray(config?.windows) ? config.windows : [];

        const amounts = apportion(feeBase, weights);
        if (carryAmount > 0) {
          if (amounts.length) amounts[0] += carryAmount;
          else amounts.push(carryAmount);
        }

        const items = labels.map((label, idx) => {
          const win = windows[idx] || windows[windows.length - 1] || { from: [1, 1], to: [1, 10] };
          const [fromM, fromD] = win.from;
          const [toM, toD] = win.to;
          return {
            label,
            amount: amounts[idx] || 0,
            fromTS: ymdToTS(targetYear, fromM, fromD, false),
            toTS: ymdToTS(targetYear, toM, toD, true),
            paidAllocated: 0,
            status: 'Pending',
          };
        });
        return { items, academicYear: targetYear, feeBase, planName: student.paymentPlan || '' };
      }

      function fallbackWindow(config, idx) {
        if (!config || !Array.isArray(config.windows) || !config.windows.length) return null;
        return config.windows[idx] || config.windows[config.windows.length - 1];
      }

      function resolveWindowPair(row, key, fallbackPair) {
        if (!row) return fallbackPair || null;
        const monthKey = `${key}Month`;
        const dayKey = `${key}Day`;
        if (row[monthKey] !== undefined && row[dayKey] !== undefined) {
          const m = Number(row[monthKey]);
          const d = Number(row[dayKey]);
          if (Number.isFinite(m) && Number.isFinite(d) && m > 0 && d > 0) return [m, d];
        }
        const direct = row[key] || row[`${key}Date`];
        if (direct) {
          const match = String(direct).match(/(\d{1,2})\D*(\d{1,2})/);
          if (match) {
            const m = Number(match[1]);
            const d = Number(match[2]);
            if (Number.isFinite(m) && Number.isFinite(d) && m > 0 && d > 0) return [m, d];
          }
        }
        if (row.windowText) {
          const segments = String(row.windowText).split('–');
          const idx = key === 'from' ? 0 : 1;
          if (segments[idx]) {
            const match = segments[idx].match(/(\d{1,2})\D*(\d{1,2})/);
            if (match) {
              const m = Number(match[1]);
              const d = Number(match[2]);
              if (Number.isFinite(m) && Number.isFinite(d) && m > 0 && d > 0) return [m, d];
            }
          }
        }
        return fallbackPair || null;
      }

      function toAcademicTS(pair, endOfDay) {
        let [month, day] = Array.isArray(pair) ? pair : [1, 1];
        month = Number(month);
        day = Number(day);
        if (!Number.isFinite(month) || month <= 0 || month > 12) month = 1;
        if (!Number.isFinite(day) || day <= 0 || day > 31) day = endOfDay ? 10 : 1;
        return ymdToTS(targetYear, month, day, endOfDay);
      }

      async function buildSchedule(student, classDefaults, override) {
        if (!student || student.isGraduated) {
          return { items: [], academicYear: targetYear, feeBase: 0, planName: student?.paymentPlan || '' };
        }
        const config = getConfig(student);
        
        // PRIORITY 1: Check for student custom schedule (highest priority override)
        if (override && Array.isArray(override.customSchedule) && override.customSchedule.length > 0) {
          // Student has custom schedule - let resolveEffectiveInstallments handle it
          // Fall through to PRIORITY 2
        }
        
        // PRIORITY 2: Check if class-level edited installments exist (from paymentedits.html)
        // These are stored in feesStructure/{year}/{Class}/installments
        // Only use if student doesn't have a custom schedule or plan override
        const hasStudentOverride = override && (
          (Array.isArray(override.customSchedule) && override.customSchedule.length > 0) ||
          override.planId
        );
        
        if (!hasStudentOverride && classDefaults && classDefaults.installments && typeof classDefaults.installments === 'object') {
          const installmentsObj = classDefaults.installments;
          const entries = Object.values(installmentsObj).filter(inst => inst && inst.active !== false);
          
          if (entries.length > 0) {
            // Sort by window date (from month/day)
            const sorted = entries.slice().sort((a, b) => {
              const af = (a?.window?.from || []);
              const bf = (b?.window?.from || []);
              if (!af.length && !bf.length) return 0;
              if (!af.length) return 1;
              if (!bf.length) return -1;
              if (af[0] !== bf[0]) return af[0] - bf[0];
              return af[1] - bf[1];
            });
            
            const items = sorted.map((inst, idx) => {
              const win = inst?.window || {};
              const fromPair = Array.isArray(win.from) ? win.from : null;
              const toPair = Array.isArray(win.to) ? win.to : null;
              const fallback = fallbackWindow(config, idx) || { from: [1, 1], to: [1, 10] };
              const amount = Math.max(0, Math.round(Number(inst?.amount) || 0));
              const label = inst?.label || (config?.labels?.[idx] || `Inst ${idx + 1}`);
              
              return {
                label,
                amount,
                fromTS: toAcademicTS(fromPair || fallback.from, false),
                toTS: toAcademicTS(toPair || fallback.to, true),
                paidAllocated: 0,
                status: 'Pending',
                weight: Number(inst?.weight || 0),
                windowText: inst?.windowText || ''
              };
            });
            
            // Add carry forward if exists
            const carryAmount = Math.max(0, Number(student.carryAmount || 0));
            if (carryAmount > 0 && items.length) {
              items[0].amount += carryAmount;
            }
            
            const feeBase = Math.max(0, Math.round(Number(classDefaults.feePerYear || student.baseFee || student.feePerYear || 0)));
            
            return {
              items,
              academicYear: targetYear,
              feeBase,
              planName: classDefaults.defaultPlan || classDefaults.defaultPlanId || student.paymentPlan || '',
              planId: classDefaults.defaultPlanId || ''
            };
          }
        }
        
        // PRIORITY 3: Try resolveEffectiveInstallments (handles student overrides, custom schedules, plan overrides)
        let breakdown = null;
        try {
          breakdown = await resolveEffectiveInstallments(
            studentId,
            student.classLevel || student.className || student.class || '',
            { year: targetYearStr }
          );
        } catch (err) {
          console.warn('resolveEffectiveInstallments error', err);
        }
        const rows = Array.isArray(breakdown?.rows) ? breakdown.rows : [];
        if (!rows.length) {
          // PRIORITY 4: Fall back to legacy apportioning
          return buildLegacySchedule(student);
        }

        const items = rows.map((row, idx) => {
          const fallback = fallbackWindow(config, idx) || { from: [1, 1], to: [1, 10] };
          const fromPair = resolveWindowPair(row, 'from', fallback.from);
          const toPair = resolveWindowPair(row, 'to', fallback.to);
          const amount = Math.max(0, Math.round(Number(row.amount) || 0));
          const label = row.label || (config?.labels?.[idx] || `Inst ${idx + 1}`);
          return {
            label,
            amount,
            fromTS: toAcademicTS(fromPair, false),
            toTS: toAcademicTS(toPair, true),
            paidAllocated: 0,
            status: 'Pending',
            weight: Number(row.weight || 0),
            windowText: row.windowText || '',
          };
        });

        const carryAmount = Math.max(0, Number(student.carryAmount || 0));
        if (carryAmount > 0) {
          if (items.length) {
            items[0].amount += carryAmount;
          } else {
            const fallback = fallbackWindow(config, 0) || { from: [1, 1], to: [1, 10] };
            items.push({
              label: 'Carry Forward',
              amount: carryAmount,
              fromTS: toAcademicTS(fallback.from, false),
              toTS: toAcademicTS(fallback.to, true),
              paidAllocated: 0,
              status: 'Pending',
              weight: 0,
              windowText: '',
            });
          }
        }

        return {
          items,
          academicYear: targetYear,
          feeBase: breakdown?.fee ?? 0,
          planName: breakdown?.planName || breakdown?.planId || student.paymentPlan || '',
          planId: breakdown?.planId || '',
        };
      }

      function windowLabelForSort(item){
        const fmt = (ts) => {
          const d = new Date(ts || 0);
          return `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
        };
        return `${fmt(item.fromTS)} - ${fmt(item.toTS)}`;
      }

      function sortScheduleItems(items){
        if (!Array.isArray(items)) return;
        const comparator = window.SomapFinance?.installmentCompare;
        if (typeof comparator === 'function') {
          items.sort((a, b) => comparator(
            { label: a.label, window: windowLabelForSort(a) },
            { label: b.label, window: windowLabelForSort(b) }
          ));
        } else {
          items.sort((a, b) => (a.fromTS || 0) - (b.fromTS || 0));
        }
      }

      function allocatePayments(schedule, student) {
        const payments = Object.values(student.payments || {})
          .map(p => ({
            amount: Math.max(0, Number(p.amount) || 0),
            ts: Number(p.timestamp || p.datePaid || 0),
          }))
          .filter(p => p.amount > 0)
          .sort((a, b) => a.ts - b.ts);
        const totalPaid = payments.reduce((a, b) => a + b.amount, 0);
        let pot = totalPaid;
        for (const it of schedule.items) {
          if (pot <= 0) break;
          const need = Math.max(0, it.amount - it.paidAllocated);
          const use = Math.min(need, pot);
          it.paidAllocated += use;
          pot -= use;
        }
        const credit = Math.max(0, pot);
        const now = nowTS();
        for (const it of schedule.items) {
          const got = it.paidAllocated, need = it.amount;
          if (got >= need) it.status = 'Cleared';
          else if (now > it.toTS) it.status = (got > 0) ? 'Partially Paid (Overdue)' : 'Overdue';
          else it.status = (got > 0) ? 'Partially Paid' : 'Pending';
        }
        const expectedToDate = schedule.items.filter(it => it.toTS < now).reduce((s, it) => s + it.amount, 0);
        const paidConsumed = totalPaid - credit;
        const debtTillNow = Math.max(0, expectedToDate - paidConsumed);
        return { credit, totalPaid, debtTillNow };
      }

      async function render(student, classDefaults, override) {
        const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
        if (student.isGraduated) {
          mount(`
            <div class="mb-2 flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
              <h2 class="font-semibold text-indigo-700">Installment Breakdown - ${fullName} (${student.admissionNumber || ''})</h2>
              <div class="text-xs">
                <span class="mr-3">Plan: <strong>${student.paymentPlan || ''}</strong></span>
                <span class="mr-3">Class: <strong>${student.classLevel || ''}</strong></span>
                <span>Year: <strong>${targetYearStr}</strong></span>
              </div>
            </div>
            <div class="p-4 border border-emerald-200 bg-emerald-50 text-emerald-700 text-sm rounded">
              This learner is marked as GRADUATED for ${targetYearStr}. No installments are scheduled for this year.
            </div>
          `);
          return;
        }

        const schedule = await buildSchedule(student, classDefaults, override);
        schedule.items = Array.isArray(schedule?.items) ? schedule.items : [];
        sortScheduleItems(schedule.items);
        const planDisplay = schedule.planName || student.paymentPlan || '';
        const hasYearData = Boolean(student.hasYearData);
        const admissionForLookup = student.admissionNumber || studentId;
        const prevCarry = hasYearData ? await fetchPrevYearCarry(admissionForLookup) : 0;
        const dbCarry = Math.max(0, Number(student.carryAmount || 0));
        const effectiveCarry = Math.max(dbCarry, prevCarry);
        const inferredBaseFee = student.baseFee != null
          ? Math.max(0, Number(student.baseFee) || 0)
          : Math.max(0, Number(student.feePerYear || 0) - dbCarry);
        const totalDueWithCarry = hasYearData ? inferredBaseFee + effectiveCarry : 0;

        const summary = hasYearData ? await loadApprovedSummary(studentId, targetYearStr) : null;
        const summaryFee = summary
          ? Number(
              summary.feeTotal ??
              summary.fee ??
              summary.totalDue ??
              summary.total ??
              summary.finance?.feePerYear ??
              summary.baseFee ??
              0
            )
          : 0;
        const summaryPaid = summary
          ? Number(
              summary.paidTotal ??
              summary.paid ??
              summary.collected ??
              summary.finance?.paidAmount ??
              0
            )
          : 0;
        const summaryBalanceRaw = summary
          ? Number(
              summary.balanceTotal ??
              summary.balance ??
              summary.outstanding ??
              summary.finance?.balance ??
              (summary.feeTotal != null && summary.paidTotal != null
                ? Number(summary.feeTotal) - Number(summary.paidTotal)
                : NaN) ??
              0
            )
          : NaN;

        const feeForYear = hasYearData
          ? Math.max(0, summaryFee || totalDueWithCarry)
          : 0;

        const breakdown = hasYearData
          ? buildBreakdownFromSummary(schedule.items, feeForYear, summaryPaid)
          : { rows: [], allocated: 0, paidTotal: 0, remainingForYear: 0, credit: 0, debtTillNow: 0 };

        if (summary && breakdown.paidTotal !== summaryPaid) {
          console.warn('[Installment Breakdown] Mismatch between summary and computed totals', {
            summaryPaid,
            breakdownPaid: breakdown.paidTotal,
            studentId,
            year: targetYearStr,
          });
          breakdown.paidTotal = summaryPaid;
        }

        const totalsPaid = hasYearData ? breakdown.allocated : 0;
        const totalPaidAll = hasYearData ? breakdown.paidTotal : 0;
        const remainingWithCarry = hasYearData
          ? (Number.isFinite(summaryBalanceRaw) && summaryBalanceRaw >= 0
              ? Math.max(0, summaryBalanceRaw)
              : breakdown.remainingForYear)
          : 0;
        const debtWithCarry = hasYearData ? breakdown.debtTillNow : 0;
        const creditValue = hasYearData ? breakdown.credit : 0;
        const totalFeeDisplay = hasYearData ? (feeForYear || totalDueWithCarry) : 0;

        const prevYearLabel = targetYear - 1;
        const carryParts = [];
        if (prevCarry > 0) carryParts.push(`Prev ${prevYearLabel}: <strong>${fmt(prevCarry)}</strong>`);
        if (dbCarry > 0 && dbCarry !== prevCarry) carryParts.push(`Ledger: <strong>${fmt(dbCarry)}</strong>`);
        const carryTag = carryParts.length
          ? `<span class="mr-3">Carry Forward (${prevYearLabel}+): ${carryParts.join(' + ')}</span>`
          : '';

        const rows = hasYearData && breakdown.rows.length
          ? breakdown.rows.map(r => {
              const win = (r.fromTS && r.toTS)
                ? `${new Date(r.fromTS).toLocaleDateString()} - ${new Date(r.toTS).toLocaleDateString()}`
                : '';
              const statusClass = r.status === 'Cleared'
                ? 'status-cleared'
                : (String(r.status || '').includes('Overdue') ? 'status-overdue' : 'status-partial');
              return `
                <tr>
                  <td class="p-1 border text-center">${r.label}</td>
                  <td class="p-1 border text-right">${fmt(r.expected)}</td>
                  <td class="p-1 border text-right">${fmt(r.allocated)}</td>
                  <td class="p-1 border text-right">${fmt(r.remaining)}</td>
                  <td class="p-1 border text-center"><span class="status-pill ${statusClass}">${r.status}</span></td>
                  <td class="p-1 border text-center">${win}</td>
                </tr>`;
            }).join('')
          : '';

        const tableSection = hasYearData && breakdown.rows.length
          ? `
            <div class="overflow-auto border rounded">
              <table class="min-w-full text-xs">
                <thead>
                  <tr class="table-header">
                    <th class="p-1 border">Period</th>
                    <th class="p-1 border">Expected</th>
                    <th class="p-1 border">Allocated Paid</th>
                    <th class="p-1 border">Remaining</th>
                    <th class="p-1 border">Status</th>
                    <th class="p-1 border">Window</th>
                  </tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>
            </div>`
          : `
            <div class="p-4 border border-dashed border-slate-200 rounded text-xs text-slate-500">
              No installment schedule for ${targetYearStr} yet.
            </div>`;

        const infoNote = !hasYearData
          ? `<div class="mb-3 text-xs text-slate-500 bg-slate-50 border border-slate-200 rounded p-3">
              No finance data has been recorded for ${targetYearStr}. Once this year's fee structure or payments are captured, the breakdown will appear here.
            </div>`
          : '';

        mount(`
          <div class="mb-2 flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
            <h2 class="font-semibold text-indigo-700">Installment Breakdown - ${fullName} (${student.admissionNumber || ''})</h2>
            <div class="text-xs">
              <span class="mr-3">Plan: <strong>${planDisplay}</strong></span>
              <span class="mr-3">Class: <strong>${student.classLevel || ''}</strong></span>
              <span>Year: <strong>${targetYearStr}</strong></span>
            </div>
          </div>

          <div class="mb-3 flex flex-col gap-2 text-xs md:flex-row md:items-center md:justify-between">
            <div class="flex flex-wrap items-center gap-3">
              <span data-cf-fee-year>
                Fee (incl. carry):
                <strong
                  data-base-fee="${inferredBaseFee}"
                  data-base-value="${inferredBaseFee}"
                  data-initial-carry="${effectiveCarry}"
                >${fmt(totalFeeDisplay)}</strong>
              </span>
              <span data-cf-base-fee>Base: <strong>${fmt(inferredBaseFee)}</strong></span>
              <span data-cf-carry-slot>${carryTag || ''}</span>
            </div>
            <div class="flex flex-wrap items-center gap-3">
              <span data-cf-paid-total>Paid (total): <strong>${fmt(totalPaidAll)}</strong></span>
              <span data-cf-allocated>Allocated: <strong>${fmt(totalsPaid)}</strong></span>
              <span data-cf-remaining>
                Remaining:
                <strong
                  data-base-fee="${inferredBaseFee}"
                  data-base-value="${remainingWithCarry}"
                  data-initial-carry="${effectiveCarry}"
                  data-total-paid="${totalPaidAll}"
                  data-rem-base="${remainingWithCarry}"
                >${fmt(remainingWithCarry)}</strong>
              </span>
              <span data-cf-debt>Debt till now: <strong>${fmt(debtWithCarry)}</strong></span>
              <span data-cf-credit>Credit: <strong>${fmt(creditValue)}</strong></span>
            </div>
          </div>

          ${infoNote}
          ${tableSection}
        `);
      }

      // ---- load student and render ----
      const studentId = new URL(location.href).searchParams.get('student');
      window.__STUDENT_ID__ = studentId;
      if (!studentId) { err('Error: No student ID provided in URL.'); return; }
      Promise.all([
        ref(`students/${studentId}`).once('value'),
        ref(`enrollments/${anchorYearStr}/${studentId}`).once('value'),
        ref(`enrollments/${targetYearStr}/${studentId}`).once('value'),
        ref(`feesStructure/${targetYearStr}`).once('value'),
        ref(`studentOverrides/${targetYearStr}/${studentId}`).once('value'),
        ref(`installmentPlans/${targetYearStr}`).once('value'),
        ref(`financeLedgers/${targetYearStr}/${studentId}/payments`).once('value'),
        ref(`financeCarryForward/${targetYearStr}/${studentId}`).once('value'),
      ])
        .then(async ([studentSnap, anchorSnap, enrollmentSnap, classFeesSnap, overrideSnap, plansSnap, ledgerSnap, carrySnap]) => {
          const baseStudent = studentSnap.val();
          if (!baseStudent) { err('Student not found.'); return; }

          const anchor = anchorSnap.val() || {};
          const enrollment = enrollmentSnap.val() || {};
          const classFees = classFeesSnap.val() || {};
          const override = overrideSnap.val() || {};
          const plans = plansSnap.val() || {};
          const carry = carrySnap.val() || {};

          let paymentsSource = extractPaymentsMap(ledgerSnap.val(), targetYear);
          if (!Object.keys(paymentsSource).length) {
            try {
              const altSnap = await ref(`financeLedgers/${studentId}/${targetYearStr}/payments`).once('value');
              paymentsSource = extractPaymentsMap(altSnap.val(), targetYear);
            } catch (altErr) {
              console.warn('Legacy ledger path (payments) read failed', altErr?.message || altErr);
            }
          }
          if (!Object.keys(paymentsSource).length) {
            try {
              const altBucketSnap = await ref(`financeLedgers/${studentId}/${targetYearStr}`).once('value');
              paymentsSource = extractPaymentsMap(altBucketSnap.val(), targetYear);
            } catch (legacyBucketErr) {
              console.warn('Legacy ledger path (bucket) read failed', legacyBucketErr?.message || legacyBucketErr);
            }
          }
          if (!Object.keys(paymentsSource).length) {
            try {
              const altRootSnap = await ref(`financeLedgers/${studentId}`).once('value');
              paymentsSource = extractPaymentsMap(altRootSnap.val(), targetYear);
            } catch (legacyRootErr) {
              console.warn('Legacy ledger root read failed', legacyRootErr?.message || legacyRootErr);
            }
          }

          const enrollmentHasData = Object.keys(enrollment).length > 0;
          const anchorHasData = Object.keys(anchor).length > 0;
          const baseClass = enrollmentHasData
            ? (enrollment.className || enrollment.classLevel || enrollment.class || '')
            : (anchor.className || anchor.classLevel || anchor.class || baseStudent.classLevel || baseStudent.class || '');
          const deltaYears = enrollmentHasData ? 0 : (targetYear - (anchorHasData ? anchorYear : targetYear));
          const classLevel = shiftClass(baseClass, deltaYears);

          let effectiveFinance = null;
          try {
            effectiveFinance = await resolveEffectiveFinance(studentId, classLevel, { year: targetYearStr, anchorClass: baseClass });
          } catch (effErr) {
            console.warn('resolveEffectiveFinance error', effErr?.message || effErr);
          }

          const classDefaults = effectiveFinance?.classCfg || classFees[classLevel] || classFees[baseClass] || {};
          const resolvedPlanId = effectiveFinance?.planId || override.planId || classDefaults.defaultPlanId || null;
          let resolvedPlan = null;
          if (resolvedPlanId) {
            try {
              resolvedPlan = await getPlan(resolvedPlanId, { year: targetYearStr });
            } catch (planErr) {
              console.warn('Plan lookup failed', planErr?.message || planErr);
            }
            if (!resolvedPlan && plans[resolvedPlanId]) resolvedPlan = plans[resolvedPlanId];
          }

          const effectiveFeeValue = Number(effectiveFinance?.fee);
          const baseFeeCandidate =
            (Number.isFinite(effectiveFeeValue) && effectiveFeeValue > 0)
              ? effectiveFeeValue
              : (override.feePerYear ??
                classDefaults.feePerYear ??
                baseStudent.feePerYear ??
                baseStudent.feeDue ??
                baseStudent.requiredFee ??
                0);
          const baseFee = Math.max(0, Math.round(Number(baseFeeCandidate) || 0));
          const carryAmount = Math.max(0, Number(carry.amount ?? carry.balance ?? 0));
          const effectiveFee = Math.max(0, baseFee + carryAmount);

          let payments = normalizeLedgerPayments(paymentsSource, targetYear);
          if (!Object.keys(payments).length) {
            const overridePayments = normalizeLedgerPayments(coercePaymentMap(override.payments), targetYear);
            if (Object.keys(overridePayments).length) payments = overridePayments;
          }
          if (!Object.keys(payments).length) {
            const enrollmentPayments = normalizeLedgerPayments(coercePaymentMap(enrollment.payments), targetYear);
            if (Object.keys(enrollmentPayments).length) payments = enrollmentPayments;
          }
          if (!Object.keys(payments).length) {
            const basePayments = normalizeLedgerPayments(coercePaymentMap(baseStudent.payments), targetYear);
            if (Object.keys(basePayments).length) payments = basePayments;
          }

          const hasYearData =
            (Object.keys(enrollment).length > 0) ||
            (Object.keys(override).length > 0) ||
            (Object.keys(payments).length > 0) ||
            (classDefaults && Object.keys(classDefaults).length > 0) ||
            baseFee > 0 ||
            carryAmount > 0;

          const planName =
            (resolvedPlan && resolvedPlan.name) ||
            effectiveFinance?.planOverride?.planName ||
            effectiveFinance?.planOverride?.name ||
            override.planName ||
            override.paymentPlan ||
            enrollment.planName ||
            enrollment.paymentPlan ||
            classDefaults.defaultPlan ||
            baseStudent.paymentPlan ||
            '6-instalments';

          const effectiveOverride = {
            ...override,
            ...(effectiveFinance?.planOverride || {}),
            ...(effectiveFinance?.feeOverride || {}),
          };

          const prepared = {
            ...baseStudent,
            academicYear: targetYearStr,
            classLevel,
            paymentPlan: planName,
            baseFee,
            carryAmount,
            feePerYear: effectiveFee,
            payments,
            hasYearData,
            isGraduated: classLevel === 'GRADUATED',
            admissionNumber: enrollment.admissionNumber || enrollment.admissionNo || baseStudent.admissionNumber || studentId,
          };

          // Attach custom schedule or plan schedule for builder to use
          if (Array.isArray(effectiveOverride.customSchedule) && effectiveOverride.customSchedule.length) {
            prepared._customSchedule = effectiveOverride.customSchedule;
          } else if (resolvedPlan && Array.isArray(resolvedPlan.schedule)) {
            prepared._planSchedule = resolvedPlan.schedule; // [{label, from, to, weight}]
          }

          await render(prepared, classDefaults, effectiveOverride);
        })
        .catch(e => { console.error(e); err('Error loading student data.'); });

      // resize again after fonts/images settle
      window.addEventListener('load', () => {
        const h = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        try { window.parent.postMessage({ type:'resizeIframe', id: window.__STUDENT_ID__, height: h }, '*'); } catch {}
      });
    })();
  </script>

  <script>
  /** SoMAp v2.1 — Carry-forward overlay for January installment (prevYear >= 2025) */
  (function carryForwardIntoJanuary() {
    const START_YEAR = 2025;

    function detectTargetYear() {
      const urlYear = Number(new URL(location.href).searchParams.get('year'));
      if (!Number.isNaN(urlYear)) return urlYear;
      if (window.currentAcademicYear && Number(window.currentAcademicYear)) return Number(window.currentAcademicYear);
      try {
        const parentYear = Number(window.parent?.somapYearContext?.getSelectedYear?.());
        if (!Number.isNaN(parentYear)) return parentYear;
      } catch (_) {}
      return new Date().getFullYear();
    }

    const targetYear = detectTargetYear();
    const prevYear = targetYear - 1;
    if (!Number.isFinite(prevYear) || prevYear < START_YEAR) return;

    function parseNumberLike(value) {
      if (typeof value === 'number') return value;
      return Number(String(value || '0').replace(/[^\d\-]/g, '')) || 0;
    }

    function formatTSh(amount) {
      const value = Number(amount) || 0;
      try {
        return new Intl.NumberFormat('en-KE', {
          style: 'currency',
          currency: 'TZS',
          maximumFractionDigits: 0,
        }).format(value);
      } catch (_) {
        return 'TSh ' + value.toLocaleString('en-US');
      }
    }

    async function getCarryForward(adm) {
      if (!adm) return 0;
    if (typeof window.__somap_fetchCarryForward === 'function') {
      try {
        const val = await window.__somap_fetchCarryForward(targetYear, adm);
        if (val) return Math.max(0, Number(val) || 0);
      } catch (_) {}
    }

    const storeKey = `${targetYear}::${adm}`;
      try {
        if (window.parent && window.parent.__financeCarryForwardVisual) {
          const record = window.parent.__financeCarryForwardVisual[storeKey];
          if (record && record.carry) return Math.max(0, Number(record.carry) || 0);
        }
      } catch (_) {}

      try {
        const fromSession = sessionStorage.getItem(`somap_cf_${targetYear}_${adm}`);
        if (fromSession) return Math.max(0, Number(fromSession) || 0);
      } catch (_) {}

      try {
        if (window.parent && typeof window.parent.__finance_getBalanceForYearAdmission === 'function') {
          const bal = await window.parent.__finance_getBalanceForYearAdmission(prevYear, adm);
          return Math.max(0, Number(bal) || 0);
        }
      } catch (_) {}

      if (typeof window.__finance_getBalanceForYearAdmission === 'function') {
        try {
          const bal = await window.__finance_getBalanceForYearAdmission(prevYear, adm);
          return Math.max(0, Number(bal) || 0);
        } catch (_) {}
      }

      if (window.firebase?.database) {
        try {
          const ref = window.firebase.database().ref(`finance/${prevYear}/students/${adm}`);
          const snap = await ref.get();
          if (snap.exists()) {
            const data = snap.val() || {};
            if (data.balance !== undefined) return Math.max(0, Number(data.balance) || 0);
            const feeYear = Number(String(data.feeYear || data.fee || 0).replace(/[^\d]/g, '')) || 0;
            const paid = Number(String(data.paid || 0).replace(/[^\d]/g, '')) || 0;
            return Math.max(0, feeYear - paid);
          }
        } catch (err) {
          console.warn('CarryForward January fallback fetch failed', adm, prevYear, err);
        }
      }
      return 0;
    }

    async function applyCarryForward() {
      const adm = window.__STUDENT_ID__ || new URL(location.href).searchParams.get('student') || '';
      if (!adm) return;
      const carry = await getCarryForward(adm);
      if (!carry) return;

      const tableBody = document.querySelector('#breakdownContent table tbody');
      if (!tableBody) return;
      const firstRow = tableBody.querySelector('tr');
      if (!firstRow) return;

      const cells = Array.from(firstRow.children);
      const expectedCell = cells[1];
      const remainingCell = cells[3];
      if (!expectedCell) return;

      if (!expectedCell.dataset.baseValue) {
        expectedCell.dataset.baseValue = String(parseNumberLike(expectedCell.innerText));
      }
      const baseExpected = Number(expectedCell.dataset.baseValue || 0);
      const alreadyApplied = Number(expectedCell.dataset.cfCarryApplied || 0);
      const deltaCarry = Math.max(0, carry - alreadyApplied);
      if (deltaCarry === 0 && alreadyApplied > 0) {
        // Already applied same amount; ensure summary still reflects it.
      }
      const newExpected = baseExpected + carry;

      expectedCell.dataset.cfCarryApplied = String(carry);
      expectedCell.innerHTML = `${formatTSh(newExpected)}
        <div class="text-[10px] mt-1">
          <span class="px-2 py-0.5 rounded bg-yellow-100 text-yellow-700">
            + Carry Forward (${prevYear}): ${formatTSh(carry)}
          </span>
        </div>`;
      if (remainingCell) {
        if (!remainingCell.dataset.baseValue) {
          remainingCell.dataset.baseValue = String(parseNumberLike(remainingCell.innerText));
        }
        const baseRemaining = Number(remainingCell.dataset.baseValue || 0);
        const newRemaining = baseRemaining + carry;
        remainingCell.dataset.cfCarryApplied = String(carry);
        remainingCell.innerHTML = `${formatTSh(newRemaining)}
          <div class="text-[10px] mt-1 text-slate-500">
            Includes carry-forward balance
          </div>`;
      }

      const feeStrong = document.querySelector('[data-cf-fee-year] strong');
      if (feeStrong) {
        const baseFee =
          Number(feeStrong.dataset.baseFee || feeStrong.dataset.baseValue || 0) ||
          parseNumberLike(feeStrong.textContent);
        const shownCarry = Number(feeStrong.dataset.initialCarry || feeStrong.dataset.cfCarryApplied || 0);
        if (carry > shownCarry) {
          const totalFee = baseFee + carry;
          feeStrong.textContent = formatTSh(totalFee);
          feeStrong.dataset.initialCarry = String(carry);
          feeStrong.dataset.cfCarryApplied = String(carry);
        }
      }

      const remainingStrong = document.querySelector('[data-cf-remaining] strong');
      if (remainingStrong) {
        const baseFee =
          Number(remainingStrong.dataset.baseFee || feeStrong?.dataset.baseFee || 0) ||
          parseNumberLike(remainingStrong.textContent);
        const paidTotal = Number(remainingStrong.dataset.totalPaid || 0);
        const remBase = Number(remainingStrong.dataset.remBase || 0);
        const shownCarry = Number(remainingStrong.dataset.initialCarry || remainingStrong.dataset.cfCarryApplied || 0);
        if (carry > shownCarry) {
          const recomputed = Math.max(remBase, Math.max(0, (baseFee + carry) - paidTotal));
          remainingStrong.textContent = formatTSh(recomputed);
          remainingStrong.dataset.initialCarry = String(carry);
          remainingStrong.dataset.cfCarryApplied = String(carry);
        }
      }

      const carrySlot = document.querySelector('[data-cf-carry-slot]');
      if (carrySlot) {
        carrySlot.innerHTML = `<span class="px-2 py-0.5 rounded bg-yellow-100 text-yellow-700">Carry Forward (${prevYear}): ${formatTSh(carry)}</span>`;
      }
    }

    function startObserver() {
      const container = document.getElementById('breakdownContent');
      if (!container) return;
      const attempt = () => { applyCarryForward(); };
      if (container.querySelector('table tbody tr')) {
        attempt();
        return;
      }
      const observer = new MutationObserver(() => {
        if (container.querySelector('table tbody tr')) {
          observer.disconnect();
          attempt();
        }
      });
      observer.observe(container, { childList: true, subtree: true });
      setTimeout(() => observer.disconnect(), 12000);
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      startObserver();
    } else {
      document.addEventListener('DOMContentLoaded', startObserver);
    }
  })();
  </script>
</body>
</html>
