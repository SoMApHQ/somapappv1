<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>SoMAp — Reclassify School Fee Payments (Admin)</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet"/>
<style>
  *{font-family:Inter,system-ui,Arial}
  .mono{font-family:ui-monospace, Menlo, Monaco, Consolas, monospace}
  .tag{padding:2px 8px;border-radius:9999px;font-size:12px;font-weight:700}
  .tag-legacy{background:#fee2e2;color:#991b1b}
  .tag-ok{background:#dcfce7;color:#166534}
  .btn{padding:.5rem .75rem;border-radius:.5rem}
  .queued-row td{background:#dcfce7 !important;color:#166534 !important}
  .queued-row .queueHint{color:#166534}
  .queued-row input[type="checkbox"]{opacity:0.5;cursor:not-allowed}
  .queue-count-badge{margin-top:.15rem;font-size:10px;font-weight:600;color:#15803d}
</style>
</head>
<body class="bg-slate-50 min-h-screen">
<header class="bg-white border-b sticky top-0 z-20">
  <div class="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <a href="../Todashboardhtml/approvals.html" class="text-slate-700 hover:text-blue-600">← Back to Approvals</a>
      <h1 class="text-lg font-semibold">Reclassify School Fee Payments → Queue to Approvals</h1>
    </div>
    <div id="rtState" class="text-sm text-slate-500">Connecting…</div>
  </div>
</header>

<main class="max-w-6xl mx-auto px-4 py-4 space-y-4">
  <section class="bg-white border rounded-2xl p-4 shadow-sm">
    <p class="text-sm text-slate-600">
      Assign a year to legacy payments and <b>send them to Approvals (School Fees · PENDING)</b>.
      This page does <b>not</b> touch ledgers. Your approvals flow will post to
      <span class="mono">financeLedgers/{year}</span> after approval.
    </p>
    <div class="mt-3 flex flex-wrap items-center gap-2">
      <label class="flex items-center gap-2 text-sm">
        <input type="checkbox" id="toggleLegacyOnly" class="scale-110" checked>
        <span>Show legacy only</span>
      </label>
      <input id="searchBox" class="border rounded px-3 py-2 w-72" placeholder="Search name/admission/ref/note…"/>
      <select id="bulkYear" class="border rounded px-2 py-2"></select>
      <button id="btnApplyBulk" class="btn bg-slate-900 text-white">Queue selected to Approvals</button>
      <button id="btnReload" class="btn border">Reload</button>
      <div class="ml-auto text-sm text-slate-700">
        <span id="statStudents">0</span> students • <span id="statPayments">0</span> payments • <span id="statLegacy">0</span> legacy
      </div>
    </div>
  </section>

  <div id="lastQueued" class="text-sm text-slate-500 italic px-4">No recent queue activity.</div>

  <section class="bg-white border rounded-2xl p-4 shadow-sm">
    <div class="overflow-auto border rounded">
      <table class="min-w-full text-sm">
        <thead class="bg-slate-100">
          <tr class="text-left">
            <th class="p-2 w-10"><input type="checkbox" id="masterChk"></th>
            <th class="p-2">Student</th>
            <th class="p-2">Admission</th>
            <th class="p-2">Payment Key</th>
            <th class="p-2">Amount</th>
            <th class="p-2">Ref</th>
            <th class="p-2">Note / Method</th>
            <th class="p-2">Current Year</th>
            <th class="p-2">Assign Year</th>
            <th class="p-2">Actions</th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>
    </div>
    <div id="opToast" class="mt-3 text-sm text-slate-500"></div>
  </section>
</main>

<!-- Firebase compat -->
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
<script src="../firebase.js"></script>
<script src="../js/finance_dedupe.js"></script>

<script>
(async function(){
  // ---------- CONFIG ----------
  const YEARS = Array.from({length:20},(_,i)=>2023+i); // 2023..2042
  // Approvals pending root used by your approvals.html (School Fees lane)
  const APPROVALS_PENDING_ROOT = 'approvals/finance/pending';

  // ---------- STATE ----------
  const el = id => document.getElementById(id);
  const rowsEl = el('rows');
  const fmt = n => Number(n||0).toLocaleString();
  const esc = s => String(s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
  let db=null, approvalsByRef={}, payments=[], filtered=[], approvedPayments={};

  // ---------- HELPERS ----------
  const toast = (m,t=1600)=>{ el('opToast').textContent=m||''; if(m) setTimeout(()=>el('opToast').textContent='',t); };
  const studentName = s => (`${s.firstName||''} ${s.middleName||''} ${s.lastName||''}`).replace(/\s+/g,' ').trim() || s.name || s.fullName || '—';

  function queueCountForYear(payment, year){
    if(!year || !payment) return 0;
    const buckets = payment.queueCounts || {};
    return Number(buckets[String(year)] || 0);
  }
  
  function isPaymentQueuedForAnyYear(payment){
    if(!payment) return false;
    const buckets = payment.queueCounts || {};
    return Object.values(buckets).some(count => Number(count) > 0);
  }
  
  function getQueuedYears(payment){
    if(!payment) return [];
    const buckets = payment.queueCounts || {};
    return Object.entries(buckets)
      .filter(([year, count]) => Number(count) > 0)
      .map(([year]) => year);
  }
  function yearSelectHTML(selected){
    const opts = YEARS.map(y=>`<option value="${y}" ${String(selected)===String(y)?'selected':''}>${y}</option>`).join('');
    return `<select class="yrSel border rounded px-2 py-1">${opts}</select>`;
  }

  function resolvedYear(p){
    if (p.forYear!=null) return Number(p.forYear);
    if (p.year!=null) return Number(p.year);
    if (p.targetYear!=null) return Number(p.targetYear);
    const ref = String(p.referenceCode||'').trim();
    if (ref && approvalsByRef && approvalsByRef[ref]!=null) return Number(approvalsByRef[ref]);
    return null; // legacy
  }
  const isLegacy = p => resolvedYear(p)==null;

  // ---------- DB ----------
  async function initDb(){
    db = window.db || (window.firebase && firebase.database ? firebase.database() : null);
    if(!db) throw new Error('Firebase DB not initialized');
    el('rtState').textContent='Connected';
  }
  async function loadApprovalsIndex(){
    try{
      const s = await db.ref('approvalsIndex/byRef').once('value');
      approvalsByRef = s.exists()? (s.val()||{}) : {};
    }catch(e){
      approvalsByRef = {};
      console.warn('approvalsIndex/byRef not found; continuing.');
    }
  }

  async function loadApprovedPayments(){
    approvedPayments = {};
    try{
      // Check all years for approved payments in financeLedgers
      const years = Array.from({length:20},(_,i)=>2023+i);
      const checks = years.map(async year => {
        try{
          const ledgerSnap = await db.ref(`financeLedgers/${year}`).once('value');
          if(!ledgerSnap.exists()) return;
          const students = ledgerSnap.val() || {};
          Object.keys(students).forEach(studentId => {
            const studentLedger = students[studentId];
            const payments = studentLedger?.payments || {};
            Object.keys(payments).forEach(paymentKey => {
              const approvalId = `${studentId}_${paymentKey}`;
              approvedPayments[approvalId] = true;
            });
          });
        }catch(e){
          console.warn(`Failed to check financeLedgers/${year}`, e);
        }
      });
      await Promise.all(checks);
    }catch(e){
      console.warn('Failed to load approved payments; continuing.', e);
    }
  }

  // ---------- SCAN students/payments ----------
  async function scan(){
    payments = []; filtered = []; rowsEl.innerHTML='';
    await loadApprovalsIndex();
    await loadApprovedPayments();

    const s = await db.ref('students').once('value');
    const students = s.exists()? s.val() : {};
    const ids = Object.keys(students);
    el('statStudents').textContent = String(ids.length);

    ids.forEach(id=>{
      const stu = students[id]||{};
      const pays = stu.payments||{};
      Object.entries(pays).forEach(([pkey,p])=>{
        const approvalId = `${id}_${pkey}`;
        // Filter out approved payments
        if(!approvedPayments[approvalId]){
          payments.push({ studentId:id, student:stu, paymentKey:pkey, payment:p });
        }
      });
    });

    payments.sort((a,b)=>(Number(b.payment.timestamp||b.payment.approvedAt||0) - Number(a.payment.timestamp||a.payment.approvedAt||0)));
    filterAndRender();
  }

  function filterAndRender(){
    const q = (el('searchBox').value||'').toLowerCase().trim();
    const legacyOnly = el('toggleLegacyOnly').checked;
    let list = payments.slice();
    if (legacyOnly) list = list.filter(r=> isLegacy(r.payment));
    if (q){
      list = list.filter(r=>{
        const s = r.student, p=r.payment;
        return (studentName(s).toLowerCase().includes(q)
          || String(s.admissionNumber||r.studentId).toLowerCase().includes(q)
          || String(r.paymentKey).toLowerCase().includes(q)
          || String(p.referenceCode||'').toLowerCase().includes(q)
          || String(p.note||'').toLowerCase().includes(q)
          || String(p.method||'').toLowerCase().includes(q)
          || String(p.amount||'').includes(q));
      });
    }
    filtered = list;
    el('statPayments').textContent = String(filtered.length);
    el('statLegacy').textContent = String(filtered.filter(x=>isLegacy(x.payment)).length);
    renderRows();
  }

  function renderRows(){
    rowsEl.innerHTML='';
    if(!filtered.length){
      rowsEl.innerHTML = `<tr><td colspan="10" class="p-6 text-center text-slate-500">No matching payments</td></tr>`;
      return;
    }
    const frag = document.createDocumentFragment();
    filtered.forEach((r,i)=>{
      const s = r.student, p=r.payment;
      const displayName = studentName(s);
      const curY = resolvedYear(p);
      const badge = isLegacy(p) ? `<span class="tag tag-legacy">LEGACY</span>` : `<span class="tag tag-ok">OK</span>`;
      
      // Check if payment is queued for ANY year
      const isQueued = isPaymentQueuedForAnyYear(p);
      const queuedYears = getQueuedYears(p);
      let queueHintText = 'Ready';
      if(isQueued){
        const yearList = queuedYears.join(', ');
        const totalAttempts = queuedYears.reduce((sum, year) => {
          return sum + queueCountForYear(p, year);
        }, 0);
        queueHintText = `Queued for ${yearList}${totalAttempts > queuedYears.length ? ` (${totalAttempts}x total)` : ''}`;
      }
      const queueHintColor = isQueued ? 'text-emerald-700' : 'text-slate-400';
      const queueCountBadge = isQueued ? `<div class="queue-count-badge">Queued</div>` : '';
      
      const tr = document.createElement('tr');
      // Make entire row green if queued
      if(isQueued) {
        tr.className = 'queued-row';
      } else {
        tr.className = i%2?'bg-white':'bg-slate-50';
      }
      tr.setAttribute('data-sid', r.studentId);
      tr.setAttribute('data-pkey', r.paymentKey);
      tr.dataset.studentName = displayName;
      tr.dataset.isQueued = isQueued ? 'true' : 'false';

      // Button text and state based on queue status
      const buttonText = isQueued ? 'ALREADY QUEUED' : 'Queue to Approvals';
      const buttonClass = isQueued 
        ? 'btnQueue btn bg-slate-400 text-white text-xs cursor-not-allowed opacity-75' 
        : 'btnQueue btn bg-blue-600 text-white text-xs';
      const buttonDisabled = isQueued ? 'disabled' : '';

      tr.innerHTML = `
        <td class="p-2"><input type="checkbox" class="rowChk" ${isQueued ? 'disabled' : ''}></td>
        <td class="p-2">${esc(displayName)}</td>
        <td class="p-2 mono">${esc(s.admissionNumber || r.studentId)}</td>
        <td class="p-2 mono">${esc(r.paymentKey)}</td>
        <td class="p-2">TSh ${fmt(p.amount)}</td>
        <td class="p-2 mono">${esc(p.referenceCode || '—')}</td>
        <td class="p-2">
          <div class="text-slate-700">${esc(p.note||'')}</div>
          <div class="text-slate-500 text-xs">${esc(p.method||'')}</div>
        </td>
        <td class="p-2"><div>${curY? esc(curY): '—'} ${badge}</div></td>
        <td class="p-2">${yearSelectHTML(curY || new Date().getFullYear())}</td>
        <td class="p-2">
          <div class="queueHint text-xs ${queueHintColor}">${queueHintText}</div>
          ${queueCountBadge}
          <button class="${buttonClass}" ${buttonDisabled}>${buttonText}</button>
        </td>
      `;
      frag.appendChild(tr);
    });
    rowsEl.appendChild(frag);

    rowsEl.querySelectorAll('.btnQueue').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const tr = btn.closest('tr');
        const isQueued = tr.dataset.isQueued === 'true';
        
        // If already queued, show message and return
        if(isQueued || btn.disabled || btn.textContent === 'ALREADY QUEUED'){
          toast('This payment has already been queued to approvals', 'warning');
          return;
        }
        
        const sid = tr.getAttribute('data-sid');
        const pkey = tr.getAttribute('data-pkey');
        const yr = Number(tr.querySelector('.yrSel')?.value);
        if(!yr) return alert('Pick a year.');
        
        // Check if already queued for this specific year
        const paymentData = payments.find(p => p.studentId === sid && p.paymentKey === pkey);
        if(paymentData){
          const alreadyQueuedForYear = queueCountForYear(paymentData.payment, String(yr)) > 0;
          if(alreadyQueuedForYear){
            toast(`This payment has already been queued for year ${yr}`, 'warning');
            return;
          }
        }
        
        const hint = tr.querySelector('.queueHint');
        const studentLabel = tr.dataset.studentName || 'student';
        try{
          btn.disabled = true;
          btn.textContent = 'Queuing...';
          const queueAttempts = await queueToApprovals(sid, pkey, yr);
          
          // Update the row to show queued state
          tr.classList.add('queued-row');
          tr.dataset.isQueued = 'true';
          if(hint) {
            const queuedYears = getQueuedYears(paymentData?.payment || {});
            const yearList = queuedYears.join(', ');
            hint.textContent = `Queued for ${yearList || yr}`;
            hint.className = 'queueHint text-xs text-emerald-700';
          }
          btn.textContent = 'ALREADY QUEUED';
          btn.className = 'btnQueue btn bg-slate-400 text-white text-xs cursor-not-allowed opacity-75';
          btn.disabled = true;
          
          // Disable checkbox
          const checkbox = tr.querySelector('.rowChk');
          if(checkbox) checkbox.disabled = true;
          
          el('lastQueued').textContent = `Queued ${studentLabel} (${pkey}) for ${yr}`;
          toast(`Queued ${studentLabel} for ${yr}`, 'success');
          
          // Reload to refresh the list (this will also check for approved payments)
          await scan();
        }catch(e){
          alert('Queue failed: ' + e.message);
          btn.disabled = false;
          btn.textContent = 'Queue to Approvals';
        }
      });
    });
  }

  function selectedRows(){
    return Array.from(rowsEl.querySelectorAll('tr')).filter(tr=> tr.querySelector('.rowChk')?.checked);
  }

  // ---------- QUEUE TO APPROVALS (School Fees) ----------
  async function queueToApprovals(studentId, paymentKey, year){
    const [stuSnap, paySnap] = await Promise.all([
      db.ref(`students/${studentId}`).once('value'),
      db.ref(`students/${studentId}/payments/${paymentKey}`).once('value')
    ]);
    if(!stuSnap.exists() || !paySnap.exists()) throw new Error('Student/payment missing');
    const S = stuSnap.val()||{}, P = paySnap.val()||{};

    const fullName = (`${S.firstName||''} ${S.middleName||''} ${S.lastName||''}`).replace(/\s+/g,' ').trim() || '—';
    const approvalId = `${studentId}_${paymentKey}`; // idempotent
    const parsedYear = Number(year);
    const normalizedYear = Number.isFinite(parsedYear) ? parsedYear : new Date().getFullYear();

    const amountNumber = Number(P.amount || 0);
    const paymentPayload = {
      amount: amountNumber,
      method: P.method || '',
      referenceCode: P.referenceCode || '',
      recordedBy: P.recordedBy || 'unknown',
      note: P.note || '',
      timestamp: P.timestamp || P.approvedAt || Date.now(),
      paymentKey: paymentKey,
      recordedAt: P.recordedAt || P.timestamp || P.approvedAt || Date.now(),
      targetYear: normalizedYear,
      academicYear: normalizedYear,
    };

    const payload = {
      id: approvalId,
      studentId: studentId,
      studentName: fullName,
      admissionNumber: S.admissionNumber || studentId,
      studentAdm: S.admissionNumber || studentId,
      className: S.classLevel || S.class || '',
      parentContact: S.primaryParentContact || S.parentPhone || '',
      module: 'School Fees',          // IMPORTANT: lane identification
      category: 'Finance',
      targetYear: normalizedYear,
      amount: amountNumber,
      method: P.method || '',
      referenceCode: P.referenceCode || '',
      recordedBy: P.recordedBy || 'unknown',
      note: P.note || '',
      sourceModule: 'finance',
      source: 'Finance Reclassifier',
      createdAt: Date.now(),
      datePaid: paymentPayload.timestamp,
      originalTimestamp: P.timestamp || P.approvedAt || null,
      status: 'PENDING'
    };

    const studentAdm = S.admissionNumber || studentId;
    const identityCandidate = {
      ...paymentPayload,
      year: normalizedYear,
      studentAdm,
      paymentDate: paymentPayload.timestamp,
      sourceModule: 'School Fees'
    };

    const duplicateApproved = window.SOMAP_FINANCE?.isDuplicateInLedger
      ? await window.SOMAP_FINANCE.isDuplicateInLedger(
          db,
          `financeLedgers/${normalizedYear}/${studentId}/payments`,
          identityCandidate,
          normalizedYear,
          studentAdm
        )
      : false;
    if (duplicateApproved) {
      toast('THIS PAYMENT IS ALREADY APPROVED IN THE LEDGER. REJECTING DUPLICATE.', 2600);
      return;
    }

    let duplicatePending = false;
    const targetIdentity = window.SOMAP_FINANCE?.buildIdentity
      ? window.SOMAP_FINANCE.buildIdentity(identityCandidate, normalizedYear)
      : null;
    if (targetIdentity) {
      const pendingSnap = await db.ref('approvalsPending').once('value');
      if (pendingSnap.exists()) {
        pendingSnap.forEach((child) => {
          const val = child.val();
          if (!val) return;
          const status = String(val.status || 'PENDING').toUpperCase();
          if (status !== 'PENDING') return;
          const compareCandidate = {
            ...val,
            year: val.forYear || normalizedYear,
            studentAdm: val.studentAdm || val.admissionNumber || val.studentId,
            paymentDate: val.datePaid || val.timestamp,
            refCode: val.paymentReferenceCode || val.referenceCode,
            amount: Number(val.amountPaidNow || val.amount || 0),
            sourceModule: val.sourceModule || 'School Fees'
          };
          const pendingIdentity = window.SOMAP_FINANCE.buildIdentity(compareCandidate, normalizedYear);
          if (pendingIdentity === targetIdentity) duplicatePending = true;
        });
      }
    }
    if (duplicatePending) {
      toast('THIS HAS ALREADY BEEN QUEUED FOR APPROVAL. REJECTING DUPLICATE.', 2600);
      return;
    }

    const queueCountsKey = String(normalizedYear);
    let queueAttemptsForYear = 1;
    try{
      const queueTx = await db.ref(`students/${studentId}/payments/${paymentKey}/queueCounts/${queueCountsKey}`).transaction(
        current => (Number(current) || 0) + 1
      );
      queueAttemptsForYear = Number(queueTx.snapshot?.val()) || queueAttemptsForYear;
    }catch(err){
      const fallback = Number(((P.queueCounts || {})[queueCountsKey]) || 0) + 1;
      if (Number.isFinite(fallback)) queueAttemptsForYear = fallback;
    }
    payload.queueAttempts = queueAttemptsForYear;

    // Audit breadcrumb (does not set the real year here)
    await db.ref(`students/${studentId}/payments/${paymentKey}`).update({
      proposedYear: normalizedYear,
      stagedToApprovalsAt: Date.now()
    });

    // Write to approvals pending queue (School Fees lane)
    const pendingPath = `${APPROVALS_PENDING_ROOT}/${normalizedYear}/${approvalId}`;
    await db.ref(pendingPath).set(payload);

    const approvalsPendingPayload = {
      ...payload,
      approvalId,
      amountPaidNow: paymentPayload.amount,
      paymentReferenceCode: paymentPayload.referenceCode,
      sourceModule: 'finance',
      status: 'PENDING',
      forYear: normalizedYear,
      academicYear: normalizedYear,
      queueAttempts: queueAttemptsForYear,
      modulePayload: {
        studentKey: studentId,
        payment: {
          ...paymentPayload,
          amount: paymentPayload.amount,
          method: paymentPayload.method,
          referenceCode: paymentPayload.referenceCode,
        },
        paymentRef: paymentKey,
      },
    };
    await db.ref(`approvalsPending/${approvalId}`).set(approvalsPendingPayload);

    // Maintain approvalsIndex/byRef if payment has a reference code (help future resolution)
    const ref = String(P.referenceCode||'').trim();
    if (ref){
      const idxSnap = await db.ref(`approvalsIndex/byRef/${ref}`).once('value');
      if (!idxSnap.exists()){
        await db.ref(`approvalsIndex/byRef/${ref}`).set(normalizedYear);
      }
    }
    return queueAttemptsForYear;
  }

  // ---------- WIRE UI ----------
  function wireUI(){
    el('searchBox').addEventListener('input', filterAndRender);
    el('toggleLegacyOnly').addEventListener('change', filterAndRender);
    el('masterChk').addEventListener('change', e=>{
      const on = e.target.checked;
      rowsEl.querySelectorAll('.rowChk').forEach(ch=> ch.checked = on);
    });
    el('btnApplyBulk').addEventListener('click', async ()=>{
      const picks = selectedRows();
      if(!picks.length) return alert('Select at least one payment.');
      const yr = Number(el('bulkYear').value);
      if(!yr) return alert('Pick a bulk year.');
      let ok=0, fail=0;
      for (const tr of picks){
        const sid = tr.getAttribute('data-sid');
        const pkey = tr.getAttribute('data-pkey');
        try{
          const queueAttempts = await queueToApprovals(sid, pkey, yr);
          ok++;
          const hint = tr.querySelector('.queueHint');
          if(hint) hint.textContent = `Queued for ${yr}${queueAttempts > 1 ? ` (${queueAttempts}x)` : ''}`;
        }catch{
          fail++;
        }
      }
      if(ok){
        el('lastQueued').textContent = `Queued ${ok} payment(s) for ${yr}`;
        try{
          await scan();
        }catch(e){
          console.error('Re-scan after bulk queue failed', e);
        }
      }
      toast(`Queued ${ok} payment(s) to Approvals${fail?`, ${fail} failed`:''}`);
    });
    el('btnReload').addEventListener('click', scan);
  }

  function mountYears(){
    const sel = el('bulkYear');
    sel.innerHTML = YEARS.map(y=>`<option value="${y}">${y}</option>`).join('');
    sel.value = new Date().getFullYear();
  }

  // ---------- START ----------
  try{
    mountYears();
    wireUI();
    await initDb();
    await scan();
  }catch(e){
    console.error(e);
    el('rtState').textContent = 'Error: ' + e.message;
    alert('Init failed: '+e.message);
  }
})();
</script>
</body>
</html>
