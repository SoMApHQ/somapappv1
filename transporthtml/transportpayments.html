<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Transport Payments - Management & Debt Tracking</title>
    <link rel="stylesheet" href="./css/transport_dark.css" />
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-storage-compat.js"></script>
    <script src="../somapappv1multischool/js/context.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <script src="../Todashboardhtml/yearContext.js"></script>
    <style>
      .tableScrollControls {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-bottom: 8px;
      }

      /* Keep Actions always visible */
      #paymentsTable th:last-child,
      #paymentsTable td:last-child {
        position: sticky;
        right: 0;
        z-index: 3;
        background: rgba(15, 23, 42, 0.95);
        box-shadow: -8px 0 16px rgba(0, 0, 0, 0.25);
      }
    </style>
    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyBhONntRE_aRsU0y1YcPZzWud3CBfwH_a8",
        authDomain: "somaptestt.firebaseapp.com",
        databaseURL: "https://somaptestt-default-rtdb.firebaseio.com",
        projectId: "somaptestt",
        storageBucket: "somaptestt.appspot.com",
        messagingSenderId: "105526245138",
        appId: "1:105526245138:web:b8e7c0cb82a46e861965cb",
      };
      if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
    </script>
  </head>
  <body>
    <div id="contextBar" class="bar">
      <div>
        <h1>Transport Payments & Debt Management</h1>
        <small>Comprehensive payment tracking and debt monitoring - <span id="schoolNameDisplay">-</span></small>
      </div>
      <div class="context-selectors">
        <div class="date-time-display">
          <span class="label">Payment Due Date</span>
          <span class="value" id="dueDate">3rd of each month</span>
        </div>
        <div>
          <label style="margin-bottom: 0.25rem; font-size: 0.75rem;">Academic Year</label>
          <select id="yearSelect" data-somap-year-select data-somap-year-min="2023" data-somap-year-max="2042" style="min-width: 100px; padding: 0.5rem;">
          </select>
        </div>
        <a id="backButton" href="transport.html" class="btn secondary"><- Back to Dashboard</a>
      </div>
    </div>

    <main>
      <!-- Financial Overview KPIs -->
      <section class="row">
        <article class="card stat-card">
          <div class="stat-label">Total Expected (This Month)</div>
          <div class="stat-value" id="totalExpected">-</div>
          <div class="stat-label" style="font-size: 0.75rem; margin-top: 0.5rem;" id="monthLabel"></div>
        </article>
        
        <article class="card stat-card">
          <div class="stat-label">Total Collected</div>
          <div class="stat-value" id="totalCollected" style="color: var(--accent-success);">-</div>
          <div class="stat-label" style="font-size: 0.75rem; margin-top: 0.5rem;">All transport payments</div>
        </article>
        
        <article class="card stat-card">
          <div class="stat-label">Total Transport Debt</div>
          <div class="stat-value" id="totalDebt" style="color: var(--accent-danger);">-</div>
          <div class="stat-label" style="font-size: 0.75rem; margin-top: 0.5rem;">Unpaid amounts</div>
        </article>
        
        <article class="card stat-card">
          <div class="stat-label">Total Expenses</div>
          <div class="stat-value" id="totalExpenses">-</div>
          <div class="stat-label" style="font-size: 0.75rem; margin-top: 0.5rem;">Fuel + Maintenance</div>
        </article>
        
        <article class="card stat-card">
          <div class="stat-label">Net Balance</div>
          <div class="stat-value" id="netBalance">-</div>
          <div class="stat-label" style="font-size: 0.75rem; margin-top: 0.5rem;">Collected - Expenses</div>
        </article>
      </section>

      <!-- Critical Alerts -->
      <section id="criticalAlerts" class="mt-3"></section>

      <!-- Students on Transport - Payment Tracking -->
      <section class="card mt-3">
        <div class="flex space center mb-2">
          <div>
            <h2 style="margin: 0;">Students on Transport - Payment Registry</h2>
            <small id="paymentSummary" class="muted"></small>
          </div>
          <div class="flex">
            <button class="btn secondary" onclick="toggleDebtorsOnly()">
              <span id="debtorsBtnText">Show Debtors Only</span>
            </button>
            <button class="btn secondary" id="exportPdfBtn">Download PDF</button>
            <button class="btn success" onclick="exportToExcel()">Export Excel</button>
            <button class="btn" onclick="refreshData()">Refresh</button>
          </div>
        </div>

        <div class="filter-bar">
          <select id="classFilter">
            <option value="">All Classes</option>
            <option>Baby Class</option>
            <option>Middle Class</option>
            <option>Pre Unit Class</option>
            <option>Class 1</option>
            <option>Class 2</option>
            <option>Class 3</option>
            <option>Class 4</option>
            <option>Class 5</option>
            <option>Class 6</option>
            <option>Class 7</option>
          </select>
          <input id="searchInput" type="text" placeholder="Search student..." style="max-width: 300px;" />
          <select id="statusFilter">
            <option value="">All Status</option>
            <option value="paid">Paid</option>
            <option value="partial">Partially Paid</option>
            <option value="unpaid">Unpaid (DEBT)</option>
          </select>
        </div>

        <div class="tableScrollWrap" style="margin-top: 1.5rem;">
          <div class="tableScrollControls">
            <button class="btn secondary" type="button" onclick="scrollPaymentsTable(-1)">&larr;</button>
            <button class="btn secondary" type="button" onclick="scrollPaymentsTable(1)">&rarr;</button>
          </div>
          <div id="paymentsTableScroll" style="overflow-x:auto;">
            <div id="loadingIndicator" class="empty" style="text-align: center; padding: 2rem; display: none;">
              <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">Loading student data...</div>
              <div style="font-size: 0.875rem; color: var(--text-muted, #94a3b8);" id="loadingProgress">Please wait</div>
            </div>
            <table class="table" id="paymentsTable">
              <thead>
                <tr>
                  <th>Admission No</th>
                  <th>Full Name</th>
                  <th>Class</th>
                  <th>Parent Contact</th>
                  <th>Transport Start Date</th>
                  <th>Route (Morning)</th>
                  <th>Route (Evening)</th>
                  <th>Driver</th>
                  <th>Current Month Transport Fee</th>
                  <th>Transport Paid</th>
                  <th>Transport Debt (TO DATE)</th>
                  <th>Unpaid Months (TO DATE)</th>
                  <th>Total Combined Debt</th>
                  <th>Total Year Fee</th>
                  <th>Total Year Debt</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="paymentsBody">
                <!-- Populated by JavaScript -->
              </tbody>
            </table>
            <div id="emptyState" class="empty hidden">No students found on transport</div>
          </div>
        </div>
      </section>

      <!-- Expenses Tracking -->
      <section class="card mt-3">
        <h2>Transport Expenses Tracker</h2>
        <p class="muted mb-2">Track all transport-related expenses including fuel, maintenance, repairs, etc.</p>

        <div class="grid two" style="margin-bottom: 1.5rem;">
          <div class="card"> 
            <h3 style="margin-top: 0;">Quick Stats</h3>
            <div style="display: grid; gap: 0.75rem;">
              <div style="display: flex; justify-content: space-between;">
                <span>Fuel Expenses:</span>
                <span id="fuelExpenses" style="font-weight: 600;">-</span>
              </div>
              <div style="display: flex; justify-content: space-between;">
                <span>Maintenance Expenses:</span>
                <span id="maintenanceExpenses" style="font-weight: 600;">-</span>
              </div>
              <div style="display: flex; justify-content: space-between;">
                <span>Other Expenses:</span>
                <span id="otherExpenses" style="font-weight: 600;">-</span>
              </div>
            </div>
          </div>

          <div class="card">
            <h3 style="margin-top: 0;">Add New Expense</h3>
            <div style="display: grid; gap: 0.75rem;">
              <select id="expenseCategory">
                <option value="">Select Category</option>
                <option value="FUEL">Fuel</option>
                <option value="MAINTENANCE">Maintenance</option>
                <option value="REPAIRS">Repairs</option>
                <option value="INSURANCE">Insurance</option>
                <option value="PERMITS">Permits</option>
                <option value="SALARIES">Driver Salaries</option>
                <option value="OTHER">Other</option>
              </select>
              <input id="expenseAmount" type="number" min="1" placeholder="Amount (TZS)" />
              <input id="expenseDescription" type="text" placeholder="Description" />
              <button class="btn success" onclick="addExpense()">Add Expense</button>
            </div>
          </div>
        </div>

        <div style="overflow-x: auto;">
          <table class="table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Category</th>
                <th>Description</th>
                <th>Amount</th>
                <th>Added By</th>
              </tr>
            </thead>
            <tbody id="expensesBody">
              <!-- Populated by JavaScript -->
            </tbody>
          </table>
        </div>
      </section>
    </main>

    <!-- Payment History Modal -->
    <div id="historyModal" class="modal hidden">
      <div class="modal-content" style="max-width: 1200px;">
        <div class="flex space center mb-2">
          <h2 style="margin: 0;" id="historyModalTitle">Payment History</h2>
          <button class="btn secondary" onclick="closeHistoryModal()">Close</button>
        </div>
        <div id="historyStartDateInfo" style="padding: 1rem; background: rgba(59, 130, 246, 0.1); border-radius: 12px; margin-bottom: 1rem; display: none;">
          <strong>Transport Start Date:</strong> <span id="historyStartDateValue">-</span>
        </div>
        <div class="flex mb-2" style="flex-wrap: wrap; gap: 0.5rem;">
          <button type="button" class="btn" id="openPaymentScheduleBtn" title="View and download year payment schedule for parent">
            &#128196; Taarifa ya Malipo (Payment Schedule)
          </button>
        </div>
        <div style="overflow-x: auto; margin-top: 1.5rem;">
          <table class="table" id="historyTable">
            <thead>
              <tr>
                <th>Date</th>
                <th>Month</th>
                <th>Amount</th>
                <th>Method</th>
                <th>Reference</th>
                <th>Payer Name</th>
                <th>Status</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody id="historyBody">
              <!-- Populated by JavaScript -->
            </tbody>
          </table>
          <div id="historyEmpty" class="empty hidden">No payments recorded</div>
        </div>
      </div>
    </div>

    <!-- Payment Schedule Modal (Taarifa ya Malipo) -->
    <div id="paymentScheduleModal" class="modal hidden">
      <div class="modal-content" style="max-width: 700px;">
        <div class="flex space center mb-2">
          <h2 style="margin: 0;">Taarifa ya Malipo ya Usafiri - Payment Schedule</h2>
          <button class="btn secondary" onclick="closePaymentScheduleModal()">Close</button>
        </div>
        <div id="paymentScheduleStudentInfo" style="padding: 1rem; background: rgba(59, 130, 246, 0.1); border-radius: 12px; margin-bottom: 1rem;"></div>
        <div id="paymentScheduleTableWrap" style="overflow-x: auto; margin-bottom: 1rem;">
          <table class="table" id="paymentScheduleTable">
            <thead>
              <tr>
                <th>Mkupuo / Month</th>
                <th>Inatarajiwa / Expected</th>
                <th>Imelipwa / Paid</th>
                <th>Salio / Balance</th>
              </tr>
            </thead>
            <tbody id="paymentScheduleBody"></tbody>
          </table>
        </div>
        <div id="paymentScheduleTotals" style="padding: 1rem; background: rgba(15, 23, 42, 0.5); border-radius: 12px; margin-bottom: 1rem;"></div>
        <div class="flex" style="gap: 0.5rem;">
          <button type="button" class="btn success" id="downloadPaymentSchedulePdf">&#128196; Download PDF</button>
        </div>
      </div>
    </div>

    <!-- Record Payment Modal -->
    <div id="paymentModal" class="modal hidden">
      <div class="modal-content">
        <div class="flex space center mb-2">
          <h2 style="margin: 0;">Record Transport Payment</h2>
          <button class="btn secondary" onclick="closePaymentModal()">Close</button>
        </div>

        <div id="paymentAlert" class="alert hidden"></div>

        <div style="margin-bottom: 1.5rem; padding: 1rem; background: rgba(59, 130, 246, 0.1); border-radius: 12px;">
          <h3 style="margin: 0 0 0.5rem 0; font-size: 1rem;">Student Information</h3>
          <div id="paymentStudentInfo"></div>
        </div>

        <div class="grid two">
          <div>
            <label for="paymentMonth">Payment Month</label>
            <select id="paymentMonth" required>
              <option value="">Select Month</option>
              <option value="1">January</option>
              <option value="2">February</option>
              <option value="3">March</option>
              <option value="4">April</option>
              <option value="5">May</option>
              <option value="6">June</option>
              <option value="7">July</option>
              <option value="8">August</option>
              <option value="9">September</option>
              <option value="10">October</option>
              <option value="11">November</option>
              <option value="12">December</option>
            </select>
          </div>

          <div>
            <label for="paymentAmount">Amount Paid (TZS)</label>
            <input id="paymentAmount" type="number" min="1" required />
          </div>

          <div>
            <label for="paymentMethod">Payment Method</label>
            <select id="paymentMethod">
              <option>Cash</option>
              <option>M-Pesa</option>
              <option>Airtel Money</option>
              <option>TigoPesa</option>
              <option>Bank Transfer</option>
              <option>Cheque</option>
              <option>Other</option>
            </select>
          </div>

          <div>
            <label for="paymentReference">Reference/Transaction No <span style="color: red;">*</span></label>
            <input id="paymentReference" type="text" placeholder="e.g., RFX123..." required />
          </div>

          <div>
            <label for="paymentPayerName">Payer Full Name <span style="color: red;">*</span></label>
            <input id="paymentPayerName" type="text" placeholder="Parent/Guardian name" required />
          </div>

          <div>
            <label for="paymentDate">Payment Date <span style="color: red;">*</span></label>
            <input id="paymentDate" type="date" required />
          </div>
        </div>

        <div class="mt-2">
          <label for="paymentNotes">Notes (Optional)</label>
          <textarea id="paymentNotes" rows="3" placeholder="Any additional notes..."></textarea>
        </div>

        <div class="flex mt-2" style="justify-content: flex-end; gap: 1rem;">
          <button class="btn secondary" onclick="closePaymentModal()">Cancel</button>
          <button class="btn success" onclick="savePayment()">Save Payment</button>
        </div>
      </div>
    </div>

    <div id="toast" class="toast hidden"></div>

    <script src="./modules/transport_roles.js"></script>
    <script src="./modules/transport_context.js"></script>
    <script src="./modules/transport_helpers.js"></script>
    <script src="./modules/transport_pricing.js"></script>
    <script>
      const db = firebase.database();
      const schoolParams = new URLSearchParams(window.location.search);
      const initOptions = {
        db,
        allowQuerySchoolParam: true,
        redirectIfMissingSchool: true,
        multischoolPath: '../somapappv1multischool/multischool.html',
      };
      if (window.SOMAP?.init) {
        try {
          window.SOMAP.init(initOptions);
        } catch (err) {
          console.warn('SOMAP.init failed:', err);
        }
      } else if (initOptions.allowQuerySchoolParam) {
        const schoolParam = schoolParams.get('school');
        if (schoolParam && window.SOMAP?.setSchoolId) {
          window.SOMAP.setSchoolId(schoolParam);
        }
      }

      const currentSchool = window.SOMAP?.getSchool?.();
      if (!currentSchool || !currentSchool.id) {
        if (initOptions.redirectIfMissingSchool) {
          window.location.href = initOptions.multischoolPath;
        }
      }

      let schoolId = currentSchool?.id || '';
      let schoolName = currentSchool?.name || schoolId;
      const isSocratesSchool = () => schoolId === 'socrates-school' || schoolId === 'default';

      function scopedSubPath(subPath) {
        const clean = String(subPath || '').replace(/^\/+/, '');
        if (isSocratesSchool()) return `schools/${schoolId}/${clean}`;
        return clean;
      }

      function schoolRef(subPath) {
        return db.ref(window.SOMAP.P(scopedSubPath(subPath)));
      }

      function schoolPath(subPath) {
        return window.SOMAP.P(scopedSubPath(subPath));
      }

      async function scopedOrSocratesLegacy(scopedSubPath, legacyPath) {
        const scopedRef = schoolRef(scopedSubPath);
        if (!isSocratesSchool() || !legacyPath) return scopedRef.once('value');
        try {
          const scopedSnap = await scopedRef.once('value');
          const val = scopedSnap.val();
          const emptyObj = val && typeof val === 'object' && Object.keys(val).length === 0;
          if (!scopedSnap.exists() || emptyObj) {
            return db.ref(legacyPath).once('value');
          }
          return scopedSnap;
        } catch (err) {
          console.warn('Scoped read failed, falling back to legacy:', scopedSubPath, err);
          return db.ref(legacyPath).once('value');
        }
      }

      // Fetch approvalsHistory from all paths approvals.js may write to (school-scoped + root for Socrates)
      async function fetchApprovalsHistoryForYear(year) {
        const yearStr = String(year);
        const merged = {};
        try {
          const paths = [
            schoolRef(`approvalsHistory/${yearStr}`),
            db.ref(`approvalsHistory/${yearStr}`)
          ];
          for (const ref of paths) {
            const snap = await ref.once('value').catch(() => null);
            const val = snap?.val();
            if (val && typeof val === 'object' && Object.keys(val).length > 0) {
              Object.entries(val).forEach(([month, records]) => {
                merged[month] = { ...(merged[month] || {}), ...(records || {}) };
              });
            }
          }
        } catch (err) {
          console.warn('fetchApprovalsHistoryForYear:', err);
        }
        return merged;
      }

      function maybeAutoAdvanceYear() {
        const ctx = window.somapYearContext;
        if (!ctx || typeof ctx.getSelectedYear !== 'function') return;
        const current = String(new Date().getFullYear());
        const selected = String(ctx.getSelectedYear());
        if (Number(current) > Number(selected)) {
          if (typeof ctx.resetToCurrentYear === 'function') {
            ctx.resetToCurrentYear();
          } else if (typeof ctx.setSelectedYear === 'function') {
            ctx.setSelectedYear(current, { manual: false, forceDispatch: true });
          }
        }
      }

      const CLASS_ORDER = ['Baby Class', 'Middle Class', 'Pre Unit Class', 'Class 1', 'Class 2', 'Class 3', 'Class 4', 'Class 5', 'Class 6', 'Class 7'];
      function shiftClass(baseClass, deltaYears) {
        const normalized = String(baseClass || '').trim();
        const idx = CLASS_ORDER.findIndex(c => c.toLowerCase() === normalized.toLowerCase());
        if (idx < 0) return baseClass || '';
        const newIdx = idx + Number(deltaYears || 0);
        if (newIdx < 0) return 'PRE-ADMISSION';
        if (newIdx >= CLASS_ORDER.length) return 'GRADUATED';
        return CLASS_ORDER[newIdx];
      }

      async function maybeRunRollover() {
        const systemYear = String(new Date().getFullYear());
        const flagRef = schoolRef(`meta/rolloverDone/${systemYear}`);
        try {
          const flagSnap = await flagRef.get();
          if (flagSnap.exists()) return;
          const previousYear = String(Number(systemYear) - 1);
          const prevEnrollSnap = await scopedOrSocratesLegacy(`years/${previousYear}/enrollments`, `enrollments/${previousYear}`);
          const prevEnrollments = prevEnrollSnap.val() || {};
          const nowIso = new Date().toISOString();
          const updates = {};

          Object.entries(prevEnrollments).forEach(([studentKey, record]) => {
            const baseClass = (record && (record.className || record.classLevel)) || '';
            const nextClass = shiftClass(baseClass, 1);
            if (nextClass === 'GRADUATED') {
              updates[schoolPath(`years/${systemYear}/graduated/${studentKey}`)] = {
                className: baseClass || 'Class 7',
                promotedAt: nowIso,
                fromYear: Number(previousYear)
              };
              updates[schoolPath(`years/${systemYear}/enrollments/${studentKey}`)] = {
                className: 'GRADUATED',
                promotedFrom: baseClass || 'Class 7',
                fromYear: Number(previousYear),
                at: firebase.database.ServerValue.TIMESTAMP
              };
            } else {
              updates[schoolPath(`years/${systemYear}/enrollments/${studentKey}`)] = {
                className: nextClass,
                promotedFrom: baseClass,
                fromYear: Number(previousYear),
                at: firebase.database.ServerValue.TIMESTAMP
              };
            }
          });

          updates[schoolPath(`meta/rolloverDone/${systemYear}`)] = true;
          await db.ref().update(updates);
        } catch (err) {
          console.warn('Year rollover skipped/failed:', err);
        }
      }

      const schoolNameDisplay = document.getElementById('schoolNameDisplay');
      if (schoolNameDisplay) {
        schoolNameDisplay.textContent = schoolName
          || (isSocratesSchool() ? 'Socrates School' : schoolId)
          || 'Socrates School';
      }

      // Allow deep links to set the active year via the shared helper
      (function syncYearFromUrl() {
        const params = new URLSearchParams(window.location.search);
        const y = parseInt(params.get('year'), 10);
        if (Number.isFinite(y) && window.somapYearContext?.setSelectedYear) {
          window.somapYearContext.setSelectedYear(String(y), { manual: false, forceDispatch: true });
        }
      })();

      // Global State
      const state = {
        user: null,
        role: null,
        year: (() => {
          const rawYear = window.somapYearContext?.getSelectedYear?.();
          const parsed = parseInt(rawYear, 10);
          return Number.isFinite(parsed) ? parsed : new Date().getFullYear();
        })(),
        month: new Date().getMonth() + 1,
        schoolId,
        schoolName,
        students: {},
        transportEnrollments: {},
        financeData: {},
        transportPayments: {},
        expenses: {},
        showDebtorsOnly: false,
        currentPaymentStudentId: null,
        currentHistoryResolvedPayments: [],
        studentKeyAliases: {},
      };

      state.year = Number(state.year) || new Date().getFullYear();
      state.month = Number(state.month) || new Date().getMonth() + 1;

      const MONTH_NAMES = ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      const BASE_YEAR = 2025;
      
      // Store loaded multipliers per year
      let cachedMultipliers = {};

      function getFocusedMonth() {
        const today = new Date();
        // Only honor state.month when explicitly provided via URL or user selection
        if (state.monthSelectedFromUrl === true) {
          const parsed = Number(state.month);
          if (Number.isFinite(parsed) && parsed >= 1 && parsed <= 12) return parsed;
        }
        if (today.getFullYear() === Number(state.year)) return today.getMonth() + 1;
        return 1;
      }

      function normalizeDateInput(raw, fallbackYear = Number(state.year)) {
        if (raw === null || raw === undefined || raw === '') {
          const yr = Number.isFinite(fallbackYear) ? fallbackYear : new Date().getFullYear();
          return `${yr}-01-01`;
        }
        if (typeof raw === 'number') {
          const d = new Date(raw);
          if (!Number.isNaN(d.getTime())) return d.toISOString().slice(0, 10);
        }
        const text = String(raw).trim();
        if (/^\d{4}-\d{2}-\d{2}$/.test(text)) return text;
        if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(text)) {
          const [dd, mm, yy] = text.split('/').map(Number);
          const date = new Date(yy, mm - 1, dd);
          if (!Number.isNaN(date.getTime())) return date.toISOString().slice(0, 10);
        }
        const tryDate = new Date(text);
        if (!Number.isNaN(tryDate.getTime())) return tryDate.toISOString().slice(0, 10);
        const yr = Number.isFinite(fallbackYear) ? fallbackYear : new Date().getFullYear();
        return `${yr}-01-01`;
      }

      function resolveStartDate(enrollment) {
        if (!enrollment) return normalizeDateInput(null);
        if (enrollment.startDate) return normalizeDateInput(enrollment.startDate);
        if (enrollment.start_date) return normalizeDateInput(enrollment.start_date);
        if (enrollment.startTimestamp) return normalizeDateInput(Number(enrollment.startTimestamp));
        if (enrollment.start_time) return normalizeDateInput(enrollment.start_time);
        if (enrollment.dateRegistered) return normalizeDateInput(enrollment.dateRegistered);
        return normalizeDateInput(null);
      }

      function formatStartDateDisplay(value) {
        if (!value) return 'N/A';
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return String(value);
        return date.toLocaleDateString('en-GB');
      }

      // Phone normalization
      function normalizePhone(p) {
        const s = String(p || '').replace(/[\s\-()]/g, '');
        return s.replace(/(?!^\+)[^\d]/g, '');
      }

      function normalizeIdentifier(value) {
        return String(value || '').trim().toUpperCase().replace(/[^A-Z0-9]/g, '');
      }

      function splitName(fullName) {
        const clean = String(fullName || '').replace(/\s+/g, ' ').trim();
        if (!clean) return { firstName: '', middleName: '', lastName: '' };
        const parts = clean.split(' ');
        if (parts.length === 1) return { firstName: parts[0], middleName: '', lastName: '' };
        if (parts.length === 2) return { firstName: parts[0], middleName: '', lastName: parts[1] };
        return {
          firstName: parts[0],
          middleName: parts.slice(1, -1).join(' '),
          lastName: parts[parts.length - 1],
        };
      }

      function buildFallbackStudent(studentId, enrollment = {}) {
        const fullNameRaw = enrollment.studentName || enrollment.fullName || enrollment.name || '';
        const { firstName, middleName, lastName } = splitName(fullNameRaw || studentId);
        return {
          firstName,
          middleName,
          lastName,
          classLevel: enrollment.classLevel || enrollment.className || enrollment.class || '',
          admissionNumber: enrollment.admissionNumber || enrollment.admissionNo || enrollment.studentAdm || studentId,
          primaryParentContact: enrollment.primaryParentContact || enrollment.parentContact || enrollment.parentPhone || enrollment.guardianPhone || '',
          feePerYear: Number(enrollment.feePerYear || enrollment.schoolFeeTotal || 0) || 0,
          payments: {},
          timestamp: enrollment.timestamp || enrollment.createdAt || enrollment.dateRegistered || null,
          createdAt: enrollment.createdAt || enrollment.timestamp || enrollment.dateRegistered || null,
          __synthetic: true,
        };
      }

      function getStudentForTransport(studentId, enrollment = null) {
        const student = state.students[studentId];
        if (student) return student;
        const fallback = buildFallbackStudent(studentId, enrollment || state.transportEnrollments[studentId] || {});
        state.students[studentId] = fallback;
        return fallback;
      }

      const toast = document.getElementById("toast");
      const yearSelect = document.getElementById("yearSelect");
      const classFilter = document.getElementById("classFilter");
      const searchInput = document.getElementById("searchInput");
      const statusFilter = document.getElementById("statusFilter");
      const paymentsBody = document.getElementById("paymentsBody");
      
      // Initialize year from context
      if (window.somapYearContext) {
        const currentYear = window.somapYearContext.getSelectedYear();
        state.year = parseInt(currentYear) || state.year;
        if (yearSelect) yearSelect.value = state.year;
      }

      // Utility Functions
      function showToast(message, tone = "ok") {
        toast.textContent = message;
        toast.classList.remove("hidden");
        toast.style.background = tone === "bad" ? "#ef4444" : "#10b981";
        setTimeout(() => toast.classList.add("hidden"), 3500);
      }

      function resolveRecorder() {
        if (state.user && state.user.email) return state.user.email;
        if (state.user && state.user.uid) return state.user.uid;
        return "unknown";
      }

      function formatCurrency(amount) {
        return new Intl.NumberFormat('en-TZ', { style: 'currency', currency: 'TZS', minimumFractionDigits: 0 }).format(amount || 0);
      }

      function formatShortNum(amount) {
        return new Intl.NumberFormat('en-TZ', { minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(Math.round(amount || 0));
      }

      function formatDate(timestamp) {
        if (!timestamp) return 'N/A';
        const date = new Date(timestamp);
        return date.toLocaleDateString('en-GB');
      }

      function sanitizeDriverName(name) {
        const v = String(name || '').trim();
        if (!v) return '';
        const n = v.toLowerCase();
        if (n === 'not assigned' || n === 'n/a' || n === 'na' || n === 'none' || n === '-' || n === 'â€”' || n === 'unknown') return '';
        return v;
      }

      function driverNameFromVehicle(v) {
        return sanitizeDriverName(v?.driverName || v?.assignedDriverName || v?.driverFullName || v?.driver || '');
      }

      function getDriverDisplay(enrollment) {
        const amDriver = driverNameFromVehicle(enrollment?.morningVehicle);
        const pmDriver = driverNameFromVehicle(enrollment?.eveningVehicle);
        if (amDriver && pmDriver && amDriver !== pmDriver) return `AM: ${amDriver} / PM: ${pmDriver}`;
        return amDriver || pmDriver || '&mdash;';
      }

      // Calculate school debt till
      function calculateDebtTill(student) {
        // This matches the finance.html logic
        const feePerYear = Number(student.feePerYear) || 0;
        const payments = student.payments || {};
        const totalPaid = Object.values(payments).reduce((sum, p) => sum + (Number(p.amount) || 0), 0);
        
        // Simple calculation - in real app, this would match finance.html installment logic
        const debt = Math.max(0, feePerYear - totalPaid);
        return debt > 0 ? `Inst ${Math.min(6, Math.ceil(debt / (feePerYear / 6)))}` : '-';
      }

      // Calculate base monthly fee (without month multipliers) - for display in table
      // Now date-aware: uses priceHistory for the selected month
      async function calculateBaseMonthlyFee(amStop, pmStop, year, month) {
        return await TransportPricing.computeBaseMonthlyFeeOnMonth({ year, month, amStop, pmStop });
      }

      // Calculate transport payment status (now year-scoped with DB multipliers) - OPTIMIZED with parallel month calculations and caching
      async function calculateTransportStatus(enrollment, payments, yearMultipliers, studentId = null) {
        // Check cache first to avoid recalculation
        if (studentId) {
          const cacheKey = getCacheKey(studentId, state.year);
          if (statusCache.has(cacheKey)) {
            return statusCache.get(cacheKey);
          }
        }

        const amStop = enrollment?.amStop || '';
        const pmStop = enrollment?.pmStop || '';
        const year = Number(state.year) || new Date().getFullYear();

        // Use year-specific multipliers if provided, otherwise load from DB
        const multipliers = yearMultipliers || cachedMultipliers[year] || (await TransportPricing.loadYearMultipliers(year));
        if (!cachedMultipliers[year]) cachedMultipliers[year] = multipliers;

        // Base monthly fee (without multipliers) - for display & calculations
        // Always use live route prices when amStop/pmStop exist so route edits propagate to students
        const selectedMonth = getFocusedMonth();
        const baseMonthlyFee = (amStop || pmStop)
          ? (await calculateBaseMonthlyFee(amStop, pmStop, year, selectedMonth))
          : (Number(enrollment?.baseMonthlyFee) || 0);
        const startDateIso = resolveStartDate(enrollment);
        const hasExplicitStart = Boolean(enrollment?.startDate || enrollment?.start_date || enrollment?.startTimestamp || enrollment?.start_time);

        const paymentsArray = Array.isArray(payments) ? payments : Object.values(payments || {});
        // Only approved payments count toward paid amounts (pending approvals are not recorded)
        const approvedPayments = paymentsArray.filter(p =>
          p.approved === true || p.approved === 'true' || !!p.approvedAt
        );

        const ledger = await TransportPricing.buildLedger({
          year,
          baseMonthlyFee,
          amStop,
          pmStop,
          startDate: startDateIso,
          payments: approvedPayments,
          multipliers,
        });
        const monthResults = ledger.months.map(m => ({
          month: m.month,
          expected: Number(m.due || 0),
          paid: Number(m.paid || 0),
        }));
        
        // Debt only includes months already due: payment due date is 3rd of same month; paying on/from 3rd is late.
        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonth = now.getMonth() + 1;
        const currentDay = now.getDate();
        const lastDueMonth = currentDay >= 3 ? currentMonth : Math.max(0, currentMonth - 1);
        function isMonthAlreadyDue(month) {
          if (year < currentYear) return true;
          if (year > currentYear) return false;
          return month <= lastDueMonth;
        }

        let totalExpected = 0;
        let totalPaid = 0;
        const unpaidMonths = [];
        const unpaidMonthsWithAmounts = [];
        let totalYearExpected = 0;

        monthResults.forEach(({ month, expected, paid }) => {
          totalYearExpected += expected;
          if (!isMonthAlreadyDue(month)) return;
          totalExpected += expected;
          totalPaid += paid;
          const balance = Math.max(0, expected - paid);
          if ((paid + 0.01) < expected && expected > 0) {
            unpaidMonths.push(MONTH_NAMES[month]);
            unpaidMonthsWithAmounts.push({ month, name: MONTH_NAMES[month], balance });
          }
        });

        const debt = Math.max(0, totalExpected - totalPaid);
        const totalYearDebt = Math.max(0, Number(ledger?.totals?.balance || 0));

        // Current month expected (already calculated above, reuse result)
        const currentMonthResult = monthResults.find(r => r.month === selectedMonth);
        const currentMonthExpected = currentMonthResult
          ? currentMonthResult.expected
          : Math.round(
            await TransportPricing.dueForMonth({
              year,
              month: selectedMonth,
              amStop,
              pmStop,
              baseMonthlyFee,
              startDate: startDateIso,
              multipliers,
            }) || 0
          );

        // Compact unpaid months with amounts: "Jan=114,000, Feb=76,000"
        const unpaidMonthsDisplay = unpaidMonthsWithAmounts.length
          ? unpaidMonthsWithAmounts.map(m => `${m.name.substring(0,3)}=${formatShortNum(m.balance)}`).join(', ')
          : 'None';

        const result = {
          totalExpected,
          totalPaid,
          debt,
          unpaidMonths: unpaidMonths.join(', ') || 'None',
          unpaidMonthsWithAmounts,
          unpaidMonthsDisplay,
          totalYearExpected,
          totalYearDebt,
          monthlyFee: baseMonthlyFee, // Base fee for table display (e.g., 35,500)
          currentMonthExpected, // Month-specific fee with multiplier for KPIs
          startDateIso,
          startDateDisplay: hasExplicitStart ? formatStartDateDisplay(startDateIso) : 'N/A',
        };

        // Cache the result
        if (studentId) {
          const cacheKey = getCacheKey(studentId, state.year);
          statusCache.set(cacheKey, result);
        }

        return result;
      }

      // Render KPIs - only for admin view, not parent view (now async for DB multipliers) - OPTIMIZED with parallel processing
      async function renderKPIs() {
        // Skip if parent view (stat cards already rendered by renderParentTransportPayment)
        const monthForKpi = getFocusedMonth();
        const kpiMonthLabel = MONTH_NAMES[monthForKpi] || ('Month ' + monthForKpi);
        const urlParams = new URLSearchParams(window.location.search);
        const studentParam = urlParams.get('studentKey');
        if (studentParam) {
          return; // Don't render KPIs in parent view
        }
        
        // Load year multipliers once for all calculations
        const year = Number(state.year);
        const multipliers = cachedMultipliers[year] || (await TransportPricing.loadYearMultipliers(year));
        if (!cachedMultipliers[year]) cachedMultipliers[year] = multipliers;
        
        // OPTIMIZATION: Process all students in parallel instead of sequentially with caching
        const statusPromises = Object.entries(state.transportEnrollments).map(async ([studentId, enrollment]) => {
          const payments = Object.values(state.transportPayments[studentId] || {});
          return await calculateTransportStatus(enrollment, payments, multipliers, studentId);
        });

        const allStatuses = await Promise.all(statusPromises);
        
        let totalExpected = 0;
        let totalCollected = 0;
        let totalDebt = 0;
        let criticalDebtors = 0;

        allStatuses.forEach(status => {
          // Use currentMonthExpected for KPI (includes month multiplier)
          totalExpected += status.currentMonthExpected;
          totalCollected += status.totalPaid;
          totalDebt += status.debt;
          if (status.debt > 0) criticalDebtors++;
        });

        // Calculate expenses
        const expensesArray = Object.values(state.expenses);
        const totalExpenses = expensesArray.reduce((sum, exp) => sum + (Number(exp.amount) || 0), 0);
        const fuelExp = expensesArray.filter(e => e.category === 'FUEL').reduce((sum, e) => sum + (Number(e.amount) || 0), 0);
        const maintExp = expensesArray.filter(e => e.category === 'MAINTENANCE' || e.category === 'REPAIRS').reduce((sum, e) => sum + (Number(e.amount) || 0), 0);
        const otherExp = totalExpenses - fuelExp - maintExp;

        document.getElementById('totalExpected').textContent = formatCurrency(totalExpected);
        document.getElementById('totalCollected').textContent = formatCurrency(totalCollected);
        document.getElementById('totalDebt').textContent = formatCurrency(totalDebt);
        document.getElementById('totalExpenses').textContent = formatCurrency(totalExpenses);
        document.getElementById('netBalance').textContent = formatCurrency(totalCollected - totalExpenses);
        document.getElementById('monthLabel').textContent = `${kpiMonthLabel} ${state.year}`;

        document.getElementById('fuelExpenses').textContent = formatCurrency(fuelExp);
        document.getElementById('maintenanceExpenses').textContent = formatCurrency(maintExp);
        document.getElementById('otherExpenses').textContent = formatCurrency(otherExp);

        // Critical alerts for unpaid students
        if (criticalDebtors > 0) {
          document.getElementById('criticalAlerts').innerHTML = `
            <div class="alert red" style="animation: pulse 2s infinite;">
              <strong>ALERT:</strong> ${criticalDebtors} student(s) have unpaid transport fees. 
              Payment deadline is the 3rd of each month for that same month.
            </div>
          `;
        } else {
          document.getElementById('criticalAlerts').innerHTML = '';
        }
      }

      // Render payments table (now async for DB multipliers) - OPTIMIZED with parallel processing, early filtering, and progressive rendering
      async function renderPaymentsTable() {
        const loadingIndicator = document.getElementById('loadingIndicator');
        const loadingProgress = document.getElementById('loadingProgress');
        const filterClass = classFilter.value;
        const searchTerm = searchInput.value.toLowerCase();
        const filterStatus = statusFilter.value;
        const yearDelta = state.year - BASE_YEAR;

        // Show loading indicator
        if (loadingIndicator) {
          loadingIndicator.style.display = 'block';
          paymentsBody.innerHTML = '';
        }

        // Load year multipliers once for all calculations
        const year = Number(state.year);
        const multipliers = cachedMultipliers[year] || (await TransportPricing.loadYearMultipliers(year));
        if (!cachedMultipliers[year]) cachedMultipliers[year] = multipliers;

        const allEntries = Object.entries(state.transportEnrollments);
        
        // OPTIMIZATION: Pre-filter students before expensive calculations
        const preFiltered = [];
        for (const [studentId, enrollment] of allEntries) {
          const student = getStudentForTransport(studentId, enrollment);

          // Calculate class for selected year
          const baseClass = student.classLevel || '';
          const shiftedClass = shiftClass(baseClass, yearDelta);
          
          const matchesClass = !filterClass || shiftedClass === filterClass;
          const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.toLowerCase();
          const matchesSearch = !searchTerm || 
            fullName.includes(searchTerm) || 
            (student.admissionNumber || '').toLowerCase().includes(searchTerm);

          // Only add to pre-filtered if class and search match (status and debt filters need calculation)
          if (matchesClass && matchesSearch) {
            preFiltered.push([studentId, enrollment, student, shiftedClass]);
          }
        }

        if (preFiltered.length === 0) {
          if (loadingIndicator) loadingIndicator.style.display = 'none';
          paymentsBody.innerHTML = '';
          document.getElementById('emptyState').classList.remove('hidden');
          document.getElementById('paymentSummary').textContent = '0 students found';
          return;
        }

        // Update progress
        if (loadingProgress) {
          loadingProgress.textContent = `Calculating status for ${preFiltered.length} students...`;
        }

        // OPTIMIZATION: Process in smaller batches for progressive rendering on slow connections
        const BATCH_SIZE = 20;
        const allStatuses = [];
        
        for (let i = 0; i < preFiltered.length; i += BATCH_SIZE) {
          const batch = preFiltered.slice(i, i + BATCH_SIZE);
          const statusPromises = batch.map(async ([studentId, enrollment]) => {
            const payments = Object.values(state.transportPayments[studentId] || {});
            const status = await calculateTransportStatus(enrollment, payments, multipliers, studentId);
            return [studentId, enrollment, status];
          });
          
          const batchResults = await Promise.all(statusPromises);
          allStatuses.push(...batchResults);
          
          // Update progress
          if (loadingProgress && i % (BATCH_SIZE * 2) === 0) {
            loadingProgress.textContent = `Processing ${Math.min(i + BATCH_SIZE, preFiltered.length)}/${preFiltered.length} students...`;
          }
        }
        
        // Hide loading indicator
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        
        // Apply status and debt filters after calculations
        const filtered = [];
        for (let i = 0; i < allStatuses.length; i++) {
          const [studentId, enrollment, status] = allStatuses[i];
          const [, , student, shiftedClass] = preFiltered[i];
          
          let matchesStatus = true;
          if (filterStatus === 'paid') matchesStatus = status.debt === 0;
          if (filterStatus === 'partial') matchesStatus = status.debt > 0 && status.totalPaid > 0;
          if (filterStatus === 'unpaid') matchesStatus = status.totalPaid === 0;

          const matchesDebtFilter = !state.showDebtorsOnly || status.debt > 0;

          if (matchesStatus && matchesDebtFilter) {
            filtered.push([studentId, enrollment, status]);
          }
        }

        if (filtered.length === 0) {
          paymentsBody.innerHTML = '';
          document.getElementById('emptyState').classList.remove('hidden');
          document.getElementById('paymentSummary').textContent = '0 students found';
          return;
        }

        document.getElementById('emptyState').classList.add('hidden');
        const totalTransport = allEntries.length;
        document.getElementById('paymentSummary').textContent = filtered.length === totalTransport
          ? `${filtered.length} student(s) on transport`
          : `${filtered.length} of ${totalTransport} student(s) on transport`;

        // Sort by debt (highest first)
        filtered.sort((a, b) => b[2].debt - a[2].debt);

        paymentsBody.innerHTML = filtered.map(([studentId, enrollment, transportStatus]) => {
          const student = getStudentForTransport(studentId, enrollment);
          const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
          
          const yearDelta = state.year - BASE_YEAR;
          const baseClass = student.classLevel || '';
          const shiftedClass = shiftClass(baseClass, yearDelta);
          const selectedMonth = getFocusedMonth();
          const selectedMonthName = MONTH_NAMES[selectedMonth] || 'Current';
          const startDateDisplay = transportStatus.startDateDisplay || 'N/A';
          const baseFeeDisplay = formatCurrency(transportStatus.monthlyFee);
          const currentMonthDue = transportStatus.currentMonthExpected;
          
          const driverDisplay = getDriverDisplay(enrollment);
          
          const transportDebt = transportStatus.debt;
          const isDebtor = transportDebt > 0;
          const rowClass = isDebtor ? 'style="background: rgba(239, 68, 68, 0.15); font-weight: 600;"' : '';
          const debtWarning = isDebtor ? '<span style="color: var(--accent-danger); font-weight: 800; font-size: 0.75rem;">&#9888; USIMCHUKUE ANADAIWA</span>' : '';
          
          const escapedId = String(studentId).replace(/'/g, "\\'");
          const totalYearFee = transportStatus.totalYearExpected ?? transportStatus.totalExpected;
          const totalYearDebt = transportStatus.totalYearDebt ?? transportStatus.debt;
          const unpaidDisplay = transportStatus.unpaidMonthsDisplay ?? transportStatus.unpaidMonths;
          return `
            <tr ${rowClass}>
              <td>${student.admissionNumber || 'N/A'}</td>
              <td>${fullName}${debtWarning ? '<br>' + debtWarning : ''}</td>
              <td>${shiftedClass}</td>
              <td>${student.primaryParentContact || 'N/A'}</td>
              <td>${startDateDisplay}</td>
              <td>${enrollment.amStop || '&mdash;'}</td>
              <td>${enrollment.pmStop || '&mdash;'}</td>
              <td style="font-size: 0.85rem;">${driverDisplay}</td>
              <td title="Base fee before multiplier: ${baseFeeDisplay}">
                ${formatCurrency(currentMonthDue)}<br>
                <span style="font-size: 0.7rem; color: var(--text-muted, #94a3b8);">
                  Base: ${baseFeeDisplay} &#183; ${selectedMonthName}
                </span>
              </td>
              <td style="color: var(--accent-success);">${formatCurrency(transportStatus.totalPaid)}</td>
              <td style="color: ${transportDebt > 0 ? 'var(--accent-danger)' : 'var(--accent-success)'};">
                ${formatCurrency(transportDebt)}
              </td>
              <td style="font-size: 0.7rem;" title="${transportStatus.unpaidMonths}">${unpaidDisplay}</td>
              <td style="color: ${transportDebt > 0 ? 'var(--accent-danger)' : 'var(--accent-success)'}; font-weight: 700;">
                ${formatCurrency(transportDebt)}
              </td>
              <td style="font-size: 0.75rem;">${formatCurrency(totalYearFee)}</td>
              <td style="font-size: 0.75rem;">${formatCurrency(totalYearDebt)}</td>
              <td class="table-actions" style="justify-content: flex-end;">
                <button class="btn success" data-action="pay" data-student="${escapedId}">&#128176; Pay</button>
                <button class="btn secondary" data-action="history" data-student="${escapedId}">&#128221; History</button>
              </td>
            </tr>
          `;
        }).join('');
      }

      function scrollPaymentsTable(dir) {
        const el = document.getElementById('paymentsTableScroll');
        if (!el) return;
        const amt = Math.max(360, Math.floor(el.clientWidth * 0.7));
        el.scrollBy({ left: dir * amt, behavior: 'smooth' });
      }

      // Toggle debtors only
      function toggleDebtorsOnly() {
        state.showDebtorsOnly = !state.showDebtorsOnly;
        document.getElementById('debtorsBtnText').textContent = state.showDebtorsOnly ? 'Show All' : 'Show Debtors Only';
        renderPaymentsTable();
      }

      // Open payment modal (with year-scoped multipliers)
      async function openPaymentModal(studentId) {
        state.currentPaymentStudentId = studentId;
        const enrollment = state.transportEnrollments[studentId];
        const student = getStudentForTransport(studentId, enrollment);
        
        if (!enrollment) return;
        
        const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
        const payments = Object.values(state.transportPayments[studentId] || {});
        
        // Check if we have year-scoped assignment data (parent view)
        const year = String(state.year);
        
        // Load year multipliers for accurate calculations
        const multipliers = cachedMultipliers[Number(year)] || (await TransportPricing.loadYearMultipliers(Number(year)));
        if (!cachedMultipliers[Number(year)]) cachedMultipliers[Number(year)] = multipliers;
        
        let status, baseMonthlyFee, currentMonthAmount, currentMonthLabel;
        const focusedMonth = getFocusedMonth();
        const focusedMonthLabel = MONTH_NAMES[focusedMonth] || ('Month ' + focusedMonth);
        const enrollmentStart = resolveStartDate(enrollment);

        try {
          const assignSnap = await scopedOrSocratesLegacy(`years/${year}/transportAssignments/${studentId}`, `transportAssignments/${year}/${studentId}`);
          const assign = assignSnap.val();
          
          if (assign && assign.status === 'Using') {
            baseMonthlyFee = Number(assign.baseMonthlyFee || 0) || Number(enrollment.baseMonthlyFee || 0);
            const startDate = normalizeDateInput(assign.startDate || enrollmentStart, Number(year));
        const hasAssignedStart = Boolean(assign?.startDate || assign?.start_date || assign?.startTimestamp || assign?.start_time);
            
            currentMonthLabel = focusedMonthLabel;
            currentMonthAmount = Math.round(await TransportPricing.dueForMonth({
              year: Number(year),
              month: focusedMonth,
              amStop: assign?.amStop || enrollment?.amStop,
              pmStop: assign?.pmStop || enrollment?.pmStop,
              baseMonthlyFee,
              startDate,
              multipliers // Pass year-specific multipliers
            }));
            
            const ledger = await TransportPricing.buildLedger({
              year: Number(year),
              amStop: assign?.amStop || enrollment?.amStop,
              pmStop: assign?.pmStop || enrollment?.pmStop,
              baseMonthlyFee,
              startDate,
              payments,
              multipliers // Pass year-specific multipliers
            });
            
            status = {
              monthlyFee: baseMonthlyFee,
              currentMonthExpected: currentMonthAmount,
              debt: ledger.totals.balance,
              totalExpected: ledger.totals.due,
              totalPaid: ledger.totals.paid,
              unpaidMonths: ledger.months.filter(m => m.status === 'UNPAID' || m.status === 'PARTIAL').map(m => MONTH_NAMES[m.month]).join(', ') || 'None',
              startDateIso: startDate,
              startDateDisplay: formatStartDateDisplay(startDate),
            };
          } else {
            status = await calculateTransportStatus(enrollment, payments, multipliers);
            baseMonthlyFee = status.monthlyFee;
            currentMonthLabel = focusedMonthLabel;
            currentMonthAmount = Math.round(await TransportPricing.dueForMonth({
              year: Number(year),
              month: focusedMonth,
              amStop: enrollment?.amStop,
              pmStop: enrollment?.pmStop,
              baseMonthlyFee,
              startDate: enrollmentStart,
              multipliers // Pass year-specific multipliers
            }) || status.currentMonthExpected || status.monthlyFee);
          }
        } catch (err) {
          console.warn('Error loading assignment data, using legacy:', err);
          status = await calculateTransportStatus(enrollment, payments, multipliers);
          baseMonthlyFee = status.monthlyFee;
          currentMonthLabel = focusedMonthLabel;
          currentMonthAmount = Math.round(await TransportPricing.dueForMonth({
            year: Number(year),
            month: focusedMonth,
            amStop: enrollment?.amStop,
            pmStop: enrollment?.pmStop,
            baseMonthlyFee,
            startDate: enrollmentStart,
            multipliers // Pass year-specific multipliers
          }) || status.currentMonthExpected || status.monthlyFee);
        }
        
        document.getElementById('paymentStudentInfo').innerHTML = `
          <div style="display: grid; gap: 0.5rem; font-size: 0.875rem;">
            <div><strong>Name:</strong> ${fullName}</div>
            <div><strong>Admission No:</strong> ${student.admissionNumber}</div>
            <div><strong>Class:</strong> ${student.classLevel}</div>
            <div><strong>Base Monthly Fee:</strong> ${formatCurrency(baseMonthlyFee)}</div>
            <div><strong>Current Month Fee (${currentMonthLabel || focusedMonthLabel}):</strong> ${formatCurrency(currentMonthAmount)}</div>
            <div><strong>Total Debt:</strong> <span style="color: var(--accent-danger);">${formatCurrency(status.debt)}</span></div>
            <div><strong>Unpaid Months:</strong> ${status.unpaidMonths}</div>
            <div><strong>Transport Start:</strong> ${status.startDateDisplay || formatStartDateDisplay(enrollmentStart)}</div>
          </div>
        `;
        // Set current month as default using focused context
        document.getElementById('paymentMonth').value = String(focusedMonth);
        document.getElementById('paymentAmount').value = currentMonthAmount;
        document.getElementById('paymentDate').valueAsDate = new Date();
        document.getElementById('paymentReference').value = '';
        document.getElementById('paymentPayerName').value = '';
        document.getElementById('paymentNotes').value = '';
        
        document.getElementById('paymentModal').classList.remove('hidden');
      }

      function closePaymentModal() {
        document.getElementById('paymentModal').classList.add('hidden');
        document.getElementById('paymentAlert').classList.add('hidden');
        state.currentPaymentStudentId = null;
      }

      // Save payment (enhanced: also write to canonical year path)
      async function savePayment() {
        const studentId = state.currentPaymentStudentId;
        const month = parseInt(document.getElementById('paymentMonth').value);
        const amount = parseFloat(document.getElementById('paymentAmount').value);
        const method = document.getElementById('paymentMethod').value;
        const reference = document.getElementById('paymentReference').value.trim();
        const payerName = document.getElementById('paymentPayerName').value.trim();
        const paymentDate = document.getElementById('paymentDate').value;
        const notes = document.getElementById('paymentNotes').value.trim();
        
        // Validate all mandatory fields
        if (!month || !amount || amount <= 0 || !method || !reference || !payerName || !paymentDate) {
          showToast('Please fill in ALL required fields (Month, Amount, Method, Reference, Payer Name, Payment Date)', 'bad');
          return;
        }
        
        try {
          const enrollment = state.transportEnrollments[studentId];
          const student = getStudentForTransport(studentId, enrollment);
          if (!enrollment) throw new Error('Student transport enrollment not found.');
          const payments = Object.values(state.transportPayments[studentId] || {});
          const multipliers = cachedMultipliers[Number(state.year)] || (await TransportPricing.loadYearMultipliers(Number(state.year)));
          if (!cachedMultipliers[Number(state.year)]) cachedMultipliers[Number(state.year)] = multipliers;
          const status = await calculateTransportStatus(enrollment, payments, multipliers);
          const recorder = resolveRecorder();
          // Convert payment date to timestamp (local timezone - Africa/Nairobi)
          const paidAt = new Date(paymentDate + 'T12:00:00').getTime();
          const timestamp = Date.now();
          const pendingRef = schoolRef('approvalsPending').push();
          const monthName = MONTH_NAMES[month] || `Month ${month}`;
          const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.replace(/\s+/g, ' ').trim();
          const totalRequired = Number(status.totalExpected || 0);
          const totalPaidBefore = Number(status.totalPaid || 0);
          const newBalance = Math.max(0, totalRequired - Math.min(totalRequired, totalPaidBefore + amount));

          // Also write to transport ledger as pending (for parent view and history)
          const yearStr = String(state.year);
          const payRef = schoolRef(`years/${yearStr}/transportLedgers/${studentId}/payments`).push();
          
          const paymentData = {
            month: monthName,
            amount,
            method,
            ref: reference,
            payerName,
            paidAt,
            notes: notes || null,
            createdBy: state.user ? 'parent' : 'staff',
            createdByUid: state.user?.uid || null,
            approved: false,
            approvedBy: null,
            approvedAt: null,
            timestamp
          };
          
          await payRef.set(paymentData);

          // Canonical write: transportPayments/{year}/{studentId}/{paymentId}
          const canonical = {
            month,
            amount,
            method,
            reference,
            payerName,
            paidAt,
            notes: notes || '',
            status: 'pending',
            createdAt: timestamp
          };
          await schoolRef(`years/${yearStr}/transportPayments/${studentId}`).push(canonical);
          
          // Queue for approval - include payment key for matching
          const queueRef = schoolRef(`pendingApprovals/transportPayments/${payRef.key}`);
          await queueRef.set({
            year: yearStr,
            studentId,
            admissionNumber: student.admissionNumber || studentId,
            studentName: fullName,
            parentPhone: student.primaryParentContact || student.primaryContact || student.guardianPhone || '--',
            paymentRef: payRef.key, // Store the ledger payment key for approval matching
            ...paymentData,
            queuedAt: timestamp
          });

          // Legacy approval queue (keep for backward compatibility)
          await pendingRef.set({
            approvalId: pendingRef.key,
            sourceModule: 'transport',
            studentAdm: student.admissionNumber || studentId,
            studentName: fullName || (student.admissionNumber || studentId),
            className: student.classLevel || '',
            parentContact: student.primaryParentContact || student.primaryContact || student.guardianPhone || '--',
            amountPaidNow: amount,
            paymentMethod: method,
            paymentReferenceCode: reference,
            payerName: payerName,
            paymentDate: paymentDate,
            datePaid: paidAt,
            recordedBy: recorder,
            status: 'pending',
            notes,
            totalRequired,
            totalPaidBefore,
            newBalanceAfterThis: newBalance,
            createdAt: firebase.database.ServerValue.TIMESTAMP,
            paymentRef: payRef.key,
            modulePayload: {
              studentKey: studentId,
              paymentRef: payRef.key,
              payment: {
                studentId,
                month,
                year: state.year,
                amount,
                method,
                reference,
                payerName,
                paidAt,
                notes,
                timestamp,
                recordedBy: recorder,
              },
              breakdown: [
                { label: 'Month', value: monthName },
                { label: 'Year', value: state.year },
                { label: 'Route', value: `` },
                { label: 'Expected (Year)', value: formatCurrency(status.totalExpected) },
                { label: 'Paid Before', value: formatCurrency(status.totalPaid) },
                { label: 'Debt Before', value: formatCurrency(status.debt) },
              ],
            },
          });

          showToast('Payment pending admin approval.', 'ok');
          closePaymentModal();
          
          // Refresh based on view mode
          const urlParams = new URLSearchParams(window.location.search);
          const studentParam = urlParams.get('studentKey') || urlParams.get('student');
          if (studentParam) {
            // Single-student view - reload that student only
            renderYearScopedStudentView(studentParam);
          } else {
            // Admin view - reload all data
            loadAllData();
          }
        } catch (error) {
          console.error('Error saving payment:', error);
          showToast('Failed to save payment', 'bad');
        }
      }

      // View payment history - with real-time approval status
      async function viewPaymentHistory(studentId) {
        state.currentHistoryStudentId = studentId;
        const student = getStudentForTransport(studentId, state.transportEnrollments[studentId]);
        
        // Load transport assignment to get start date
        const year = String(state.year);
        try {
          const assignSnap = await scopedOrSocratesLegacy(`years/${year}/transportAssignments/${studentId}`, `transportAssignments/${year}/${studentId}`);
          const assign = assignSnap.val();
          const rawStart = assign?.startDate || assign?.start_date || assign?.startTimestamp || assign?.start_time;
          if (rawStart) {
            const normalized = normalizeDateInput(rawStart, Number(year));
            document.getElementById('historyStartDateValue').textContent = formatStartDateDisplay(normalized);
            document.getElementById('historyStartDateInfo').style.display = 'block';
          } else {
            document.getElementById('historyStartDateInfo').style.display = 'none';
          }
        } catch (err) {
          console.warn('Error loading start date:', err);
          document.getElementById('historyStartDateInfo').style.display = 'none';
        }
        
        let payments = state.transportPayments[studentId] || {};
        
        // Handle array or object format
        if (Array.isArray(payments)) {
          payments = payments.sort((a, b) => (b.timestamp || b.paidAt || 0) - (a.timestamp || a.paidAt || 0));
        } else if (payments && typeof payments === 'object') {
          payments = Object.values(payments).sort((a, b) => (b.timestamp || b.paidAt || 0) - (a.timestamp || a.paidAt || 0));
        } else {
          payments = [];
        }

        // Fallback: if no payments in state, fetch approved from history (fixes "History still nothing")
        if (payments.length === 0) {
          try {
            const history = await fetchApprovalsHistoryForYear(year);
            const admissionNo = (student && (student.admissionNumber || student.admissionNo)) || '';
            const studentMatches = (r) => {
              if (!r || r.sourceModule !== 'transport') return false;
              const key = r.modulePayload?.studentKey;
              const adm = r.studentAdm || r.admissionNumber || r.modulePayload?.admissionNumber;
              return key === studentId || adm === studentId || adm === admissionNo || key === admissionNo;
            };
            Object.values(history).forEach(monthRecords => {
              Object.values(monthRecords || {}).forEach(record => {
                if (!record || record.finalStatus !== 'approved' || !studentMatches(record)) return;
                const pmt = record.modulePayload?.payment;
                const ref = record.paymentReferenceCode || pmt?.reference || pmt?.ref;
                if (!ref || !pmt) return;
                const monthNum = typeof pmt.month === 'number' ? pmt.month : (MONTH_NAMES.indexOf(pmt.month) >= 1 ? MONTH_NAMES.indexOf(pmt.month) : new Date(record.datePaid || record.createdAt || Date.now()).getMonth() + 1);
                payments.push({
                  amount: record.amountPaidNow ?? pmt.amount,
                  method: record.paymentMethod ?? pmt.method,
                  ref, reference: ref,
                  payerName: record.payerName ?? pmt.payerName,
                  paidAt: record.datePaid ?? pmt.paidAt ?? record.createdAt,
                  timestamp: record.createdAt ?? pmt.timestamp,
                  month: monthNum,
                  notes: record.notes ?? pmt.notes ?? '',
                  approved: true,
                  approvedAt: record.approvedAt,
                  approvedBy: record.approvedBy
                });
              });
            });
            payments = payments.sort((a, b) => (b.timestamp || b.paidAt || 0) - (a.timestamp || a.paidAt || 0));
          } catch (err) {
            console.warn('Fallback fetch approvals for history:', err);
          }
        }
        
        // Also check pendingApprovals to get latest approval status
        try {
          const pendingSnap = await schoolRef('pendingApprovals/transportPayments').once('value');
          const pendingApprovals = pendingSnap.val() || {};
          
          // Create a map of payment keys to approval status
          const approvalMap = {};
          Object.entries(pendingApprovals).forEach(([key, approval]) => {
            if (approval && approval.studentId === studentId && approval.ref) {
              // Match by reference code for accurate matching
              approvalMap[approval.ref] = {
                approved: false,
                pending: true
              };
            }
          });
          
          // Also check approvalsHistory for approved payments (all paths)
          const year = String(state.year);
          const admissionNo = (student && (student.admissionNumber || student.admissionNo)) || '';
          const history = await fetchApprovalsHistoryForYear(year);
          const studentMatches = (r) => {
            if (!r || r.sourceModule !== 'transport') return false;
            const key = r.modulePayload?.studentKey;
            const adm = r.studentAdm || r.admissionNumber || r.modulePayload?.admissionNumber;
            return key === studentId || adm === studentId || adm === admissionNo || key === admissionNo;
          };
          Object.values(history).forEach(monthRecords => {
            Object.values(monthRecords || {}).forEach(record => {
              if (studentMatches(record)) {
                const ref = record.paymentReferenceCode || record.modulePayload?.payment?.reference || record.modulePayload?.payment?.ref;
                if (ref) {
                  approvalMap[ref] = {
                    approved: record.finalStatus === 'approved',
                    pending: false
                  };
                }
              }
            });
          });
          
          // Update payment approval status from map
          payments = payments.map(p => {
            const ref = p.ref || p.reference;
            if (ref && approvalMap[ref]) {
              return {
                ...p,
                approved: approvalMap[ref].approved ? true : (p.approved || false)
              };
            }
            return p;
          });
        } catch (err) {
          console.warn('Error checking approval status:', err);
        }

        // Keep an approved-aware snapshot for Payment Schedule + PDF allocation
        state.currentHistoryResolvedPayments = Array.isArray(payments)
          ? payments.slice()
          : Object.values(payments || {});
        
        const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
        const admissionNo = student.admissionNumber || 'N/A';
        
        // Update modal title
        document.getElementById('historyModalTitle').textContent = `Payment History - ${fullName} (${admissionNo})`;
        
        const historyBody = document.getElementById('historyBody');
        const historyEmpty = document.getElementById('historyEmpty');
        
        if (payments.length === 0) {
          historyBody.innerHTML = '';
          historyEmpty.classList.remove('hidden');
        } else {
          historyEmpty.classList.add('hidden');
          historyBody.innerHTML = payments.map(p => {
            // Check approval status more thoroughly
            const isApproved = p.approved === true || p.approved === 'true' || p.approvedAt || (p.approvedBy && !p.approvedBy.includes('pending'));
            const statusBadge = isApproved 
              ? '<span class="chip ok" style="background: rgba(16, 185, 129, 0.15); color: #86efac; border: 1px solid rgba(16, 185, 129, 0.35); padding: 0.25rem 0.75rem; border-radius: 999px; font-size: 0.75rem; font-weight: 700;">Paid</span>'
              : '<span class="chip warn" style="background: rgba(245, 158, 11, 0.15); color: #fcd34d; border: 1px solid rgba(245, 158, 11, 0.35); padding: 0.25rem 0.75rem; border-radius: 999px; font-size: 0.75rem; font-weight: 700;">Pending</span>';
            
            const d = p.paidAt ? new Date(p.paidAt).toLocaleDateString('en-GB') : (p.timestamp ? new Date(p.timestamp).toLocaleDateString('en-GB') : '-');
            const monthName = typeof p.month === 'number' ? MONTH_NAMES[p.month] : (p.month || '-');
            const rowColor = isApproved ? 'style="background: rgba(16, 185, 129, 0.05);"' : 'style="background: rgba(245, 158, 11, 0.05);"';
            
            return `<tr ${rowColor}>
              <td style="font-weight: 600;">${d}</td>
              <td>${monthName}</td>
              <td style="color: var(--accent-success); font-weight: 700;">${formatCurrency(p.amount || 0)}</td>
              <td>${p.method || '-'}</td>
              <td style="font-family: monospace; font-size: 0.875rem;">${p.ref || p.reference || '-'}</td>
              <td>${p.payerName || '-'}</td>
              <td>${statusBadge}</td>
              <td style="font-size: 0.875rem; color: var(--text-secondary);">${p.notes || '-'}</td>
            </tr>`;
          }).join('');
        }
        
        document.getElementById('historyModal').classList.remove('hidden');
      }
      
      function closeHistoryModal() {
        document.getElementById('historyModal').classList.add('hidden');
      }

      // Payment Schedule Modal (Taarifa ya Malipo)
      let paymentScheduleLedger = null;
      let paymentScheduleStudent = null;
      let paymentScheduleStudentId = null;

      async function openPaymentScheduleModal() {
        const studentId = state.currentHistoryStudentId;
        if (!studentId) return;
        const enrollment = state.transportEnrollments[studentId];
        const student = getStudentForTransport(studentId, enrollment);
        const isApprovedPayment = (p) => (
          p && (
            p.approved === true ||
            p.approved === 'true' ||
            !!p.approvedAt ||
            (typeof p.approvedBy === 'string' && !p.approvedBy.toLowerCase().includes('pending'))
          )
        );
        const historyResolved = (
          state.currentHistoryStudentId === studentId &&
          Array.isArray(state.currentHistoryResolvedPayments)
        ) ? state.currentHistoryResolvedPayments : [];
        const statePayments = Object.values(state.transportPayments[studentId] || {});
        const allPayments = historyResolved.length ? historyResolved : statePayments;
        const payments = allPayments.filter(isApprovedPayment);
        const year = Number(state.year);
        const multipliers = cachedMultipliers[year] || (await TransportPricing.loadYearMultipliers(year));
        if (!cachedMultipliers[year]) cachedMultipliers[year] = multipliers;
        const amStop = enrollment?.amStop || '';
        const pmStop = enrollment?.pmStop || '';
        const baseMonthlyFee = (amStop || pmStop)
          ? (await calculateBaseMonthlyFee(amStop, pmStop, year, getFocusedMonth()))
          : (Number(enrollment?.baseMonthlyFee) || 0);
        const startDate = resolveStartDate(enrollment);
        const ledger = await TransportPricing.buildLedger({ year, baseMonthlyFee, amStop, pmStop, startDate, payments, multipliers });
        paymentScheduleLedger = ledger;
        paymentScheduleStudent = student;
        paymentScheduleStudentId = studentId;
        const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
        document.getElementById('paymentScheduleStudentInfo').innerHTML = `<strong>${fullName}</strong> (${student.admissionNumber || studentId}) &middot; Year ${year}`;
        const tbody = document.getElementById('paymentScheduleBody');
        const now = new Date();
        const currentMonth = now.getMonth() + 1;
        const currentDay = now.getDate();
        const lastDueMonth = currentDay >= 3 ? currentMonth : Math.max(0, currentMonth - 1);
        tbody.innerHTML = ledger.months.map(m => {
          const isDue = m.month <= lastDueMonth;
          const rowStyle = m.status === 'UNPAID' || m.status === 'PARTIAL' ? 'background: rgba(239, 68, 68, 0.1);' : (m.status === 'PAID' ? 'background: rgba(16, 185, 129, 0.08);' : '');
          return `<tr style="${rowStyle}">
            <td>Mkupuo wa ${m.month} - ${MONTH_NAMES[m.month]}</td>
            <td>${formatCurrency(m.due)}</td>
            <td style="color: var(--accent-success);">${formatCurrency(m.paid)}</td>
            <td style="color: ${m.balance > 0 ? 'var(--accent-danger)' : 'inherit'};">${formatCurrency(m.balance)}</td>
          </tr>`;
        }).join('');
        const totals = ledger.totals;
        document.getElementById('paymentScheduleTotals').innerHTML = `
          <div style="display: grid; gap: 0.5rem;">
            <div style="display: flex; justify-content: space-between;"><span>Ada ya usafiri kwa mwaka (Total Year Transport Fee):</span><strong>${formatCurrency(totals.due)}</strong></div>
            <div style="display: flex; justify-content: space-between;"><span>Ada uliolipa hadi sasa (Total Paid):</span><strong style="color: var(--accent-success);">${formatCurrency(totals.paid)}</strong></div>
            <div style="display: flex; justify-content: space-between;"><span>Ada unaodaiwa hadi leo (Debt to Date):</span><strong style="color: var(--accent-danger);">${formatCurrency(totals.balance)}</strong></div>
          </div>
        `;
        document.getElementById('paymentScheduleModal').classList.remove('hidden');
      }

      function closePaymentScheduleModal() {
        document.getElementById('paymentScheduleModal').classList.add('hidden');
      }

      async function downloadPaymentSchedulePdf() {
        if (!paymentScheduleLedger || !paymentScheduleStudent) return;
        const student = paymentScheduleStudent;
        const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
        const year = state.year;
        const today = new Date().toLocaleDateString('sw-TZ', { day: 'numeric', month: 'long', year: 'numeric' });
        const ledger = paymentScheduleLedger;
        const currentMonth = new Date().getMonth() + 1;
        const monthsToDate = ledger.months.filter(m => m.month <= currentMonth);
        const debtToDate = monthsToDate.reduce((s, m) => s + m.balance, 0);
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
        const margin = 14;
        let y = 18;
        try {
          const sid = window.SOMAP?.getSchool?.()?.id || '';
          let logoDataUrl = null;
          if (sid) {
            const logoSnap = await db.ref(`schools/${sid}/profile/logoUrl`).once('value');
            const logoUrl = logoSnap.val();
            if (logoUrl) {
              const img = await fetch(logoUrl).then(r => r.blob());
              const reader = new FileReader();
              logoDataUrl = await new Promise((res, rej) => {
                reader.onload = () => res(reader.result);
                reader.onerror = rej;
                reader.readAsDataURL(img);
              });
            }
          }
          if (!logoDataUrl && isSocratesSchool()) {
            const socratesPaths = ['../images/socrates_logo.png', '../images/socrates-school-logo.png', '../images/socrates-logo.png'];
            for (const p of socratesPaths) {
              try {
                const img = await fetch(p).then(r => r.blob());
                const reader = new FileReader();
                logoDataUrl = await new Promise((res, rej) => {
                  reader.onload = () => res(reader.result);
                  reader.onerror = rej;
                  reader.readAsDataURL(img);
                });
                if (logoDataUrl) break;
              } catch (_) {}
            }
          }
          if (logoDataUrl) {
            doc.addImage(logoDataUrl, 'PNG', margin, y - 4, 24, 24);
          }
        } catch (_) {}
        doc.setFontSize(18);
        doc.text(schoolName || 'School', margin + 28, y + 6);
        y += 16;
        doc.setFontSize(12);
        doc.text('Taarifa ya Malipo ya Usafiri - Transport Payment Schedule', margin, y);
        y += 10;
        const letterText = `Ndugu Mzazi wa ${fullName}, naomba leo tarehe ${today} upokee taarifa ya mwanao kuhusu malipo yake ya mwaka ${year}. Angalia kwa makini.

Kumbuka, ada ya usafiri tunalipa kwa mwaka ambapo tumeigawanya kwa mikupuo kumi. Mkupuo wa kwanza ni January, wa pili February, wa tatu March, n.k.`;
        const lines = doc.splitTextToSize(letterText, 180);
        doc.setFontSize(10);
        doc.text(lines, margin, y);
        y += lines.length * 5 + 8;
        doc.autoTable({
          startY: y,
          head: [['Mkupuo / Month', 'Inatarajiwa / Expected', 'Imelipwa / Paid', 'Salio / Balance']],
          body: ledger.months.map(m => [MONTH_NAMES[m.month], formatCurrency(m.due), formatCurrency(m.paid), formatCurrency(m.balance)]),
          theme: 'grid',
          margin: { left: margin },
          styles: { fontSize: 9 },
        });
        y = doc.lastAutoTable.finalY + 10;
        doc.setFontSize(10);
        doc.text(`Ada ya usafiri kwa mwaka (Total Year): ${formatCurrency(ledger.totals.due)}`, margin, y);
        y += 6;
        doc.text(`Ada uliolipa hadi sasa (Total Paid): ${formatCurrency(ledger.totals.paid)}`, margin, y);
        y += 6;
        doc.text(`Ada unaodaiwa hadi leo (Debt to Date): ${formatCurrency(ledger.totals.balance)}`, margin, y);
        y += 14;
        doc.text('_________________________', margin, y);
        y += 6;
        doc.text('Headteacher signature', margin, y);
        doc.text(`Date: ${today}`, margin, y + 6);
        doc.save(`Taarifa_Malipo_Usafiri_${fullName.replace(/\s+/g, '_')}_${year}.pdf`);
        showToast('PDF downloaded!');
      }

      // Add expense
      async function addExpense() {
        const category = document.getElementById('expenseCategory').value;
        const amount = parseFloat(document.getElementById('expenseAmount').value);
        const description = document.getElementById('expenseDescription').value;
        
        if (!category || !amount || amount <= 0 || !description) {
          showToast('Please fill in all fields', 'bad');
          return;
        }
        
        try {
          const expense = {
            category,
            amount,
            description,
            timestamp: Date.now(),
            addedBy: state.user.uid,
            year: state.year,
          };
          
          await schoolRef(`years/${state.year}/transport_expenses`).push(expense);
          
          showToast('Expense added successfully!');
          document.getElementById('expenseCategory').value = '';
          document.getElementById('expenseAmount').value = '';
          document.getElementById('expenseDescription').value = '';
          loadAllData();
        } catch (error) {
          console.error('Error adding expense:', error);
          showToast('Failed to add expense', 'bad');
        }
      }

      // Render expenses table
      function renderExpensesTable() {
        const expensesBody = document.getElementById('expensesBody');
        const expenses = Object.values(state.expenses)
          .filter(exp => exp.year == state.year)
          .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        
        if (expenses.length === 0) {
          expensesBody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 2rem;">No expenses recorded</td></tr>';
          return;
        }
        
        expensesBody.innerHTML = expenses.map(exp => `
          <tr>
            <td>${formatDate(exp.timestamp)}</td>
            <td><span class="chip ${exp.category === 'FUEL' ? 'warn' : exp.category === 'MAINTENANCE' ? 'info' : 'ok'}">${exp.category}</span></td>
            <td>${exp.description}</td>
            <td>${formatCurrency(exp.amount)}</td>
            <td>${exp.addedBy || '-'}</td>
          </tr>
        `).join('');
      }

      // Export to Excel - same columns as UI, summary rows at top, column widths and numeric formatting
      async function exportToExcel() {
        const yearNum = Number(state.year);
        const multipliers = cachedMultipliers[yearNum] || (await TransportPricing.loadYearMultipliers(yearNum));
        if (!cachedMultipliers[yearNum]) cachedMultipliers[yearNum] = multipliers;
        
        const yearDelta = state.year - BASE_YEAR;
        const data = await Promise.all(Object.entries(state.transportEnrollments).map(async ([studentId, enrollment]) => {
          const student = getStudentForTransport(studentId, enrollment);
          const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
          const baseClass = student.classLevel || '';
          const shiftedClass = shiftClass(baseClass, yearDelta);
          const payments = Object.values(state.transportPayments[studentId] || {});
          const transportStatus = await calculateTransportStatus(enrollment, payments, multipliers, studentId);
          const driverDisplay = getDriverDisplay(enrollment).replace('&mdash;', '');
          const unpaidDisp = transportStatus.unpaidMonthsDisplay ?? transportStatus.unpaidMonths;
          const totalYearFee = transportStatus.totalYearExpected ?? transportStatus.totalExpected;
          const totalYearDebt = transportStatus.totalYearDebt ?? transportStatus.debt;
          return {
            'Admission No': student.admissionNumber || studentId,
            'Full Name': fullName,
            'Class': shiftedClass,
            'Parent Contact': student.primaryParentContact || '',
            'Transport Start Date': transportStatus.startDateDisplay,
            'Route (Morning)': enrollment.amStop || enrollment.morningRouteId || '',
            'Route (Evening)': enrollment.pmStop || enrollment.eveningRouteId || '',
            'Driver': driverDisplay,
            'Current Month Transport Fee': transportStatus.currentMonthExpected,
            'Transport Paid': transportStatus.totalPaid,
            'Transport Debt (TO DATE)': transportStatus.debt,
            'Unpaid Months (TO DATE)': unpaidDisp,
            'Total Combined Debt': transportStatus.debt,
            'Total Year Fee': totalYearFee,
            'Total Year Debt': totalYearDebt,
          };
        }));
        
        const filteredData = data.filter(Boolean);
        let totalExpected = 0, totalPaid = 0, totalDebt = 0;
        let maxDebt = 0, minDebt = 0;
        filteredData.forEach(row => {
          const fee = Number(row['Current Month Transport Fee']) || 0;
          const paid = Number(row['Transport Paid']) || 0;
          const debt = Number(row['Transport Debt (TO DATE)']) || 0;
          totalExpected += fee;
          totalPaid += paid;
          totalDebt += debt;
          if (debt > maxDebt) maxDebt = debt;
          if (minDebt === 0 || (debt > 0 && debt < minDebt)) minDebt = debt || minDebt;
        });
        const paidCount = filteredData.filter(r => (Number(r['Transport Debt (TO DATE)']) || 0) === 0).length;
        const unpaidCount = filteredData.length - paidCount;

        const emptyRow = { 'Admission No': '', 'Full Name': '', 'Class': '', 'Parent Contact': '', 'Transport Start Date': '', 'Route (Morning)': '', 'Route (Evening)': '', 'Driver': '', 'Current Month Transport Fee': '', 'Transport Paid': '', 'Transport Debt (TO DATE)': '', 'Unpaid Months (TO DATE)': '', 'Total Combined Debt': '', 'Total Year Fee': '', 'Total Year Debt': '' };
        const summaryRows = [
          { ...emptyRow, 'Admission No': 'Report: Transport Payments', 'Full Name': schoolName, 'Transport Start Date': `Year: ${state.year}` },
          { ...emptyRow, 'Admission No': 'Total Expected (current month)', 'Current Month Transport Fee': totalExpected },
          { ...emptyRow, 'Admission No': 'Total Collected', 'Transport Paid': totalPaid },
          { ...emptyRow, 'Admission No': 'Total Transport Debt', 'Transport Debt (TO DATE)': totalDebt },
          { ...emptyRow, 'Admission No': 'Students fully paid', 'Full Name': paidCount },
          { ...emptyRow, 'Admission No': 'Students with debt', 'Full Name': unpaidCount },
        ];
        const combinedData = [...summaryRows, {}, ...filteredData];
        const ws = XLSX.utils.json_to_sheet(combinedData);
        const colWidths = [14, 22, 14, 16, 14, 18, 18, 28, 12, 12, 12, 20, 16, 14, 14];
        ws['!cols'] = colWidths.map(w => ({ wch: Math.min(w, 50) }));
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Transport Payments');
        XLSX.writeFile(wb, `transport_payments_${state.year}.xlsx`);
        showToast('Export successful!');
      }

      async function exportToPDF() {
        const yearNum = Number(state.year);
        const multipliers = cachedMultipliers[yearNum] || (await TransportPricing.loadYearMultipliers(yearNum));
        if (!cachedMultipliers[yearNum]) cachedMultipliers[yearNum] = multipliers;
        const yearDelta = state.year - BASE_YEAR;
        const rows = await Promise.all(Object.entries(state.transportEnrollments).map(async ([studentId, enrollment]) => {
          const student = getStudentForTransport(studentId, enrollment);
          const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
          const shiftedClass = shiftClass(student.classLevel || '', yearDelta);
          const payments = Object.values(state.transportPayments[studentId] || {});
          const transportStatus = await calculateTransportStatus(enrollment, payments, multipliers, studentId);
          const driverDisplay = getDriverDisplay(enrollment).replace('&mdash;', '');
          const unpaidDisp = transportStatus.unpaidMonthsDisplay ?? transportStatus.unpaidMonths;
          const totalYearFee = transportStatus.totalYearExpected ?? transportStatus.totalExpected;
          const totalYearDebt = transportStatus.totalYearDebt ?? transportStatus.debt;
          return [
            student.admissionNumber || studentId,
            fullName,
            shiftedClass,
            student.primaryParentContact || '',
            transportStatus.startDateDisplay,
            enrollment.amStop || '',
            enrollment.pmStop || '',
            driverDisplay,
            String(transportStatus.currentMonthExpected),
            String(transportStatus.totalPaid),
            String(transportStatus.debt),
            unpaidDisp,
            String(transportStatus.debt),
            String(totalYearFee),
            String(totalYearDebt),
          ];
        }));
        let totalExpected = 0, totalPaid = 0, totalDebt = 0, maxDebt = 0, maxDebtName = '', paidCount = 0;
        rows.forEach((r) => {
          const fee = Number(r[8]) || 0, paid = Number(r[9]) || 0, debt = Number(r[10]) || 0;
          totalExpected += fee; totalPaid += paid; totalDebt += debt;
          if (debt > maxDebt) { maxDebt = debt; maxDebtName = r[1]; }
          if (debt === 0) paidCount++;
        });
        const unpaidCount = rows.length - paidCount;
        const minDebtRow = rows.filter(r => (Number(r[10]) || 0) > 0).sort((a, b) => (Number(a[10]) || 0) - (Number(b[10]) || 0))[0];
        const leastDebt = minDebtRow ? (Number(minDebtRow[10]) || 0) : 0;
        const leastDebtName = minDebtRow ? minDebtRow[1] : '';

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
        const pageW = doc.internal.pageSize.getWidth();
        let y = 18;
        try {
          const sid = window.SOMAP?.getSchool?.()?.id || '';
          let logoDataUrl = null;
          if (sid) {
            const logoSnap = await db.ref(`schools/${sid}/profile/logoUrl`).once('value');
            const logoUrl = logoSnap.val();
            if (logoUrl) {
              const img = await fetch(logoUrl).then(r => r.blob());
              const reader = new FileReader();
              logoDataUrl = await new Promise((res, rej) => {
                reader.onload = () => res(reader.result);
                reader.onerror = rej;
                reader.readAsDataURL(img);
              });
            }
          }
          if (!logoDataUrl && isSocratesSchool()) {
            const socratesPaths = ['../images/socrates_logo.png', '../images/socrates-school-logo.png', '../images/socrates-logo.png'];
            for (const p of socratesPaths) {
              try {
                const img = await fetch(p).then(r => r.blob());
                const reader = new FileReader();
                logoDataUrl = await new Promise((res, rej) => {
                  reader.onload = () => res(reader.result);
                  reader.onerror = rej;
                  reader.readAsDataURL(img);
                });
                if (logoDataUrl) break;
              } catch (_) {}
            }
          }
          if (logoDataUrl) {
            doc.addImage(logoDataUrl, 'PNG', 14, y - 4, 24, 24);
          }
        } catch (_) {}
        doc.setFontSize(10);
        y += 10;
        doc.setFontSize(16);
        doc.text(schoolName || 'School', 42, y);
        y += 8;
        doc.setFontSize(14);
        doc.text('Transport Payments Report', 14, y);
        y += 6;
        doc.setFontSize(10);
        doc.text('Generated: ' + new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' }), 14, y);
        y += 12;

        doc.autoTable({
          startY: y,
          head: [['Metric', 'Value']],
          body: [
            ['Total Expected (current month)', formatCurrency(totalExpected)],
            ['Total Collected', formatCurrency(totalPaid)],
            ['Total Transport Debt', formatCurrency(totalDebt)],
            ['Students fully paid', String(paidCount)],
            ['Students with debt', String(unpaidCount)],
            ['Highest debt', maxDebtName ? `${formatCurrency(maxDebt)} (${maxDebtName})` : formatCurrency(maxDebt)],
            ['Lowest debt (among debtors)', leastDebtName ? `${formatCurrency(leastDebt)} (${leastDebtName})` : (leastDebt ? formatCurrency(leastDebt) : 'N/A')],
          ],
          theme: 'grid',
          margin: { left: 14 },
        });
        y = doc.lastAutoTable.finalY + 10;

        doc.setFontSize(10);
        const p1 = 'This report summarizes transport fee payments and outstanding debt for the selected academic year. Debt is calculated only for months whose payment due date (the 3rd of the same month) has already passed; future months are not included. Partial payments are reflected so that any shortfall between expected and paid amount for a due month counts as debt.';
        const p2 = 'Payment deadline is the 3rd of each month for that same month. Payments made on or after the 3rd are considered late. The table below lists each student on transport with their routes, driver, current month fee, amount paid to date, transport debt to date, and unpaid months. Use this report for reconciliation and follow-up with parents.';
        const lineH = 5;
        const lines1 = doc.splitTextToSize(p1, pageW - 28);
        doc.text(lines1, 14, y);
        y += lines1.length * lineH + 6;
        const lines2 = doc.splitTextToSize(p2, pageW - 28);
        doc.text(lines2, 14, y);
        y += lines2.length * lineH + 8;

        const colHeaders = ['Admission No', 'Full Name', 'Class', 'Parent Contact', 'Transport Start', 'Route (AM)', 'Route (PM)', 'Driver', 'Curr. Month Fee', 'Transport Paid', 'Transport Debt', 'Unpaid Months', 'Total Debt', 'Total Year Fee', 'Total Year Debt'];
        doc.addPage('a4', 'l');
        const tablePageW = 297 - 28;
        const colW = [16, 30, 14, 20, 16, 20, 20, 28, 14, 14, 14, 24, 14, 14, 14];
        const colStyles = {};
        colW.forEach((w, i) => { colStyles[i] = { cellWidth: w, overflow: 'linebreak', minCellHeight: 6 }; });
        doc.autoTable({
          startY: 14,
          head: [colHeaders],
          body: rows,
          theme: 'grid',
          margin: { left: 14 },
          styles: { fontSize: 8, cellPadding: 2 },
          columnStyles: colStyles,
          headStyles: { fontSize: 8, cellPadding: 2 },
          tableWidth: tablePageW,
          showHead: 'everyPage',
        });
        doc.addPage('a4', 'p');
        doc.setFontSize(10);
        doc.text('_________________________', 14, 36);
        doc.text('Headteacher signature', 14, 42);
        doc.text('Date: _________________________', 14, 48);

        doc.save(`transport_payments_${state.year}.pdf`);
        showToast('PDF downloaded!');
      }

      document.getElementById('exportPdfBtn').addEventListener('click', function() {
        exportToPDF().catch(err => { console.error(err); showToast('PDF export failed', 'bad'); });
      });

      // Cache for calculated statuses to avoid recalculation
      const statusCache = new Map();
      const getCacheKey = (studentId, year) => `${studentId}_${year}`;

      function normalizePaymentList(data) {
        if (!data) return [];
        if (Array.isArray(data)) return data;
        if (typeof data === 'object') return Object.values(data);
        return [data];
      }

      function filterLegacyPaymentsByYear(data, year) {
        const yearNum = Number(year);
        return normalizePaymentList(data).filter((p) => Number(p?.year) === yearNum);
      }

      async function readSupplementalPayments(year, studentId) {
        let scopedSnap = null;
        try {
          scopedSnap = await schoolRef(`years/${year}/transport_payments/${studentId}`).once('value');
        } catch (err) {
          scopedSnap = null;
        }
        const scopedVal = scopedSnap?.val();
        const scopedEmpty = !scopedSnap?.exists() ||
          (scopedVal && typeof scopedVal === 'object' && Object.keys(scopedVal).length === 0);
        if (!scopedEmpty && scopedVal) {
          return normalizePaymentList(scopedVal);
        }
        if (isSocratesSchool()) {
          try {
            const legacySnap = await db.ref(`transport_payments/${studentId}`).once('value');
            return filterLegacyPaymentsByYear(legacySnap.val(), year);
          } catch (err) {
            return [];
          }
        }
        return [];
      }

      // Load all data - ULTRA-OPTIMIZED: Load only transport students, progressive loading
      async function loadAllData() {
        try {
          showToast('Loading transport data...', 'ok');
          const year = String(state.year);
          
          // STEP 1: Load and merge transport sources exactly like transport hub
          const isLegacyMerge = isSocratesSchool();
          const legacyBusesPaths = isLegacyMerge ? [
            `transport/socrates-school/${year}/buses`,
            `transport/socrates/${year}/buses`
          ] : [];
          const [
            enrollScopedSnap,
            enrollLegacySnap,
            registryScopedSnap,
            registryLegacySnap,
            assignmentsScopedSnap,
            assignmentsLegacySnap,
            vehiclesSnap,
            workersSnap,
            catalogStopsSnap,
            ...legacyBusesSnaps
          ] = await Promise.all([
            schoolRef(`years/${year}/transportEnrollments`).once('value'),
            isLegacyMerge ? db.ref('transport_enrollments').once('value') : Promise.resolve(null),
            schoolRef(`years/${year}/transportRegistry`).once('value').catch(() => ({ val: () => null })),
            isLegacyMerge ? db.ref(`transportRegistry/${year}`).once('value').catch(() => ({ val: () => null })) : Promise.resolve(null),
            schoolRef(`years/${year}/transportAssignments`).once('value').catch(() => ({ val: () => null })),
            isLegacyMerge ? db.ref(`transportAssignments/${year}`).once('value').catch(() => ({ val: () => null })) : Promise.resolve(null),
            scopedOrSocratesLegacy(`years/${year}/transport/buses`, `transport/socrates-school/${year}/buses`).catch(() => ({ val: () => null, exists: () => false })),
            (async () => {
              try {
                const primary = await schoolRef(`years/${year}/workers`).once('value');
                const primaryVal = primary?.val?.();
                const primaryHasData = primary?.exists?.() && primaryVal && typeof primaryVal === 'object' && Object.keys(primaryVal).length > 0;
                if (primaryHasData) {
                  if (isLegacyMerge) {
                    try {
                      const [legacyRoot, legacyYear, schoolWorkers, schoolYearWorkers] = await Promise.all([
                        db.ref('workers').once('value').catch(() => null),
                        db.ref(`years/${year}/workers`).once('value').catch(() => null),
                        db.ref(`schools/${schoolId}/workers`).once('value').catch(() => null),
                        db.ref(`schools/${schoolId}/years/${year}/workers`).once('value').catch(() => null)
                      ]);
                      const legacyVal = legacyRoot?.val() || {};
                      const yearVal = legacyYear?.val() || {};
                      const schoolVal = schoolWorkers?.val() || {};
                      const schoolYearVal = schoolYearWorkers?.val() || {};
                      const merged = { ...legacyVal, ...yearVal, ...schoolVal, ...schoolYearVal, ...primaryVal };
                      return { val: () => merged, exists: () => true };
                    } catch (_) {}
                  }
                  return primary;
                }
              } catch (_) {}
              try {
                if (isLegacyMerge) {
                  const [legacyRoot, legacyYear, schoolWorkers, schoolYearWorkers] = await Promise.all([
                    db.ref('workers').once('value').catch(() => null),
                    db.ref(`years/${year}/workers`).once('value').catch(() => null),
                    db.ref(`schools/${schoolId}/workers`).once('value').catch(() => null),
                    db.ref(`schools/${schoolId}/years/${year}/workers`).once('value').catch(() => null)
                  ]);
                  const merged = {
                    ...(legacyRoot?.val() || {}),
                    ...(legacyYear?.val() || {}),
                    ...(schoolWorkers?.val() || {}),
                    ...(schoolYearWorkers?.val() || {})
                  };
                  if (merged && typeof merged === 'object' && Object.keys(merged).length > 0) {
                    return { val: () => merged, exists: () => true };
                  }
                }
                const legacy = isLegacyMerge ? await db.ref('workers').once('value') : await schoolRef('workers').once('value');
                return legacy || { val: () => null, exists: () => false };
              } catch (_) {}
              return { val: () => null, exists: () => false };
            })(),
            (async () => {
              try {
                const s = await schoolRef(`transportCatalog/${year}/stops`).once('value');
                return s && s.val ? s : { val: () => null };
              } catch (_) {
                try {
                  const g = await db.ref(`transportCatalog/${year}/stops`).once('value');
                  return g && g.val ? g : { val: () => null };
                } catch (__) { return { val: () => null }; }
              }
            })(),
            ...legacyBusesPaths.map(p => db.ref(p).once('value').catch(() => ({ val: () => null }))),
          ]);
          const catalogStopsVal = catalogStopsSnap && catalogStopsSnap.val ? catalogStopsSnap.val() : null;

          const scopedEnrollments = (enrollScopedSnap && typeof enrollScopedSnap.val === 'function') ? (enrollScopedSnap.val() || {}) : {};
          const legacyEnrollmentsRaw = (enrollLegacySnap && typeof enrollLegacySnap.val === 'function') ? (enrollLegacySnap.val() || {}) : {};
          const enrollments = isLegacyMerge ? { ...legacyEnrollmentsRaw, ...scopedEnrollments } : scopedEnrollments;

          const scopedRegistry = (registryScopedSnap && typeof registryScopedSnap.val === 'function') ? (registryScopedSnap.val() || {}) : {};
          const legacyRegistry = (registryLegacySnap && typeof registryLegacySnap.val === 'function') ? (registryLegacySnap.val() || {}) : {};
          const registry = isLegacyMerge ? { ...legacyRegistry, ...scopedRegistry } : scopedRegistry;

          const scopedAssignments = (assignmentsScopedSnap && typeof assignmentsScopedSnap.val === 'function') ? (assignmentsScopedSnap.val() || {}) : {};
          const legacyAssignments = (assignmentsLegacySnap && typeof assignmentsLegacySnap.val === 'function') ? (assignmentsLegacySnap.val() || {}) : {};
          const assignments = isLegacyMerge ? { ...legacyAssignments, ...scopedAssignments } : scopedAssignments;

          // --- DRIVER + VEHICLE RESOLUTION (FIX: Furaha not showing) ---
          const norm = (s) => String(s || '').toLowerCase().trim();
          const isUsableDriverName = (name) => {
            const v = String(name || '').trim();
            if (!v) return false;
            const n = v.toLowerCase();
            return n !== 'not assigned' && n !== 'n/a' && n !== 'na' && n !== 'none' && n !== '-' && n !== 'â€”' && n !== 'unknown';
          };

          // Build full name safely from MANY possible worker schemas
          function buildWorkerFullName(uid, worker) {
            const profile = worker?.profile || {};
            const name =
              profile.fullNameUpper ||
              worker?.fullNameUpper ||
              profile.fullName ||
              worker?.fullName ||
              worker?.name ||
              [profile.firstName, profile.middleName, profile.lastName].filter(Boolean).join(' ') ||
              [worker?.firstName, worker?.middleName, worker?.lastName].filter(Boolean).join(' ') ||
              uid;
            return String(name || uid).trim() || uid;
          }

          function normalizePhone(raw) {
            const s = String(raw || '').trim();
            if (!s) return '';
            const digits = s.replace(/[^\d]/g, '');
            if (digits.startsWith('255')) return digits;
            if (digits.length === 9) return '255' + digits;
            if (digits.length === 10 && digits.startsWith('0')) return '255' + digits.slice(1);
            return digits;
          }

          // Build lookup maps from ALL workers (not only role=driver)
          const drivers = [];
          const workerNameByUid = new Map();
          const workerNameByPhone = new Map();

          const isDriverRole = (worker) => {
            const profile = worker?.profile || {};
            const roleRaw = profile.role || worker.role || profile.jobTitle || profile.position || worker.jobTitle || '';
            const role = String(roleRaw || '').toLowerCase().trim();
            return role === 'driver' || role === 'dereva';
          };

          if (workersSnap && workersSnap.exists && workersSnap.exists()) {
            const workersVal = workersSnap.val() || {};
            Object.entries(workersVal).forEach(([uid, worker]) => {
              if (!worker) return;
              const fullName = buildWorkerFullName(uid, worker);
              workerNameByUid.set(uid, fullName);

              const profile = worker?.profile || {};
              const phone = normalizePhone(profile.phone || worker.phone || worker.mobile || profile.mobile || '');
              if (phone && !workerNameByPhone.has(phone)) workerNameByPhone.set(phone, fullName);

              if (isDriverRole(worker)) {
                drivers.push({ id: uid, fullName });
              }
            });
          }

          function resolveWorkerName(uidOrPhone) {
            const key = String(uidOrPhone || '').trim();
            if (!key) return '';
            const byUid = workerNameByUid.get(key);
            if (byUid) return byUid;
            const byPhone = workerNameByPhone.get(normalizePhone(key));
            if (byPhone) return byPhone;
            return '';
          }

          const hasDriver = (v) => {
            if (!v) return false;
            return isUsableDriverName(v.driverName || v.driver || v.assignedDriverName || v.driverFullName);
          };

          function extractDriverNameValue(raw) {
            if (!raw) return '';
            if (typeof raw === 'string' || typeof raw === 'number') return String(raw).trim();
            if (typeof raw === 'object') {
              return String(
                raw.fullName ||
                raw.fullNameUpper ||
                raw.name ||
                raw.driverName ||
                raw.assignedDriverName ||
                raw.label ||
                ''
              ).trim();
            }
            return '';
          }

          // Merge buses from multiple snaps (existing code style)
          const vehicles = {};
          const mergeBusesFromSnap = (snap) => {
            if (!snap || !snap.val) return;
            const val = typeof snap.val === 'function' ? snap.val() : snap.val;
            if (!val || typeof val !== 'object') return;
            Object.entries(val).forEach(([key, v]) => {
              if (v && !vehicles[key]) vehicles[key] = { id: key, ...(v || {}) };
            });
          };
          mergeBusesFromSnap(vehiclesSnap);
          (legacyBusesSnaps || []).forEach(mergeBusesFromSnap);

          // Create vehicle lookups by id + by plate
          const vehicleIdByPlate = {};
          Object.entries(vehicles).forEach(([vehicleId, v]) => {
            const plateKey = norm(v.plate || v.plateNo || v.registration || '');
            if (plateKey) vehicleIdByPlate[plateKey] = vehicleId;
          });

          function getVehicleByAnyRef(ref) {
            const k = String(ref || '').trim();
            if (!k) return null;
            if (vehicles[k]) return vehicles[k];
            const byPlate = vehicleIdByPlate[norm(k)];
            if (byPlate && vehicles[byPlate]) return vehicles[byPlate];
            return null;
          }

          // Normalize assignedRoutes safely (handles array, object-map, RTDB array-object)
          function normalizeRoutes(raw) {
            if (!raw) return [];
            if (Array.isArray(raw)) return raw;
            if (typeof raw === 'object') {
              const entries = Object.entries(raw);
              const isArrayLike = entries.every(([k]) => String(Number(k)) === k);
              if (isArrayLike) {
                return entries
                  .sort((a, b) => Number(a[0]) - Number(b[0]))
                  .map(([, v]) => v)
                  .filter(Boolean);
              }
              const allBooleans = entries.every(([, v]) => v === true || v === 1 || v === '1');
              if (allBooleans) return entries.map(([k]) => k).filter(Boolean);
              return entries.map(([, v]) => v).filter(Boolean);
            }
            if (typeof raw === 'string') {
              return raw.split(/[|;,\n]+/).map(s => s.trim()).filter(Boolean);
            }
            return [];
          }

          // Build route -> {vehicleId, driverName} map
          const routeVehicleMap = {};
          const vehicleIdToDriver = {};
          const shouldReplaceRouteEntry = (existing, incoming) => {
            if (!existing) return true;
            const existingGood = isUsableDriverName(existing.driverName);
            const incomingGood = isUsableDriverName(incoming.driverName);
            return !existingGood && incomingGood;
          };

          Object.entries(vehicles).forEach(([vehicleId, v]) => {
            const routeCandidates = [
              v.assignedRoutes,
              v.routes,
              v.routeNames,
              v.route,
              v.routeName,
              v.stopNames,
              v.stops,
              v.amStop,
              v.pmStop,
              v.morningRoute,
              v.eveningRoute,
            ];
            const routesList = routeCandidates.flatMap(normalizeRoutes).filter(Boolean);

            const driverUid =
              v.assignedDriverUid ||
              v.driverUid ||
              v.driverId ||
              v.driverUID ||
              v.assignedDriverId ||
              v.assignedDriver ||
              v.driverUserId ||
              '';
            const driverNameFromUid = resolveWorkerName(driverUid);

            const driverNameFromVehicle = extractDriverNameValue(
              v.assignedDriverName ||
              v.driverName ||
              v.driverFullName ||
              v.assignedDriverFullName ||
              v.driver ||
              ''
            );

            const resolvedDriverName =
              driverNameFromUid ||
              driverNameFromVehicle ||
              (driverUid ? driverUid : '') ||
              'Not assigned';

            v._resolvedDriverName = resolvedDriverName;
            v._resolvedDriverUid = driverUid;
            vehicleIdToDriver[vehicleId] = resolvedDriverName;

            const entry = { vehicleId, driverName: resolvedDriverName };

            routesList.forEach(r => {
              const routeName = (typeof r === 'string' ? r : (r && (r.route || r.name || r.id))) || '';
              const key = norm(routeName);
              if (!key) return;
              if (shouldReplaceRouteEntry(routeVehicleMap[key], entry)) {
                routeVehicleMap[key] = entry;
              }
            });
            if (routesList.length === 0 && (v.amStop || v.pmStop)) {
              const k1 = norm(v.amStop);
              const k2 = norm(v.pmStop);
              if (k1 && shouldReplaceRouteEntry(routeVehicleMap[k1], entry)) routeVehicleMap[k1] = entry;
              if (k2 && shouldReplaceRouteEntry(routeVehicleMap[k2], entry)) routeVehicleMap[k2] = entry;
            }
          });

          // stop ID aliases from transportCatalog (existing idea kept)
          if (catalogStopsVal && typeof catalogStopsVal === 'object') {
            Object.entries(catalogStopsVal).forEach(([stopId, stop]) => {
              if (!stop) return;
              const stopName = norm(stop.name || stop.id || '');
              const entry = routeVehicleMap[stopName];
              if (entry) {
                if (shouldReplaceRouteEntry(routeVehicleMap[stopId], entry)) routeVehicleMap[stopId] = entry;
                if (shouldReplaceRouteEntry(routeVehicleMap[norm(stopId)], entry)) routeVehicleMap[norm(stopId)] = entry;
              }
            });
          }

          state.transportEnrollments = {};

          Object.entries(enrollments).forEach(([studentId, enrollment]) => {
            if (enrollment) state.transportEnrollments[studentId] = enrollment;
          });

          Object.entries(registry).forEach(([studentId, reg]) => {
            if (!reg || reg.using !== true) return;
            if (!state.transportEnrollments[studentId]) {
              state.transportEnrollments[studentId] = {
                amStop: reg.routeId || '',
                pmStop: reg.stopName || '',
                monthlyFee: reg.monthlyFee || 0
              };
            }
          });

          function driverForRoute(routeName) {
            if (!routeName) return null;
            const key = norm(routeName);
            const entry = routeVehicleMap[key];
            if (entry) return { driverName: entry.driverName, vehicleId: entry.vehicleId };
            const partial = Object.keys(routeVehicleMap).find(k => key.includes(k) || k.includes(key));
            return partial ? { driverName: routeVehicleMap[partial].driverName, vehicleId: routeVehicleMap[partial].vehicleId } : null;
          }

          function vehicleDriverFromEnrollment(enrollment) {
            const ref =
              enrollment?.vehicleId ||
              enrollment?.busId ||
              enrollment?.vehicle ||
              enrollment?.assignedVehicleId ||
              '';
            const v = getVehicleByAnyRef(ref);
            if (!v) return null;
            const name =
              String(v._resolvedDriverName || v.assignedDriverName || v.driverName || v.driver || '').trim();
            return isUsableDriverName(name) ? { driverName: name } : null;
          }

          function enrichVehicleWithDriver(vehicleObj) {
            if (!vehicleObj) return vehicleObj;
            if (typeof vehicleObj === 'string') {
              const vid = vehicleObj.trim();
              if (!vid) return vehicleObj;
              if (vehicleIdToDriver[vid]) {
                return { vehicleId: vid, id: vid, driverName: vehicleIdToDriver[vid] };
              }
              const v = vehicles[vid] || getVehicleByAnyRef(vid);
              if (v && v._resolvedDriverName) {
                return { vehicleId: vid, id: vid, driverName: v._resolvedDriverName };
              }
              return { vehicleId: vid, id: vid };
            }
            if (typeof vehicleObj !== 'object') return vehicleObj;
            if (hasDriver(vehicleObj)) return vehicleObj;
            const vid = vehicleObj.vehicleId || vehicleObj.id;
            if (vid && vehicleIdToDriver[vid]) {
              return { ...vehicleObj, driverName: vehicleIdToDriver[vid] };
            }
            const v = vehicles[vid] || getVehicleByAnyRef(vid);
            if (v && v._resolvedDriverName) {
              return { ...vehicleObj, driverName: v._resolvedDriverName };
            }
            return vehicleObj;
          }

          Object.entries(assignments).forEach(([studentId, assignRecord]) => {
            if (!assignRecord || assignRecord.status !== 'Using') {
              if (state.transportEnrollments[studentId]) {
                delete state.transportEnrollments[studentId];
              }
              return;
            }
            const existing = state.transportEnrollments[studentId] || {};
            const amStop = assignRecord.morningRouteId || assignRecord.amStop || existing.amStop || '';
            const pmStop = assignRecord.eveningRouteId || assignRecord.pmStop || existing.pmStop || '';
            const route = assignRecord.route || existing.route || amStop || pmStop || '';
            const period = amStop && pmStop ? 'both' : (amStop ? 'morning' : (pmStop ? 'evening' : ''));
            let morningVehicle = (hasDriver(existing.morningVehicle) && existing.morningVehicle)
              ? existing.morningVehicle
              : (hasDriver(assignRecord.morningVehicle) && assignRecord.morningVehicle)
              ? assignRecord.morningVehicle
              : (driverForRoute(amStop) || existing.morningVehicle || assignRecord.morningVehicle);
            let eveningVehicle = (hasDriver(existing.eveningVehicle) && existing.eveningVehicle)
              ? existing.eveningVehicle
              : (hasDriver(assignRecord.eveningVehicle) && assignRecord.eveningVehicle)
              ? assignRecord.eveningVehicle
              : (driverForRoute(pmStop) || existing.eveningVehicle || assignRecord.eveningVehicle);
            morningVehicle = enrichVehicleWithDriver(morningVehicle);
            eveningVehicle = enrichVehicleWithDriver(eveningVehicle);
            state.transportEnrollments[studentId] = {
              ...existing,
              ...assignRecord,
              amStop,
              pmStop,
              route,
              period: assignRecord.period || existing.period || period,
              baseMonthlyFee: assignRecord.baseMonthlyFee || existing.baseMonthlyFee,
              startDate: assignRecord.startDate || existing.startDate,
              morningVehicle: morningVehicle || existing.morningVehicle,
              eveningVehicle: eveningVehicle || existing.eveningVehicle,
            };
          });

          // Ensure ALL enrolled transport students get driver info (even if assignment record is missing)
          Object.entries(state.transportEnrollments).forEach(([studentId, en]) => {
            if (!en) return;
            // 1) direct vehicle assignment wins (if present)
            const directVehicle = vehicleDriverFromEnrollment(en);
            if (directVehicle) {
              if (!hasDriver(en.morningVehicle)) en.morningVehicle = directVehicle;
              if (!hasDriver(en.eveningVehicle)) en.eveningVehicle = directVehicle;
            }
            // 2) fallback by route mapping
            if (!hasDriver(en.morningVehicle) && en.amStop) en.morningVehicle = driverForRoute(en.amStop);
            if (!hasDriver(en.eveningVehicle) && en.pmStop) en.eveningVehicle = driverForRoute(en.pmStop);
            en.morningVehicle = enrichVehicleWithDriver(en.morningVehicle);
            en.eveningVehicle = enrichVehicleWithDriver(en.eveningVehicle);
          });

          // STEP 2: Load ONLY students who are on transport (not all students!)
          const studentIds = Object.keys(state.transportEnrollments);
          if (studentIds.length === 0) {
            state.students = {};
            state.transportPayments = {};
            state.expenses = {};
            renderKPIs();
            renderPaymentsTable();
            renderExpensesTable();
            showToast('No students on transport', 'ok');
            return;
          }

          // Load students in batches to avoid timeout on slow connections
          const BATCH_SIZE = 50;
          state.students = {};
          state.studentKeyAliases = {};
          const unresolvedStudentIds = [];
          for (let i = 0; i < studentIds.length; i += BATCH_SIZE) {
            const batch = studentIds.slice(i, i + BATCH_SIZE);
            const studentPromises = batch.map(id => 
              scopedOrSocratesLegacy(`students/${id}`, `students/${id}`).then(snap => ({ id, data: snap.val() }))
            );
            const students = await Promise.all(studentPromises);
            students.forEach(({ id, data }) => {
              if (data) {
                state.students[id] = data;
              } else {
                unresolvedStudentIds.push(id);
              }
            });
            // Show progress
            if (i % (BATCH_SIZE * 2) === 0) {
              showToast(`Loading students... ${Math.min(i + BATCH_SIZE, studentIds.length)}/${studentIds.length}`, 'ok');
            }
          }

          // Resolve transport IDs that are not direct keys in /students by admission number or equivalent identifiers.
          if (unresolvedStudentIds.length) {
            let allStudents = {};
            try {
              const allStudentsSnap = await scopedOrSocratesLegacy('students', 'students');
              allStudents = allStudentsSnap.val() || {};
            } catch (err) {
              console.warn('Could not load all students for alias matching:', err);
            }

            const admissionIndex = new Map();
            Object.entries(allStudents || {}).forEach(([key, record]) => {
              if (!record || typeof record !== 'object') return;
              const candidates = [
                key,
                record.admissionNumber,
                record.admissionNo,
                record.admission,
                record.studentAdm,
                record.studentId,
              ];
              candidates.forEach((candidate) => {
                const normalized = normalizeIdentifier(candidate);
                if (normalized && !admissionIndex.has(normalized)) {
                  admissionIndex.set(normalized, { key, record });
                }
              });
            });

            unresolvedStudentIds.forEach((transportStudentId) => {
              const enrollment = state.transportEnrollments[transportStudentId] || {};
              const keysToTry = [
                transportStudentId,
                enrollment.admissionNumber,
                enrollment.admissionNo,
                enrollment.admission,
                enrollment.studentAdm,
                enrollment.studentId,
              ];
              let match = null;
              for (const candidate of keysToTry) {
                const normalized = normalizeIdentifier(candidate);
                if (!normalized) continue;
                if (admissionIndex.has(normalized)) {
                  match = admissionIndex.get(normalized);
                  break;
                }
              }
              if (match && match.record) {
                state.students[transportStudentId] = match.record;
                state.studentKeyAliases[transportStudentId] = match.key;
              }
            });
          }

          // Final fallback: never drop transport pupils due to missing /students profile.
          studentIds.forEach((id) => {
            if (!state.students[id]) {
              state.students[id] = buildFallbackStudent(id, state.transportEnrollments[id] || {});
            }
          });

          // STEP 3: Load payments ONLY for transport students (year-scoped ledgers primary)
          showToast('Loading payments...', 'ok');
          const paymentsSnap = await scopedOrSocratesLegacy(`years/${year}/transportLedgers`, `transportLedgers/${year}`);
          let scopedPaymentsSnap = null;
          let legacyPaymentsSnap = null;

          try {
            scopedPaymentsSnap = await schoolRef(`years/${year}/transport_payments`).once('value');
          } catch (err) {
            scopedPaymentsSnap = null;
          }

          const scopedPaymentsVal = scopedPaymentsSnap?.val() || {};
          const scopedEmpty = !scopedPaymentsSnap?.exists() ||
            (scopedPaymentsVal && typeof scopedPaymentsVal === 'object' && Object.keys(scopedPaymentsVal).length === 0);

          if (isSocratesSchool() && scopedEmpty) {
            try {
              legacyPaymentsSnap = await db.ref('transport_payments').once('value');
            } catch (err) {
              legacyPaymentsSnap = null;
            }
          }

          const legacyPaymentsVal = legacyPaymentsSnap?.val ? (legacyPaymentsSnap.val() || {}) : {};

          const paymentsData = {};
          const ledgers = paymentsSnap.val() || {};
          studentIds.forEach(studentId => {
            const aliasId = state.studentKeyAliases[studentId];
            if (ledgers[studentId] && ledgers[studentId].payments) {
              paymentsData[studentId] = normalizePaymentList(ledgers[studentId].payments);
              return;
            }
            if (aliasId && ledgers[aliasId] && ledgers[aliasId].payments) {
              paymentsData[studentId] = normalizePaymentList(ledgers[aliasId].payments);
            }
          });

          // Optional legacy payments: scoped year path (non-Socrates) or legacy root (Socrates fallback)
          studentIds.forEach(studentId => {
            const aliasId = state.studentKeyAliases[studentId];
            if (paymentsData[studentId] && paymentsData[studentId].length) return;
            if (scopedPaymentsVal && scopedPaymentsVal[studentId]) {
              paymentsData[studentId] = normalizePaymentList(scopedPaymentsVal[studentId]);
              return;
            }
            if (aliasId && scopedPaymentsVal && scopedPaymentsVal[aliasId]) {
              paymentsData[studentId] = normalizePaymentList(scopedPaymentsVal[aliasId]);
              return;
            }
            if (legacyPaymentsVal && legacyPaymentsVal[studentId]) {
              const legacyPayments = legacyPaymentsVal[studentId];
              paymentsData[studentId] = filterLegacyPaymentsByYear(legacyPayments, year);
              return;
            }
            if (aliasId && legacyPaymentsVal && legacyPaymentsVal[aliasId]) {
              const legacyPayments = legacyPaymentsVal[aliasId];
              paymentsData[studentId] = filterLegacyPaymentsByYear(legacyPayments, year);
            }
          });

          // Merge approval status from approvalsHistory + inject approved payments not in ledger
          try {
            const history = await fetchApprovalsHistoryForYear(year);
            const studentMatches = (r, sid, admNo) => {
              if (!r || r.sourceModule !== 'transport') return false;
              const key = r.modulePayload?.studentKey;
              const adm = r.studentAdm || r.admissionNumber || r.modulePayload?.admissionNumber;
              return key === sid || adm === sid || adm === admNo || key === admNo;
            };
            Object.values(history).forEach(monthRecords => {
              Object.values(monthRecords || {}).forEach(record => {
                if (!record || record.finalStatus !== 'approved') return;
                const pmt = record.modulePayload?.payment;
                const ref = record.paymentReferenceCode || pmt?.reference || pmt?.ref;
                if (!ref) return;
                studentIds.forEach(sid => {
                  const enrollment = state.transportEnrollments[sid] || {};
                  const student = state.students[sid];
                  const admNo = student?.admissionNumber || enrollment?.admissionNumber || enrollment?.admissionNo || '';
                  if (!studentMatches(record, sid, admNo)) return;
                  if (!paymentsData[sid]) paymentsData[sid] = [];
                  const pays = paymentsData[sid];
                  let found = false;
                  pays.forEach((p, i) => {
                    const pr = p.ref || p.reference;
                    if (pr === ref) {
                      paymentsData[sid][i] = { ...p, approved: true, approvedAt: p.approvedAt || record.approvedAt };
                      found = true;
                    }
                  });
                  // Inject approved payment from history when not in ledger (fixes "History still nothing")
                  if (!found && pmt) {
                    const monthNum = typeof pmt.month === 'number' ? pmt.month : (MONTH_NAMES.indexOf(pmt.month) >= 1 ? MONTH_NAMES.indexOf(pmt.month) : new Date(record.datePaid || record.createdAt || Date.now()).getMonth() + 1);
                    paymentsData[sid].push({
                      amount: record.amountPaidNow ?? pmt.amount,
                      method: record.paymentMethod ?? pmt.method,
                      ref: ref,
                      reference: ref,
                      payerName: record.payerName ?? pmt.payerName,
                      paidAt: record.datePaid ?? pmt.paidAt ?? record.createdAt,
                      timestamp: record.createdAt ?? pmt.timestamp,
                      month: monthNum,
                      notes: record.notes ?? pmt.notes ?? '',
                      approved: true,
                      approvedAt: record.approvedAt,
                      approvedBy: record.approvedBy
                    });
                  }
                });
              });
            });
          } catch (err) {
            console.warn('Merge approval status from history:', err);
          }

          state.transportPayments = paymentsData;

          // STEP 4: Load expenses (lightweight, can load all)
          const expensesSnap = await scopedOrSocratesLegacy(`years/${year}/transport_expenses`, 'transport_expenses');
          const allExpenses = expensesSnap.val() || {};
          state.expenses = {};
          Object.entries(allExpenses).forEach(([key, exp]) => {
            if (exp && (exp.year == year || !exp.year)) {
              state.expenses[key] = exp;
            }
          });

          // STEP 5: Pre-load multipliers
          const yearNum = Number(state.year);
          if (!cachedMultipliers[yearNum]) {
            cachedMultipliers[yearNum] = await TransportPricing.loadYearMultipliers(yearNum);
          }

          // STEP 6: Clear status cache for this year
          statusCache.clear();

          // STEP 7: Render progressively - show table first, then KPIs
          showToast('Rendering data...', 'ok');
          await renderPaymentsTable();
          await renderKPIs();
          renderExpensesTable();
          
          showToast('Data loaded successfully!', 'ok');
        } catch (error) {
          console.error('Error loading data:', error);
          showToast('Error loading data: ' + error.message, 'bad');
        }
      }

      function refreshData() {
        showToast('Refreshing data...');
        loadAllData();
      }

      maybeAutoAdvanceYear();
      maybeRunRollover();

      // Event listeners
      if (yearSelect) {
        yearSelect.value = state.year;
        yearSelect.addEventListener('change', (e) => {
          state.year = parseInt(e.target.value);
          statusCache.clear(); // Clear cache on year change
          if (window.somapYearContext) {
            window.somapYearContext.setSelectedYear(String(state.year));
          }
          loadAllData();
        });
      }
      
      // Listen to year context changes
      if (window.somapYearContext) {
        window.somapYearContext.onYearChanged((year) => {
          const newYear = parseInt(year) || state.year;
          if (newYear !== state.year) {
            state.year = newYear;
            statusCache.clear(); // Clear cache on year change
            if (yearSelect) yearSelect.value = state.year;
            loadAllData();
          }
        });
      }

      classFilter.addEventListener('change', renderPaymentsTable);
      searchInput.addEventListener('input', renderPaymentsTable);
      statusFilter.addEventListener('change', renderPaymentsTable);

      paymentsBody.addEventListener('click', function(e) {
        const btn = e.target.closest('button[data-action][data-student]');
        if (!btn) return;
        const action = btn.getAttribute('data-action');
        const studentId = btn.getAttribute('data-student');
        if (!studentId) return;
        if (action === 'pay') openPaymentModal(studentId);
        else if (action === 'history') viewPaymentHistory(studentId);
      });

      document.getElementById('openPaymentScheduleBtn')?.addEventListener('click', () => openPaymentScheduleModal());
      document.getElementById('downloadPaymentSchedulePdf')?.addEventListener('click', () => downloadPaymentSchedulePdf());

      // Update due date display: 3rd {MonthName} {Year}
      (function updateDueDate(){
        const params = new URLSearchParams(window.location.search);
        const yearParam = parseInt(params.get('year'), 10);
        const today = new Date();
        const m = today.getMonth() + 1;
        const y = Number.isFinite(yearParam) ? yearParam : today.getFullYear();
        document.getElementById('dueDate').textContent = `3rd ${MONTH_NAMES[m]} ${y}`;
      })();

      // Parent transport payment renderer - unified view with existing KPIs and table
      async function renderParentTransportPayment(studentId) {
        try {
          const y = String(state.year);
          
          // Ensure expenses/balance cards are hidden (already done on init, but double-check)
          const expCard = document.getElementById('totalExpenses')?.closest('.stat-card');
          const netCard = document.getElementById('netBalance')?.closest('.stat-card');
          if (expCard) expCard.style.display = 'none';
          if (netCard) netCard.style.display = 'none';
          
          // Hide expenses section completely
          const expSection = document.querySelector('section.card.mt-3:has([id="fuelExpenses"])');
          if (expSection) expSection.style.display = 'none';
          
          // Get parent phone (parents logged in via index.html with studentKey)
          const parentPhone = normalizePhone(localStorage.getItem('parentPhone') || '');
        
        // Load ONLY this specific student's data (fast!)
        // Use same data source as admin view (transportLedgers)
        const [sSnap, enrollSnap, ledSnap, finSnap] = await Promise.all([
          scopedOrSocratesLegacy(`students/${studentId}`, `students/${studentId}`),
          scopedOrSocratesLegacy(`years/${y}/transportEnrollments/${studentId}`, `transport_enrollments/${studentId}`).catch(() => ({ val: () => null })),
          scopedOrSocratesLegacy(`years/${y}/transportLedgers/${studentId}/payments`, `transportLedgers/${y}/${studentId}/payments`).catch(() => ({ val: () => null })),
          scopedOrSocratesLegacy(`years/${y}/finance/${studentId}/payments`, `finance/${y}/${studentId}/payments`).catch(() => ({ val: () => null }))
        ]);
        
        const S = sSnap.val() || {};
        const enrollment = enrollSnap.val() || {};
        let pays = normalizePaymentList(ledSnap.val() || {});
        
        // Also check legacy path if no data in new path
        if (!pays || pays.length === 0) {
          pays = await readSupplementalPayments(y, studentId);
        }
        
        const schoolPayments = finSnap.val() || {};
        
        // Ensure pays is an array
        if (!Array.isArray(pays)) {
          pays = pays ? [pays] : [];
        }
        
        // Verify parent owns student (but don't block if no phone match - parents already authenticated)
        const studentPhone = normalizePhone(S.motherPhone || S.parentPhone || S.primaryParentContact || '');
        if (parentPhone && parentPhone !== studentPhone) {
          alert('Access denied. This child is not linked to your account.');
          window.location.href = 'parent.html';
          return;
        }
        
        // Check if using transport
        if (!enrollment) {
          alert('This child is not using transport for the selected year.');
          window.location.href = 'parent.html';
          return;
        }
        
        // Populate state so modal functions work
        state.students[studentId] = S;
        state.transportEnrollments[studentId] = enrollment;
        state.transportPayments[studentId] = pays;
        state.currentPaymentStudentId = studentId;
        await renderYearScopedStudentView(studentId);
        return;
        } catch (error) {
          console.error('Error in renderParentTransportPayment:', error);
          showToast('Error loading student data', 'bad');
          // Still show error in stat cards
          const totalExpectedEl = document.getElementById('totalExpected');
          const totalCollectedEl = document.getElementById('totalCollected');
          const totalDebtEl = document.getElementById('totalDebt');
          if (totalExpectedEl) totalExpectedEl.textContent = 'Error';
          if (totalCollectedEl) totalCollectedEl.textContent = 'Error';
          if (totalDebtEl) totalDebtEl.textContent = 'Error';
        }
      }

      // Year-scoped single-student renderer (strict; never switch student)
      function monthName(num){ return MONTH_NAMES[num] || ''; }
      async function loadTransportContextStrict(year, studentId){
        const requestedId = String(studentId || '').trim();
        const reqNorm = normalizeIdentifier(requestedId);
        const y = String(year);
        const isLegacyMerge = isSocratesSchool();

        // 1) Build merged transport map exactly like admin view.
        const [
          enrollScopedSnap,
          enrollLegacySnap,
          registryScopedSnap,
          registryLegacySnap,
          assignmentsScopedSnap,
          assignmentsLegacySnap
        ] = await Promise.all([
          schoolRef(`years/${y}/transportEnrollments`).once('value').catch(() => ({ val: () => ({}) })),
          isLegacyMerge ? db.ref('transport_enrollments').once('value').catch(() => ({ val: () => ({}) })) : Promise.resolve({ val: () => ({}) }),
          schoolRef(`years/${y}/transportRegistry`).once('value').catch(() => ({ val: () => ({}) })),
          isLegacyMerge ? db.ref(`transportRegistry/${y}`).once('value').catch(() => ({ val: () => ({}) })) : Promise.resolve({ val: () => ({}) }),
          schoolRef(`years/${y}/transportAssignments`).once('value').catch(() => ({ val: () => ({}) })),
          isLegacyMerge ? db.ref(`transportAssignments/${y}`).once('value').catch(() => ({ val: () => ({}) })) : Promise.resolve({ val: () => ({}) }),
        ]);

        const scopedEnrollments = enrollScopedSnap.val() || {};
        const legacyEnrollments = enrollLegacySnap.val() || {};
        const scopedRegistry = registryScopedSnap.val() || {};
        const legacyRegistry = registryLegacySnap.val() || {};
        const scopedAssignments = assignmentsScopedSnap.val() || {};
        const legacyAssignments = assignmentsLegacySnap.val() || {};

        const enrollments = isLegacyMerge ? { ...legacyEnrollments, ...scopedEnrollments } : scopedEnrollments;
        const registry = isLegacyMerge ? { ...legacyRegistry, ...scopedRegistry } : scopedRegistry;
        const assignments = isLegacyMerge ? { ...legacyAssignments, ...scopedAssignments } : scopedAssignments;

        const mergedTransport = {};
        Object.entries(enrollments).forEach(([id, enrollment]) => {
          if (enrollment) mergedTransport[id] = enrollment;
        });
        Object.entries(registry).forEach(([id, reg]) => {
          if (!reg || reg.using !== true) return;
          if (!mergedTransport[id]) {
            mergedTransport[id] = {
              amStop: reg.routeId || '',
              pmStop: reg.stopName || '',
              monthlyFee: reg.monthlyFee || 0
            };
          }
        });
        Object.entries(assignments).forEach(([id, assignRecord]) => {
          if (!assignRecord || assignRecord.status !== 'Using') {
            if (mergedTransport[id]) delete mergedTransport[id];
            return;
          }
          const existing = mergedTransport[id] || {};
          mergedTransport[id] = {
            ...existing,
            ...assignRecord,
            amStop: assignRecord.morningRouteId || assignRecord.amStop || existing.amStop || '',
            pmStop: assignRecord.eveningRouteId || assignRecord.pmStop || existing.pmStop || '',
            baseMonthlyFee: assignRecord.baseMonthlyFee || existing.baseMonthlyFee,
            startDate: assignRecord.startDate || existing.startDate,
          };
        });

        // 2) Load merged students map (scoped + legacy for Socrates).
        let allStudents = {};
        try {
          const scopedStudentsSnap = await schoolRef('students').once('value');
          const scopedStudents = scopedStudentsSnap.val() || {};
          if (isLegacyMerge) {
            const legacyStudentsSnap = await db.ref('students').once('value');
            const legacyStudents = legacyStudentsSnap.val() || {};
            allStudents = { ...legacyStudents, ...scopedStudents };
          } else {
            allStudents = scopedStudents;
          }
        } catch (err) {
          console.warn('Could not load students map for single view:', err);
          allStudents = {};
        }

        // 3) Resolve student profile + transport key by requested key/admission.
        let resolvedStudentKey = null;
        let student = null;
        for (const [k, rec] of Object.entries(allStudents)) {
          if (!rec || typeof rec !== 'object') continue;
          const candidates = [k, rec.admissionNumber, rec.admissionNo, rec.studentAdm, rec.admission];
          if (candidates.some(v => normalizeIdentifier(v) === reqNorm)) {
            resolvedStudentKey = k;
            student = rec;
            break;
          }
        }
        if (!student && allStudents[requestedId]) {
          resolvedStudentKey = requestedId;
          student = allStudents[requestedId];
        }
        const admissionKey = String(student?.admissionNumber || student?.admissionNo || requestedId).trim();
        const admissionNorm = normalizeIdentifier(admissionKey);

        let resolvedTransportId = null;
        const tryTransportIds = [requestedId, resolvedStudentKey, admissionKey].filter(Boolean);
        for (const idTry of tryTransportIds) {
          if (mergedTransport[idTry]) {
            resolvedTransportId = idTry;
            break;
          }
        }
        if (!resolvedTransportId) {
          for (const id of Object.keys(mergedTransport)) {
            if (normalizeIdentifier(id) === reqNorm || normalizeIdentifier(id) === admissionNorm) {
              resolvedTransportId = id;
              break;
            }
          }
        }

        const enrollment = mergedTransport[resolvedTransportId] || null;
        const assignment = assignments[resolvedTransportId] || null;

        // 4) Payments + finance for resolved ids.
        const idsForLedger = [resolvedTransportId, admissionKey, resolvedStudentKey, requestedId].filter(Boolean);
        let payments = [];
        for (const idTry of idsForLedger) {
          if (payments.length) break;
          const paySnap = await scopedOrSocratesLegacy(`years/${y}/transportLedgers/${idTry}/payments`, `transportLedgers/${y}/${idTry}/payments`).catch(() => ({ val: () => null }));
          payments = normalizePaymentList(paySnap.val() || {});
          if (!payments.length) payments = await readSupplementalPayments(y, idTry);
        }
        const normalizedPayments = (payments || []).map(x => ({
          month: Number(x.month)||0,
          amount: Number(x.amount)||0,
          status: x.status||'pending'
        }));

        let financeMap = {};
        for (const idTry of [resolvedStudentKey, admissionKey, requestedId].filter(Boolean)) {
          if (Object.keys(financeMap).length) break;
          const finSnap = await scopedOrSocratesLegacy(`years/${y}/finance/${idTry}/payments`, `finance/${y}/${idTry}/payments`).catch(() => ({ val: () => null }));
          financeMap = finSnap.val() || {};
        }
        const schoolFeePaid = Object.values(financeMap || {}).reduce((a,p)=>a+(Number(p?.amount)||0),0);

        const safeTransportId = resolvedTransportId || requestedId;
        if (!student || Object.keys(student || {}).length === 0) {
          student = buildFallbackStudent(safeTransportId, enrollment || assignment || {});
        }

        let effectiveAssign = assignment;
        if ((!effectiveAssign || effectiveAssign.status !== 'Using') && enrollment) {
          const amStop = enrollment.amStop || enrollment.morningRouteId || enrollment.route || '';
          const pmStop = enrollment.pmStop || enrollment.eveningRouteId || enrollment.stopName || '';
          const baseMonthlyFee = Number(enrollment.baseMonthlyFee || 0) || (TransportPricing.priceForStop(amStop) + TransportPricing.priceForStop(pmStop));
          effectiveAssign = {
            status: 'Using',
            amStop,
            pmStop,
            baseMonthlyFee,
            startDate: enrollment.startDate || enrollment.start_date || enrollment.dateRegistered || null,
          };
        }

        state.students[safeTransportId] = student;
        state.transportEnrollments[safeTransportId] = enrollment || effectiveAssign || {};
        state.transportPayments[safeTransportId] = normalizedPayments;
        state.studentKeyAliases[safeTransportId] = resolvedStudentKey || admissionKey || safeTransportId;

        // Mirror onto requested key too, so downstream consumers don't break.
        state.students[requestedId] = state.students[requestedId] || student;
        state.transportEnrollments[requestedId] = state.transportEnrollments[requestedId] || state.transportEnrollments[safeTransportId];
        state.transportPayments[requestedId] = state.transportPayments[requestedId] || normalizedPayments;

        return {
          assign: effectiveAssign || (enrollment ? { status: 'Using', ...enrollment } : null),
          payments: normalizedPayments,
          schoolFeePaid,
          student,
          resolvedTransportId: safeTransportId,
        };
      }

      function setText(sel, txt){ const el=document.querySelector(sel); if(el) el.textContent=txt; }
      function renderIdentityStrict(S){
        const fullName = `${S.firstName||''} ${S.middleName||''} ${S.lastName||''}`.replace(/\s+/g,' ').trim();
        // Use table header summary for identity context
        document.getElementById('paymentSummary').textContent = fullName ? `Payments for ${fullName}` : '';
      }
      function renderNoDataStrict(msg){
        document.getElementById('totalExpected').textContent = '-';
        document.getElementById('totalCollected').textContent = '-';
        document.getElementById('totalDebt').textContent = '-';
        const tbody = document.getElementById('paymentsBody');
        if (tbody) tbody.innerHTML = '';
        const empty = document.getElementById('emptyState');
        if (empty) { empty.textContent = msg || 'No data'; empty.classList.remove('hidden'); }
      }

      async function renderYearScopedStudentView(studentId){
        state.currentPaymentStudentId = studentId;
        const year = String(state.year);
        const { assign, payments, schoolFeePaid, student, resolvedTransportId } = await loadTransportContextStrict(year, studentId);
        const effectiveStudentId = resolvedTransportId || studentId;
        state.currentPaymentStudentId = effectiveStudentId;
        if (assign && assign.status === 'Using') {
          state.transportEnrollments[effectiveStudentId] = { ...assign, amStop: assign.amStop || assign.morningRouteId, pmStop: assign.pmStop || assign.eveningRouteId };
        }
        state.students[effectiveStudentId] = student;
        state.transportPayments[effectiveStudentId] = payments;
        renderIdentityStrict(student);
        // If no year-scoped assignment, attempt to render using legacy enrollment data
        if (!assign || assign.status !== 'Using'){
          if (!state.transportEnrollments[effectiveStudentId]) {
            renderNoDataStrict(`No transport assignment for ${year}.`);
            return;
          }
        }
        
        // Load year multipliers for accurate calculations
        const multipliers = cachedMultipliers[Number(year)] || (await TransportPricing.loadYearMultipliers(Number(year)));
        if (!cachedMultipliers[Number(year)]) cachedMultipliers[Number(year)] = multipliers;
        
        const hasAssignedStart = Boolean(
          assign?.startDate ||
          assign?.start_date ||
          assign?.startTimestamp ||
          assign?.start_time
        );
        const base = Number(assign?.baseMonthlyFee||0);
        const startDate = normalizeDateInput((assign && (assign.startDate || assign.start_date || assign.startTimestamp || assign.start_time)) || `${year}-01-01`, Number(year));
        const amStop = assign?.amStop || assign?.morningRouteId || '';
        const pmStop = assign?.pmStop || assign?.eveningRouteId || '';
        const ledger = await TransportPricing.buildLedger({ 
          year: Number(year), 
          amStop,
          pmStop,
          baseMonthlyFee: base, 
          startDate, 
          payments, 
          multipliers 
        });

        const focusedMonth = getFocusedMonth();
        const selectedMonthLabel = MONTH_NAMES[focusedMonth] || ('Month ' + focusedMonth);
        const dueThisMonth = await TransportPricing.dueForMonth({ 
          year:Number(year), 
          month:focusedMonth, 
          amStop,
          pmStop,
          baseMonthlyFee: base, 
          startDate, 
          multipliers 
        });
        const startDisplay = hasAssignedStart ? formatStartDateDisplay(startDate) : 'N/A';

        // Debt only includes months already due: due date is 3rd of same month; paying on/from 3rd is late.
        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonthNum = now.getMonth() + 1;
        const currentDay = now.getDate();
        const lastDueMonth = currentDay >= 3 ? currentMonthNum : Math.max(0, currentMonthNum - 1);
        const yearNum = Number(year);
        function isMonthAlreadyDue(month) {
          if (yearNum < currentYear) return true;
          if (yearNum > currentYear) return false;
          return month <= lastDueMonth;
        }
        const monthsToDate = (ledger.months || []).filter(m => m.status !== 'SKIP' && isMonthAlreadyDue(m.month));
        const dueToDate = monthsToDate.reduce((s,m)=> s + (Number(m.due)||0), 0);
        const paidToDate = monthsToDate.reduce((s,m)=> s + (Number(m.paid)||0), 0);
        const balanceToDate = Math.max(0, Math.round(dueToDate - paidToDate));

        document.getElementById('totalExpected').textContent = formatCurrency(Math.round(dueThisMonth));
        document.getElementById('totalCollected').textContent = formatCurrency(Math.round(paidToDate));
        document.getElementById('totalDebt').textContent = formatCurrency(balanceToDate);
        document.getElementById('monthLabel').textContent = `${selectedMonthLabel} ${year}`;

        // School fee alignment
        // Note: only show value; the rest of school columns are fed from student rows
        // We will update the single-row table to reflect school fee paid from finance ledger

        const unpaidMonthsWithAmounts = monthsToDate.filter(m=>m.status==='UNPAID'||m.status==='PARTIAL').map(m=>({month:m.month,name:MONTH_NAMES[m.month],balance:Math.max(0,(Number(m.due)||0)-(Number(m.paid)||0))}));
        const unpaidDisplay = unpaidMonthsWithAmounts.length ? unpaidMonthsWithAmounts.map(m=>`${m.name.substring(0,3)}=${formatShortNum(m.balance)}`).join(', ') : 'None';
        const totalYearExpected = (ledger.months||[]).reduce((s,m)=>s+(Number(m.due)||0),0);
        const totalPaidAll = (ledger.totals&&ledger.totals.paid) ? Number(ledger.totals.paid) : paidToDate;
        const totalYearDebt = Math.max(0, totalYearExpected - totalPaidAll);

        const tbody = document.getElementById('paymentsBody');
        if (tbody){
          const fullName = `${student.firstName||''} ${student.middleName||''} ${student.lastName||''}`.replace(/\s+/g,' ').trim();
          const morningRoute = assign?.amStop || assign?.morningRouteId || '&mdash;';
          const eveningRoute = assign?.pmStop || assign?.eveningRouteId || '&mdash;';
          const driverDisplay = getDriverDisplay(assign);
          const currentMonthDue = Math.round(dueThisMonth);
          const baseDisplay = formatCurrency(base);
          const rowClass = balanceToDate > 0 ? 'style="background: rgba(239, 68, 68, 0.15); font-weight: 600;"' : '';
          const escapedId = String(effectiveStudentId).replace(/'/g, "\\'");
          tbody.innerHTML = `
            <tr ${rowClass}>
              <td>${student.admissionNumber || 'N/A'}</td>
              <td>${fullName}</td>
              <td>${student.classLevel || '&mdash;'}</td>
              <td>${student.primaryParentContact || 'N/A'}</td>
              <td>${startDisplay}</td>
              <td>${morningRoute}</td>
              <td>${eveningRoute}</td>
              <td style="font-size: 0.85rem;">${driverDisplay}</td>
              <td title="Base fee before multiplier: ${baseDisplay}">
                ${formatCurrency(currentMonthDue)}<br>
                <span style="font-size: 0.7rem; color: var(--text-muted, #94a3b8);">
                  Base: ${baseDisplay} &#183; ${selectedMonthLabel}
                </span>
              </td>
              <td style="color: var(--accent-success);">${formatCurrency(paidToDate)}</td>
              <td style="color: ${balanceToDate>0?'var(--accent-danger)':'var(--accent-success)'};">${formatCurrency(balanceToDate)}</td>
              <td style="font-size: 0.7rem;">${unpaidDisplay}</td>
              <td style="color: ${balanceToDate>0?'var(--accent-danger)':'var(--accent-success)'}; font-weight: 700;">${formatCurrency(balanceToDate)}</td>
              <td style="font-size: 0.75rem;">${formatCurrency(totalYearExpected)}</td>
              <td style="font-size: 0.75rem;">${formatCurrency(totalYearDebt)}</td>
              <td class="table-actions" style="justify-content: flex-end;">
                <button class="btn success" data-action="pay" data-student="${escapedId}">&#128176; Pay</button>
                <button class="btn secondary" data-action="history" data-student="${escapedId}">&#128221; History</button>
              </td>
            </tr>`;
          document.getElementById('emptyState')?.classList.add('hidden');
        }
      }

      // Check for single-student view (supports both studentKey and legacy student param)
      const urlParams = new URLSearchParams(window.location.search);
      const studentParam = urlParams.get('studentKey') || urlParams.get('student');
      const monthParam = parseInt(urlParams.get('month'), 10);
      
      if (Number.isFinite(monthParam) && monthParam >= 1 && monthParam <= 12) {
        state.month = monthParam;
        state.monthSelectedFromUrl = true;
      } else {
        state.monthSelectedFromUrl = false;
      }
      if (yearSelect && state.year) yearSelect.value = state.year;
      
      if (studentParam) {
        state.currentPaymentStudentId = studentParam;
        
        // Hide expense/balance cards for single-student view
        const expensesCard = document.getElementById('totalExpenses')?.closest('.stat-card');
        const netBalanceCard = document.getElementById('netBalance')?.closest('.stat-card');
        if (expensesCard) expensesCard.style.display = "none";
        if (netBalanceCard) netBalanceCard.style.display = "none";
        
        // Hide expenses section completely
        const expensesSection = document.querySelector('section.card.mt-3:has([id="fuelExpenses"])');
        if (expensesSection) expensesSection.style.display = 'none';
        
        // Change back button to go to parent.html
        const backBtn = document.getElementById('backButton');
        if (backBtn) {
          backBtn.href = '../parent.html';
          backBtn.textContent = '<- Back to Parent Dashboard';
        }
        
        // Initialize stat cards with loading state to prevent flashing
        const totalExpectedEl = document.getElementById('totalExpected');
        const totalCollectedEl = document.getElementById('totalCollected');
        const totalDebtEl = document.getElementById('totalDebt');
        const monthLabelEl = document.getElementById('monthLabel');
        
        if (totalExpectedEl) totalExpectedEl.textContent = 'Loading...';
        if (totalCollectedEl) totalCollectedEl.textContent = 'Loading...';
        if (totalDebtEl) totalDebtEl.textContent = 'Loading...';
        if (monthLabelEl) monthLabelEl.textContent = '';
        if (classFilter) classFilter.style.display = "none";
        if (searchInput) searchInput.style.display = "none";
        if (statusFilter) statusFilter.style.display = "none";
        const debtorsBtn = document.getElementById('debtorsBtnText')?.parentElement;
        if (debtorsBtn) debtorsBtn.style.display = "none";
        
        // Load and render immediately using strict year-scoped data
        renderYearScopedStudentView(studentParam).catch(err => {
          console.error('Error rendering single-student transport payment:', err);
          if (totalExpectedEl) totalExpectedEl.textContent = 'Error';
          if (totalCollectedEl) totalCollectedEl.textContent = 'Error';
          if (totalDebtEl) totalDebtEl.textContent = 'Error';
        });
      } else {
        const backBtn = document.getElementById('backButton');
        if (backBtn) { backBtn.href = 'transport.html'; backBtn.textContent = '<- Back to Dashboard'; }
        loadAllData();
      }

      // Listen to year changes for single-student view
      if (window.somapYearContext) {
        window.somapYearContext.onYearChanged((year) => {
          const studentId = state.currentPaymentStudentId;
          const urlParams = new URLSearchParams(window.location.search);
          const studentParam = urlParams.get('studentKey') || urlParams.get('student');
          if (studentParam) {
            const newYear = parseInt(year) || state.year;
            state.year = newYear;
            renderYearScopedStudentView(studentId || studentParam);
          }
        });
      }
    </script>
  </body>
</html>
