<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Transport Payments - Management & Debt Tracking</title>
    <link rel="stylesheet" href="./css/transport_dark.css" />
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-storage-compat.js"></script>
    <script src="../somapappv1multischool/js/context.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="../Todashboardhtml/yearContext.js"></script>
    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyBhONntRE_aRsU0y1YcPZzWud3CBfwH_a8",
        authDomain: "somaptestt.firebaseapp.com",
        databaseURL: "https://somaptestt-default-rtdb.firebaseio.com",
        projectId: "somaptestt",
        storageBucket: "somaptestt.appspot.com",
        messagingSenderId: "105526245138",
        appId: "1:105526245138:web:b8e7c0cb82a46e861965cb",
      };
      if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
    </script>
  </head>
  <body>
    <div id="contextBar" class="bar">
      <div>
        <h1>Transport Payments & Debt Management</h1>
        <small>Comprehensive payment tracking and debt monitoring - <span id="schoolNameDisplay">-</span></small>
      </div>
      <div class="context-selectors">
        <div class="date-time-display">
          <span class="label">Payment Due Date</span>
          <span class="value" id="dueDate">27th of current month</span>
        </div>
        <div>
          <label style="margin-bottom: 0.25rem; font-size: 0.75rem;">Academic Year</label>
          <select id="yearSelect" data-somap-year-select data-somap-year-min="2023" data-somap-year-max="2042" style="min-width: 100px; padding: 0.5rem;">
          </select>
        </div>
        <a id="backButton" href="transport.html" class="btn secondary"><- Back to Dashboard</a>
      </div>
    </div>

    <main>
      <!-- Financial Overview KPIs -->
      <section class="row">
        <article class="card stat-card">
          <div class="stat-label">Total Expected (This Month)</div>
          <div class="stat-value" id="totalExpected">-</div>
          <div class="stat-label" style="font-size: 0.75rem; margin-top: 0.5rem;" id="monthLabel"></div>
        </article>
        
        <article class="card stat-card">
          <div class="stat-label">Total Collected</div>
          <div class="stat-value" id="totalCollected" style="color: var(--accent-success);">-</div>
          <div class="stat-label" style="font-size: 0.75rem; margin-top: 0.5rem;">All transport payments</div>
        </article>
        
        <article class="card stat-card">
          <div class="stat-label">Total Transport Debt</div>
          <div class="stat-value" id="totalDebt" style="color: var(--accent-danger);">-</div>
          <div class="stat-label" style="font-size: 0.75rem; margin-top: 0.5rem;">Unpaid amounts</div>
        </article>
        
        <article class="card stat-card">
          <div class="stat-label">Total Expenses</div>
          <div class="stat-value" id="totalExpenses">-</div>
          <div class="stat-label" style="font-size: 0.75rem; margin-top: 0.5rem;">Fuel + Maintenance</div>
        </article>
        
        <article class="card stat-card">
          <div class="stat-label">Net Balance</div>
          <div class="stat-value" id="netBalance">-</div>
          <div class="stat-label" style="font-size: 0.75rem; margin-top: 0.5rem;">Collected - Expenses</div>
        </article>
      </section>

      <!-- Critical Alerts -->
      <section id="criticalAlerts" class="mt-3"></section>

      <!-- Students on Transport - Payment Tracking -->
      <section class="card mt-3">
        <div class="flex space center mb-2">
          <div>
            <h2 style="margin: 0;">Students on Transport - Payment Registry</h2>
            <small id="paymentSummary" class="muted"></small>
          </div>
          <div class="flex">
            <button class="btn secondary" onclick="toggleDebtorsOnly()">
              <span id="debtorsBtnText">Show Debtors Only</span>
            </button>
            <button class="btn success" onclick="exportToExcel()">Export Excel</button>
            <button class="btn" onclick="refreshData()">Refresh</button>
          </div>
        </div>

        <div class="filter-bar">
          <select id="classFilter">
            <option value="">All Classes</option>
            <option>Baby Class</option>
            <option>Middle Class</option>
            <option>Pre Unit Class</option>
            <option>Class 1</option>
            <option>Class 2</option>
            <option>Class 3</option>
            <option>Class 4</option>
            <option>Class 5</option>
            <option>Class 6</option>
            <option>Class 7</option>
          </select>
          <input id="searchInput" type="text" placeholder="Search student..." style="max-width: 300px;" />
          <select id="statusFilter">
            <option value="">All Status</option>
            <option value="paid">Paid</option>
            <option value="partial">Partially Paid</option>
            <option value="unpaid">Unpaid (DEBT)</option>
          </select>
        </div>

        <div style="overflow-x: auto; margin-top: 1.5rem;">
          <div id="loadingIndicator" class="empty" style="text-align: center; padding: 2rem; display: none;">
            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">Loading student data...</div>
            <div style="font-size: 0.875rem; color: var(--text-muted, #94a3b8);" id="loadingProgress">Please wait</div>
          </div>
          <table class="table" id="paymentsTable">
            <thead>
              <tr>
                <th>Admission No</th>
                <th>Full Name</th>
                <th>Class</th>
                <th>Date Registered</th>
                <th>Parent Contact</th>
                <th>Transport Start Date</th>
                <th>School Fee Total</th>
                <th>School Fee Paid</th>
                <th>School Debt</th>
                <th>Debt Till (School)</th>
                <th>Route (Morning)</th>
                <th>Route (Evening)</th>
                <th>Current Month Transport Fee</th>
                <th>Transport Paid</th>
                <th>Transport Debt</th>
                <th>Unpaid Months</th>
                <th>Total Combined Debt</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="paymentsBody">
              <!-- Populated by JavaScript -->
            </tbody>
          </table>
          <div id="emptyState" class="empty hidden">No students found on transport</div>
        </div>
      </section>

      <!-- Expenses Tracking -->
      <section class="card mt-3">
        <h2>Transport Expenses Tracker</h2>
        <p class="muted mb-2">Track all transport-related expenses including fuel, maintenance, repairs, etc.</p>

        <div class="grid two" style="margin-bottom: 1.5rem;">
          <div class="card"> 
            <h3 style="margin-top: 0;">Quick Stats</h3>
            <div style="display: grid; gap: 0.75rem;">
              <div style="display: flex; justify-content: space-between;">
                <span>Fuel Expenses:</span>
                <span id="fuelExpenses" style="font-weight: 600;">-</span>
              </div>
              <div style="display: flex; justify-content: space-between;">
                <span>Maintenance Expenses:</span>
                <span id="maintenanceExpenses" style="font-weight: 600;">-</span>
              </div>
              <div style="display: flex; justify-content: space-between;">
                <span>Other Expenses:</span>
                <span id="otherExpenses" style="font-weight: 600;">-</span>
              </div>
            </div>
          </div>

          <div class="card">
            <h3 style="margin-top: 0;">Add New Expense</h3>
            <div style="display: grid; gap: 0.75rem;">
              <select id="expenseCategory">
                <option value="">Select Category</option>
                <option value="FUEL">Fuel</option>
                <option value="MAINTENANCE">Maintenance</option>
                <option value="REPAIRS">Repairs</option>
                <option value="INSURANCE">Insurance</option>
                <option value="PERMITS">Permits</option>
                <option value="SALARIES">Driver Salaries</option>
                <option value="OTHER">Other</option>
              </select>
              <input id="expenseAmount" type="number" min="1" placeholder="Amount (TZS)" />
              <input id="expenseDescription" type="text" placeholder="Description" />
              <button class="btn success" onclick="addExpense()">Add Expense</button>
            </div>
          </div>
        </div>

        <div style="overflow-x: auto;">
          <table class="table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Category</th>
                <th>Description</th>
                <th>Amount</th>
                <th>Added By</th>
              </tr>
            </thead>
            <tbody id="expensesBody">
              <!-- Populated by JavaScript -->
            </tbody>
          </table>
        </div>
      </section>
    </main>

    <!-- Payment History Modal -->
    <div id="historyModal" class="modal hidden">
      <div class="modal-content" style="max-width: 1200px;">
        <div class="flex space center mb-2">
          <h2 style="margin: 0;" id="historyModalTitle">Payment History</h2>
          <button class="btn secondary" onclick="closeHistoryModal()">Close</button>
        </div>
        <div id="historyStartDateInfo" style="padding: 1rem; background: rgba(59, 130, 246, 0.1); border-radius: 12px; margin-bottom: 1rem; display: none;">
          <strong>Transport Start Date:</strong> <span id="historyStartDateValue">-</span>
        </div>
        <div style="overflow-x: auto; margin-top: 1.5rem;">
          <table class="table" id="historyTable">
            <thead>
              <tr>
                <th>Date</th>
                <th>Month</th>
                <th>Amount</th>
                <th>Method</th>
                <th>Reference</th>
                <th>Payer Name</th>
                <th>Status</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody id="historyBody">
              <!-- Populated by JavaScript -->
            </tbody>
          </table>
          <div id="historyEmpty" class="empty hidden">No payments recorded</div>
        </div>
      </div>
    </div>

    <!-- Record Payment Modal -->
    <div id="paymentModal" class="modal hidden">
      <div class="modal-content">
        <div class="flex space center mb-2">
          <h2 style="margin: 0;">Record Transport Payment</h2>
          <button class="btn secondary" onclick="closePaymentModal()">Close</button>
        </div>

        <div id="paymentAlert" class="alert hidden"></div>

        <div style="margin-bottom: 1.5rem; padding: 1rem; background: rgba(59, 130, 246, 0.1); border-radius: 12px;">
          <h3 style="margin: 0 0 0.5rem 0; font-size: 1rem;">Student Information</h3>
          <div id="paymentStudentInfo"></div>
        </div>

        <div class="grid two">
          <div>
            <label for="paymentMonth">Payment Month</label>
            <select id="paymentMonth" required>
              <option value="">Select Month</option>
              <option value="1">January</option>
              <option value="2">February</option>
              <option value="3">March</option>
              <option value="4">April</option>
              <option value="5">May</option>
              <option value="6">June</option>
              <option value="7">July</option>
              <option value="8">August</option>
              <option value="9">September</option>
              <option value="10">October</option>
              <option value="11">November</option>
              <option value="12">December</option>
            </select>
          </div>

          <div>
            <label for="paymentAmount">Amount Paid (TZS)</label>
            <input id="paymentAmount" type="number" min="1" required />
          </div>

          <div>
            <label for="paymentMethod">Payment Method</label>
            <select id="paymentMethod">
              <option>Cash</option>
              <option>M-Pesa</option>
              <option>Airtel Money</option>
              <option>TigoPesa</option>
              <option>Bank Transfer</option>
              <option>Cheque</option>
              <option>Other</option>
            </select>
          </div>

          <div>
            <label for="paymentReference">Reference/Transaction No <span style="color: red;">*</span></label>
            <input id="paymentReference" type="text" placeholder="e.g., RFX123..." required />
          </div>

          <div>
            <label for="paymentPayerName">Payer Full Name <span style="color: red;">*</span></label>
            <input id="paymentPayerName" type="text" placeholder="Parent/Guardian name" required />
          </div>

          <div>
            <label for="paymentDate">Payment Date <span style="color: red;">*</span></label>
            <input id="paymentDate" type="date" required />
          </div>
        </div>

        <div class="mt-2">
          <label for="paymentNotes">Notes (Optional)</label>
          <textarea id="paymentNotes" rows="3" placeholder="Any additional notes..."></textarea>
        </div>

        <div class="flex mt-2" style="justify-content: flex-end; gap: 1rem;">
          <button class="btn secondary" onclick="closePaymentModal()">Cancel</button>
          <button class="btn success" onclick="savePayment()">Save Payment</button>
        </div>
      </div>
    </div>

    <div id="toast" class="toast hidden"></div>

    <script src="./modules/transport_roles.js"></script>
    <script src="./modules/transport_context.js"></script>
    <script src="./modules/transport_helpers.js"></script>
    <script src="./modules/transport_pricing.js"></script>
    <script>
      const db = firebase.database();
      const schoolParams = new URLSearchParams(window.location.search);
      const initOptions = {
        db,
        allowQuerySchoolParam: true,
        redirectIfMissingSchool: true,
        multischoolPath: '../somapappv1multischool/multischool.html',
      };
      if (window.SOMAP?.init) {
        try {
          window.SOMAP.init(initOptions);
        } catch (err) {
          console.warn('SOMAP.init failed:', err);
        }
      } else if (initOptions.allowQuerySchoolParam) {
        const schoolParam = schoolParams.get('school');
        if (schoolParam && window.SOMAP?.setSchoolId) {
          window.SOMAP.setSchoolId(schoolParam);
        }
      }

      const currentSchool = window.SOMAP?.getSchool?.();
      if (!currentSchool || !currentSchool.id) {
        if (initOptions.redirectIfMissingSchool) {
          window.location.href = initOptions.multischoolPath;
        }
      }

      let schoolId = currentSchool?.id || '';
      let schoolName = currentSchool?.name || schoolId;
      const isSocratesSchool = () => schoolId === 'socrates-school' || schoolId === 'default';

      function scopedSubPath(subPath) {
        const clean = String(subPath || '').replace(/^\/+/, '');
        if (isSocratesSchool()) return `schools/${schoolId}/${clean}`;
        return clean;
      }

      function schoolRef(subPath) {
        return db.ref(window.SOMAP.P(scopedSubPath(subPath)));
      }

      function schoolPath(subPath) {
        return window.SOMAP.P(scopedSubPath(subPath));
      }

      async function scopedOrSocratesLegacy(scopedSubPath, legacyPath) {
        const scopedRef = schoolRef(scopedSubPath);
        if (!isSocratesSchool() || !legacyPath) return scopedRef.once('value');
        const scopedSnap = await scopedRef.once('value');
        const val = scopedSnap.val();
        const emptyObj = val && typeof val === 'object' && Object.keys(val).length === 0;
        if (!scopedSnap.exists() || emptyObj) {
          return db.ref(legacyPath).once('value');
        }
        return scopedSnap;
      }

      function maybeAutoAdvanceYear() {
        const ctx = window.somapYearContext;
        if (!ctx || typeof ctx.getSelectedYear !== 'function') return;
        const current = String(new Date().getFullYear());
        const selected = String(ctx.getSelectedYear());
        if (Number(current) > Number(selected)) {
          if (typeof ctx.resetToCurrentYear === 'function') {
            ctx.resetToCurrentYear();
          } else if (typeof ctx.setSelectedYear === 'function') {
            ctx.setSelectedYear(current, { manual: false, forceDispatch: true });
          }
        }
      }

      const CLASS_ORDER = ['Baby Class', 'Middle Class', 'Pre Unit Class', 'Class 1', 'Class 2', 'Class 3', 'Class 4', 'Class 5', 'Class 6', 'Class 7'];
      function shiftClass(baseClass, deltaYears) {
        const normalized = String(baseClass || '').trim();
        const idx = CLASS_ORDER.findIndex(c => c.toLowerCase() === normalized.toLowerCase());
        if (idx < 0) return baseClass || '';
        const newIdx = idx + Number(deltaYears || 0);
        if (newIdx < 0) return 'PRE-ADMISSION';
        if (newIdx >= CLASS_ORDER.length) return 'GRADUATED';
        return CLASS_ORDER[newIdx];
      }

      async function maybeRunRollover() {
        const systemYear = String(new Date().getFullYear());
        const flagRef = schoolRef(`meta/rolloverDone/${systemYear}`);
        try {
          const flagSnap = await flagRef.get();
          if (flagSnap.exists()) return;
          const previousYear = String(Number(systemYear) - 1);
          const prevEnrollSnap = await scopedOrSocratesLegacy(`years/${previousYear}/enrollments`, `enrollments/${previousYear}`);
          const prevEnrollments = prevEnrollSnap.val() || {};
          const nowIso = new Date().toISOString();
          const updates = {};

          Object.entries(prevEnrollments).forEach(([studentKey, record]) => {
            const baseClass = (record && (record.className || record.classLevel)) || '';
            const nextClass = shiftClass(baseClass, 1);
            if (nextClass === 'GRADUATED') {
              updates[schoolPath(`years/${systemYear}/graduated/${studentKey}`)] = {
                className: baseClass || 'Class 7',
                promotedAt: nowIso,
                fromYear: Number(previousYear)
              };
              updates[schoolPath(`years/${systemYear}/enrollments/${studentKey}`)] = {
                className: 'GRADUATED',
                promotedFrom: baseClass || 'Class 7',
                fromYear: Number(previousYear),
                at: firebase.database.ServerValue.TIMESTAMP
              };
            } else {
              updates[schoolPath(`years/${systemYear}/enrollments/${studentKey}`)] = {
                className: nextClass,
                promotedFrom: baseClass,
                fromYear: Number(previousYear),
                at: firebase.database.ServerValue.TIMESTAMP
              };
            }
          });

          updates[schoolPath(`meta/rolloverDone/${systemYear}`)] = true;
          await db.ref().update(updates);
        } catch (err) {
          console.warn('Year rollover skipped/failed:', err);
        }
      }

      const schoolNameDisplay = document.getElementById('schoolNameDisplay');
      if (schoolNameDisplay) {
        schoolNameDisplay.textContent = schoolName
          || (isSocratesSchool() ? 'Socrates School' : schoolId)
          || 'Socrates School';
      }

      // Allow deep links to set the active year via the shared helper
      (function syncYearFromUrl() {
        const params = new URLSearchParams(window.location.search);
        const y = parseInt(params.get('year'), 10);
        if (Number.isFinite(y) && window.somapYearContext?.setSelectedYear) {
          window.somapYearContext.setSelectedYear(String(y), { manual: false, forceDispatch: true });
        }
      })();

      // Global State
      const state = {
        user: null,
        role: null,
        year: (() => {
          const rawYear = window.somapYearContext?.getSelectedYear?.();
          const parsed = parseInt(rawYear, 10);
          return Number.isFinite(parsed) ? parsed : new Date().getFullYear();
        })(),
        month: new Date().getMonth() + 1,
        schoolId,
        schoolName,
        students: {},
        transportEnrollments: {},
        financeData: {},
        transportPayments: {},
        expenses: {},
        showDebtorsOnly: false,
        currentPaymentStudentId: null,
      };

      state.year = Number(state.year) || new Date().getFullYear();
      state.month = Number(state.month) || new Date().getMonth() + 1;

      const MONTH_NAMES = ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      const CLASS_ORDER = ['Baby Class', 'Middle Class', 'Pre Unit Class', 'Class 1', 'Class 2', 'Class 3', 'Class 4', 'Class 5', 'Class 6', 'Class 7'];
      const BASE_YEAR = 2025;
      
      // Store loaded multipliers per year
      let cachedMultipliers = {};

      function getFocusedMonth() {
        const today = new Date();
        // Only honor state.month when explicitly provided via URL or user selection
        if (state.monthSelectedFromUrl === true) {
          const parsed = Number(state.month);
          if (Number.isFinite(parsed) && parsed >= 1 && parsed <= 12) return parsed;
        }
        if (today.getFullYear() === Number(state.year)) return today.getMonth() + 1;
        return 1;
      }

      function normalizeDateInput(raw, fallbackYear = Number(state.year)) {
        if (raw === null || raw === undefined || raw === '') {
          const yr = Number.isFinite(fallbackYear) ? fallbackYear : new Date().getFullYear();
          return `${yr}-01-01`;
        }
        if (typeof raw === 'number') {
          const d = new Date(raw);
          if (!Number.isNaN(d.getTime())) return d.toISOString().slice(0, 10);
        }
        const text = String(raw).trim();
        if (/^\d{4}-\d{2}-\d{2}$/.test(text)) return text;
        if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(text)) {
          const [dd, mm, yy] = text.split('/').map(Number);
          const date = new Date(yy, mm - 1, dd);
          if (!Number.isNaN(date.getTime())) return date.toISOString().slice(0, 10);
        }
        const tryDate = new Date(text);
        if (!Number.isNaN(tryDate.getTime())) return tryDate.toISOString().slice(0, 10);
        const yr = Number.isFinite(fallbackYear) ? fallbackYear : new Date().getFullYear();
        return `${yr}-01-01`;
      }

      function resolveStartDate(enrollment) {
        if (!enrollment) return normalizeDateInput(null);
        if (enrollment.startDate) return normalizeDateInput(enrollment.startDate);
        if (enrollment.start_date) return normalizeDateInput(enrollment.start_date);
        if (enrollment.startTimestamp) return normalizeDateInput(Number(enrollment.startTimestamp));
        if (enrollment.start_time) return normalizeDateInput(enrollment.start_time);
        if (enrollment.dateRegistered) return normalizeDateInput(enrollment.dateRegistered);
        return normalizeDateInput(null);
      }

      function formatStartDateDisplay(value) {
        if (!value) return 'N/A';
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return String(value);
        return date.toLocaleDateString('en-GB');
      }

      // Phone normalization
      function normalizePhone(p) {
        const s = String(p || '').replace(/[\s\-()]/g, '');
        return s.replace(/(?!^\+)[^\d]/g, '');
      }

      const toast = document.getElementById("toast");
      const yearSelect = document.getElementById("yearSelect");
      const classFilter = document.getElementById("classFilter");
      const searchInput = document.getElementById("searchInput");
      const statusFilter = document.getElementById("statusFilter");
      const paymentsBody = document.getElementById("paymentsBody");
      
      // Initialize year from context
      if (window.somapYearContext) {
        const currentYear = window.somapYearContext.getSelectedYear();
        state.year = parseInt(currentYear) || state.year;
        if (yearSelect) yearSelect.value = state.year;
      }

      // Utility Functions
      function showToast(message, tone = "ok") {
        toast.textContent = message;
        toast.classList.remove("hidden");
        toast.style.background = tone === "bad" ? "#ef4444" : "#10b981";
        setTimeout(() => toast.classList.add("hidden"), 3500);
      }

      function resolveRecorder() {
        if (state.user && state.user.email) return state.user.email;
        if (state.user && state.user.uid) return state.user.uid;
        return "unknown";
      }

      function formatCurrency(amount) {
        return new Intl.NumberFormat('en-TZ', { style: 'currency', currency: 'TZS', minimumFractionDigits: 0 }).format(amount || 0);
      }

      function formatDate(timestamp) {
        if (!timestamp) return 'N/A';
        const date = new Date(timestamp);
        return date.toLocaleDateString('en-GB');
      }

      // Calculate school debt till
      function calculateDebtTill(student) {
        // This matches the finance.html logic
        const feePerYear = Number(student.feePerYear) || 0;
        const payments = student.payments || {};
        const totalPaid = Object.values(payments).reduce((sum, p) => sum + (Number(p.amount) || 0), 0);
        
        // Simple calculation - in real app, this would match finance.html installment logic
        const debt = Math.max(0, feePerYear - totalPaid);
        return debt > 0 ? `Inst ${Math.min(6, Math.ceil(debt / (feePerYear / 6)))}` : '-';
      }

      // Calculate base monthly fee (without month multipliers) - for display in table
      // Now date-aware: uses priceHistory for the selected month
      async function calculateBaseMonthlyFee(amStop, pmStop, year, month) {
        return await TransportPricing.computeBaseMonthlyFeeOnMonth({ year, month, amStop, pmStop });
      }

      // Calculate transport payment status (now year-scoped with DB multipliers) - OPTIMIZED with parallel month calculations and caching
      async function calculateTransportStatus(enrollment, payments, yearMultipliers, studentId = null) {
        // Check cache first to avoid recalculation
        if (studentId) {
          const cacheKey = getCacheKey(studentId, state.year);
          if (statusCache.has(cacheKey)) {
            return statusCache.get(cacheKey);
          }
        }

        const amStop = enrollment?.amStop || '';
        const pmStop = enrollment?.pmStop || '';
        const year = Number(state.year) || new Date().getFullYear();

        // Use year-specific multipliers if provided, otherwise load from DB
        const multipliers = yearMultipliers || cachedMultipliers[year] || (await TransportPricing.loadYearMultipliers(year));
        if (!cachedMultipliers[year]) cachedMultipliers[year] = multipliers;

        // Base monthly fee (without multipliers) - for display & calculations
        // Use date-aware pricing: compute base fee for focused month
        const selectedMonth = getFocusedMonth();
        const baseMonthlyFee = Number(enrollment?.baseMonthlyFee) || 
          (await calculateBaseMonthlyFee(amStop, pmStop, year, selectedMonth));
        const startDateIso = resolveStartDate(enrollment);
        const hasExplicitStart = Boolean(enrollment?.startDate || enrollment?.start_date || enrollment?.startTimestamp || enrollment?.start_time);

        const paymentsArray = Array.isArray(payments) ? payments : Object.values(payments || {});

        // OPTIMIZATION: Calculate all 12 months in parallel instead of sequentially
        const monthCalculations = Array.from({ length: 12 }, (_, i) => i + 1).map(month =>
          TransportPricing.dueForMonth({
            year,
            month,
            amStop,
            pmStop,
            baseMonthlyFee,
            startDate: startDateIso,
            multipliers,
          }).then(monthlyExpected => {
            const expected = Math.round(monthlyExpected || 0);
            // Handle both number and month name formats for payments
            const monthPayments = paymentsArray.filter(p => {
              if (typeof p.month === 'number') return p.month === month;
              if (typeof p.month === 'string') return MONTH_NAMES[month] === p.month;
              return false;
            });
            const monthPaid = monthPayments.reduce((sum, p) => sum + (Number(p.amount) || 0), 0);
            return { month, expected, paid: monthPaid };
          })
        );

        const monthResults = await Promise.all(monthCalculations);
        
        let totalExpected = 0;
        let totalPaid = 0;
        const unpaidMonths = [];

        monthResults.forEach(({ month, expected, paid }) => {
          totalExpected += expected;
          totalPaid += paid;
          if ((paid + 0.01) < expected && expected > 0) {
            unpaidMonths.push(MONTH_NAMES[month]);
          }
        });

        const debt = Math.max(0, totalExpected - totalPaid);

        // Current month expected (already calculated above, reuse result)
        const currentMonthResult = monthResults.find(r => r.month === selectedMonth);
        const currentMonthExpected = currentMonthResult ? currentMonthResult.expected : Math.round(
          await TransportPricing.dueForMonth({
            year,
            month: selectedMonth,
            amStop,
            pmStop,
            baseMonthlyFee,
            startDate: startDateIso,
            multipliers,
          }) || 0
        );

        const result = {
          totalExpected,
          totalPaid,
          debt,
          unpaidMonths: unpaidMonths.join(', ') || 'None',
          monthlyFee: baseMonthlyFee, // Base fee for table display (e.g., 35,500)
          currentMonthExpected, // Month-specific fee with multiplier for KPIs
          startDateIso,
          startDateDisplay: hasExplicitStart ? formatStartDateDisplay(startDateIso) : 'N/A',
        };

        // Cache the result
        if (studentId) {
          const cacheKey = getCacheKey(studentId, state.year);
          statusCache.set(cacheKey, result);
        }

        return result;
      }

      // Render KPIs - only for admin view, not parent view (now async for DB multipliers) - OPTIMIZED with parallel processing
      async function renderKPIs() {
        // Skip if parent view (stat cards already rendered by renderParentTransportPayment)
        const monthForKpi = getFocusedMonth();
        const kpiMonthLabel = MONTH_NAMES[monthForKpi] || ('Month ' + monthForKpi);
        const urlParams = new URLSearchParams(window.location.search);
        const studentParam = urlParams.get('studentKey');
        if (studentParam) {
          return; // Don't render KPIs in parent view
        }
        
        // Load year multipliers once for all calculations
        const year = Number(state.year);
        const multipliers = cachedMultipliers[year] || (await TransportPricing.loadYearMultipliers(year));
        if (!cachedMultipliers[year]) cachedMultipliers[year] = multipliers;
        
        // OPTIMIZATION: Process all students in parallel instead of sequentially with caching
        const statusPromises = Object.entries(state.transportEnrollments).map(async ([studentId, enrollment]) => {
          const payments = Object.values(state.transportPayments[studentId] || {});
          return await calculateTransportStatus(enrollment, payments, multipliers, studentId);
        });

        const allStatuses = await Promise.all(statusPromises);
        
        let totalExpected = 0;
        let totalCollected = 0;
        let totalDebt = 0;
        let criticalDebtors = 0;

        allStatuses.forEach(status => {
          // Use currentMonthExpected for KPI (includes month multiplier)
          totalExpected += status.currentMonthExpected;
          totalCollected += status.totalPaid;
          totalDebt += status.debt;
          if (status.debt > 0) criticalDebtors++;
        });

        // Calculate expenses
        const expensesArray = Object.values(state.expenses);
        const totalExpenses = expensesArray.reduce((sum, exp) => sum + (Number(exp.amount) || 0), 0);
        const fuelExp = expensesArray.filter(e => e.category === 'FUEL').reduce((sum, e) => sum + (Number(e.amount) || 0), 0);
        const maintExp = expensesArray.filter(e => e.category === 'MAINTENANCE' || e.category === 'REPAIRS').reduce((sum, e) => sum + (Number(e.amount) || 0), 0);
        const otherExp = totalExpenses - fuelExp - maintExp;

        document.getElementById('totalExpected').textContent = formatCurrency(totalExpected);
        document.getElementById('totalCollected').textContent = formatCurrency(totalCollected);
        document.getElementById('totalDebt').textContent = formatCurrency(totalDebt);
        document.getElementById('totalExpenses').textContent = formatCurrency(totalExpenses);
        document.getElementById('netBalance').textContent = formatCurrency(totalCollected - totalExpenses);
        document.getElementById('monthLabel').textContent = `${kpiMonthLabel} ${state.year}`;

        document.getElementById('fuelExpenses').textContent = formatCurrency(fuelExp);
        document.getElementById('maintenanceExpenses').textContent = formatCurrency(maintExp);
        document.getElementById('otherExpenses').textContent = formatCurrency(otherExp);

        // Critical alerts for unpaid students
        if (criticalDebtors > 0) {
          document.getElementById('criticalAlerts').innerHTML = `
            <div class="alert red" style="animation: pulse 2s infinite;">
              <strong>ALERT:</strong> ${criticalDebtors} student(s) have unpaid transport fees. 
              Payment deadline is the 27th of each month for the following month.
            </div>
          `;
        } else {
          document.getElementById('criticalAlerts').innerHTML = '';
        }
      }

      // Render payments table (now async for DB multipliers) - OPTIMIZED with parallel processing, early filtering, and progressive rendering
      async function renderPaymentsTable() {
        const loadingIndicator = document.getElementById('loadingIndicator');
        const loadingProgress = document.getElementById('loadingProgress');
        const filterClass = classFilter.value;
        const searchTerm = searchInput.value.toLowerCase();
        const filterStatus = statusFilter.value;
        const yearDelta = state.year - BASE_YEAR;

        // Show loading indicator
        if (loadingIndicator) {
          loadingIndicator.style.display = 'block';
          paymentsBody.innerHTML = '';
        }

        // Load year multipliers once for all calculations
        const year = Number(state.year);
        const multipliers = cachedMultipliers[year] || (await TransportPricing.loadYearMultipliers(year));
        if (!cachedMultipliers[year]) cachedMultipliers[year] = multipliers;

        const allEntries = Object.entries(state.transportEnrollments);
        
        // OPTIMIZATION: Pre-filter students before expensive calculations
        const preFiltered = [];
        for (const [studentId, enrollment] of allEntries) {
          const student = state.students[studentId];
          if (!student) continue;

          // Calculate class for selected year
          const baseClass = student.classLevel || '';
          const shiftedClass = shiftClass(baseClass, yearDelta);
          
          // Skip if graduated (for future years)
          if (shiftedClass === 'GRADUATED' && state.year > BASE_YEAR) {
            continue;
          }

          const matchesClass = !filterClass || shiftedClass === filterClass;
          const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.toLowerCase();
          const matchesSearch = !searchTerm || 
            fullName.includes(searchTerm) || 
            (student.admissionNumber || '').toLowerCase().includes(searchTerm);

          // Only add to pre-filtered if class and search match (status and debt filters need calculation)
          if (matchesClass && matchesSearch) {
            preFiltered.push([studentId, enrollment, student, shiftedClass]);
          }
        }

        if (preFiltered.length === 0) {
          if (loadingIndicator) loadingIndicator.style.display = 'none';
          paymentsBody.innerHTML = '';
          document.getElementById('emptyState').classList.remove('hidden');
          document.getElementById('paymentSummary').textContent = '0 students found';
          return;
        }

        // Update progress
        if (loadingProgress) {
          loadingProgress.textContent = `Calculating status for ${preFiltered.length} students...`;
        }

        // OPTIMIZATION: Process in smaller batches for progressive rendering on slow connections
        const BATCH_SIZE = 20;
        const allStatuses = [];
        
        for (let i = 0; i < preFiltered.length; i += BATCH_SIZE) {
          const batch = preFiltered.slice(i, i + BATCH_SIZE);
          const statusPromises = batch.map(async ([studentId, enrollment]) => {
            const payments = Object.values(state.transportPayments[studentId] || {});
            const status = await calculateTransportStatus(enrollment, payments, multipliers, studentId);
            return [studentId, enrollment, status];
          });
          
          const batchResults = await Promise.all(statusPromises);
          allStatuses.push(...batchResults);
          
          // Update progress
          if (loadingProgress && i % (BATCH_SIZE * 2) === 0) {
            loadingProgress.textContent = `Processing ${Math.min(i + BATCH_SIZE, preFiltered.length)}/${preFiltered.length} students...`;
          }
        }
        
        // Hide loading indicator
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        
        // Apply status and debt filters after calculations
        const filtered = [];
        for (let i = 0; i < allStatuses.length; i++) {
          const [studentId, enrollment, status] = allStatuses[i];
          const [, , student, shiftedClass] = preFiltered[i];
          
          let matchesStatus = true;
          if (filterStatus === 'paid') matchesStatus = status.debt === 0;
          if (filterStatus === 'partial') matchesStatus = status.debt > 0 && status.totalPaid > 0;
          if (filterStatus === 'unpaid') matchesStatus = status.totalPaid === 0;

          const matchesDebtFilter = !state.showDebtorsOnly || status.debt > 0;

          if (matchesStatus && matchesDebtFilter) {
            filtered.push([studentId, enrollment, status]);
          }
        }

        if (filtered.length === 0) {
          paymentsBody.innerHTML = '';
          document.getElementById('emptyState').classList.remove('hidden');
          document.getElementById('paymentSummary').textContent = '0 students found';
          return;
        }

        document.getElementById('emptyState').classList.add('hidden');
        document.getElementById('paymentSummary').textContent = `${filtered.length} student(s) on transport`;

        // Sort by debt (highest first)
        filtered.sort((a, b) => b[2].debt - a[2].debt);

        paymentsBody.innerHTML = filtered.map(([studentId, enrollment, transportStatus]) => {
          const student = state.students[studentId];
          const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
          
          // Calculate class for selected year
          const yearDelta = state.year - BASE_YEAR;
          const baseClass = student.classLevel || '';
          const shiftedClass = shiftClass(baseClass, yearDelta);
          const selectedMonth = getFocusedMonth();
          const selectedMonthName = MONTH_NAMES[selectedMonth] || 'Current';
          const startDateDisplay = transportStatus.startDateDisplay || 'N/A';
          const baseFeeDisplay = formatCurrency(transportStatus.monthlyFee);
          const currentMonthDue = transportStatus.currentMonthExpected;
          
          // School finance data
          const feePerYear = Number(student.feePerYear) || 0;
          const schoolPayments = student.payments || {};
          const schoolPaid = Object.values(schoolPayments).reduce((sum, p) => sum + (Number(p.amount) || 0), 0);
          const schoolDebt = Math.max(0, feePerYear - schoolPaid);
          const debtTill = calculateDebtTill(student);
          
          // Combined debt
          const combinedDebt = schoolDebt + transportStatus.debt;
          
          // Critical status - red background if has debt
          const isDebtor = transportStatus.debt > 0 || schoolDebt > 0;
          const rowClass = isDebtor ? 'style="background: rgba(239, 68, 68, 0.15); font-weight: 600;"' : '';
          
          const debtWarning = isDebtor ? '<span style="color: var(--accent-danger); font-weight: 800; font-size: 0.75rem;">&#9888; USIMCHUKUE ANADAIWA</span>' : '';
          
          return `
            <tr ${rowClass}>
              <td>${student.admissionNumber || 'N/A'}</td>
              <td>${fullName}${debtWarning ? '<br>' + debtWarning : ''}</td>
              <td>${shiftedClass}</td>
              <td>${formatDate(student.timestamp || student.createdAt)}</td>
              <td>${student.primaryParentContact || 'N/A'}</td>
              <td>${startDateDisplay}</td>
              <td>${formatCurrency(feePerYear)}</td>
              <td>${formatCurrency(schoolPaid)}</td>
              <td style="color: ${schoolDebt > 0 ? 'var(--accent-danger)' : 'var(--accent-success)'};">
                ${formatCurrency(schoolDebt)}
              </td>
              <td>${debtTill}</td>
              <td>${enrollment.amStop || '&mdash;'}</td>
              <td>${enrollment.pmStop || '&mdash;'}</td>
              <td title="Base fee before multiplier: ${baseFeeDisplay}">
                ${formatCurrency(currentMonthDue)}<br>
                <span style="font-size: 0.7rem; color: var(--text-muted, #94a3b8);">
                  Base: ${baseFeeDisplay} &#183; ${selectedMonthName}
                </span>
              </td>
              <td style="color: var(--accent-success);">${formatCurrency(transportStatus.totalPaid)}</td>
              <td style="color: ${transportStatus.debt > 0 ? 'var(--accent-danger)' : 'var(--accent-success)'};">
                ${formatCurrency(transportStatus.debt)}
              </td>
              <td style="font-size: 0.75rem;">${transportStatus.unpaidMonths}</td>
              <td style="color: ${combinedDebt > 0 ? 'var(--accent-danger)' : 'var(--accent-success)'}; font-weight: 700;">
                ${formatCurrency(combinedDebt)}
              </td>
              <td class="table-actions" style="justify-content: flex-end;">
                <button class=\"btn success\" onclick=\"openPaymentModal('${studentId}')\">&#128176; Pay</button>
                <button class=\"btn secondary\" onclick=\"viewPaymentHistory('${studentId}')\">&#128221; History</button>
              </td>
            </tr>
          `;
        }).join('');
      }

      // Toggle debtors only
      function toggleDebtorsOnly() {
        state.showDebtorsOnly = !state.showDebtorsOnly;
        document.getElementById('debtorsBtnText').textContent = state.showDebtorsOnly ? 'Show All' : 'Show Debtors Only';
        renderPaymentsTable();
      }

      // Open payment modal (with year-scoped multipliers)
      async function openPaymentModal(studentId) {
        state.currentPaymentStudentId = studentId;
        const student = state.students[studentId];
        const enrollment = state.transportEnrollments[studentId];
        
        if (!student || !enrollment) return;
        
        const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
        const payments = Object.values(state.transportPayments[studentId] || {});
        
        // Check if we have year-scoped assignment data (parent view)
        const year = String(state.year);
        
        // Load year multipliers for accurate calculations
        const multipliers = cachedMultipliers[Number(year)] || (await TransportPricing.loadYearMultipliers(Number(year)));
        if (!cachedMultipliers[Number(year)]) cachedMultipliers[Number(year)] = multipliers;
        
        let status, baseMonthlyFee, currentMonthAmount, currentMonthLabel;
        const focusedMonth = getFocusedMonth();
        const focusedMonthLabel = MONTH_NAMES[focusedMonth] || ('Month ' + focusedMonth);
        const enrollmentStart = resolveStartDate(enrollment);

        try {
          const assignSnap = await scopedOrSocratesLegacy(`years/${year}/transportAssignments/${studentId}`, `transportAssignments/${year}/${studentId}`);
          const assign = assignSnap.val();
          
          if (assign && assign.status === 'Using') {
            baseMonthlyFee = Number(assign.baseMonthlyFee || 0) || Number(enrollment.baseMonthlyFee || 0);
            const startDate = normalizeDateInput(assign.startDate || enrollmentStart, Number(year));
        const hasAssignedStart = Boolean(assign?.startDate || assign?.start_date || assign?.startTimestamp || assign?.start_time);
            
            currentMonthLabel = focusedMonthLabel;
            currentMonthAmount = Math.round(await TransportPricing.dueForMonth({
              year: Number(year),
              month: focusedMonth,
              amStop: assign?.amStop || enrollment?.amStop,
              pmStop: assign?.pmStop || enrollment?.pmStop,
              baseMonthlyFee,
              startDate,
              multipliers // Pass year-specific multipliers
            }));
            
            const ledger = await TransportPricing.buildLedger({
              year: Number(year),
              amStop: assign?.amStop || enrollment?.amStop,
              pmStop: assign?.pmStop || enrollment?.pmStop,
              baseMonthlyFee,
              startDate,
              payments,
              multipliers // Pass year-specific multipliers
            });
            
            status = {
              monthlyFee: baseMonthlyFee,
              currentMonthExpected: currentMonthAmount,
              debt: ledger.totals.balance,
              totalExpected: ledger.totals.due,
              totalPaid: ledger.totals.paid,
              unpaidMonths: ledger.months.filter(m => m.status === 'UNPAID' || m.status === 'PARTIAL').map(m => MONTH_NAMES[m.month]).join(', ') || 'None',
              startDateIso: startDate,
              startDateDisplay: formatStartDateDisplay(startDate),
            };
          } else {
            status = await calculateTransportStatus(enrollment, payments, multipliers);
            baseMonthlyFee = status.monthlyFee;
            currentMonthLabel = focusedMonthLabel;
            currentMonthAmount = Math.round(await TransportPricing.dueForMonth({
              year: Number(year),
              month: focusedMonth,
              amStop: enrollment?.amStop,
              pmStop: enrollment?.pmStop,
              baseMonthlyFee,
              startDate: enrollmentStart,
              multipliers // Pass year-specific multipliers
            }) || status.currentMonthExpected || status.monthlyFee);
          }
        } catch (err) {
          console.warn('Error loading assignment data, using legacy:', err);
          status = await calculateTransportStatus(enrollment, payments, multipliers);
          baseMonthlyFee = status.monthlyFee;
          currentMonthLabel = focusedMonthLabel;
          currentMonthAmount = Math.round(await TransportPricing.dueForMonth({
            year: Number(year),
            month: focusedMonth,
            amStop: enrollment?.amStop,
            pmStop: enrollment?.pmStop,
            baseMonthlyFee,
            startDate: enrollmentStart,
            multipliers // Pass year-specific multipliers
          }) || status.currentMonthExpected || status.monthlyFee);
        }
        
        document.getElementById('paymentStudentInfo').innerHTML = `
          <div style="display: grid; gap: 0.5rem; font-size: 0.875rem;">
            <div><strong>Name:</strong> ${fullName}</div>
            <div><strong>Admission No:</strong> ${student.admissionNumber}</div>
            <div><strong>Class:</strong> ${student.classLevel}</div>
            <div><strong>Base Monthly Fee:</strong> ${formatCurrency(baseMonthlyFee)}</div>
            <div><strong>Current Month Fee (${currentMonthLabel || focusedMonthLabel}):</strong> ${formatCurrency(currentMonthAmount)}</div>
            <div><strong>Total Debt:</strong> <span style="color: var(--accent-danger);">${formatCurrency(status.debt)}</span></div>
            <div><strong>Unpaid Months:</strong> ${status.unpaidMonths}</div>
            <div><strong>Transport Start:</strong> ${status.startDateDisplay || formatStartDateDisplay(enrollmentStart)}</div>
          </div>
        `;
        // Set current month as default using focused context
        document.getElementById('paymentMonth').value = String(focusedMonth);
        document.getElementById('paymentAmount').value = currentMonthAmount;
        document.getElementById('paymentDate').valueAsDate = new Date();
        document.getElementById('paymentReference').value = '';
        document.getElementById('paymentPayerName').value = '';
        document.getElementById('paymentNotes').value = '';
        
        document.getElementById('paymentModal').classList.remove('hidden');
      }

      function closePaymentModal() {
        document.getElementById('paymentModal').classList.add('hidden');
        document.getElementById('paymentAlert').classList.add('hidden');
        state.currentPaymentStudentId = null;
      }

      // Save payment (enhanced: also write to canonical year path)
      async function savePayment() {
        const studentId = state.currentPaymentStudentId;
        const month = parseInt(document.getElementById('paymentMonth').value);
        const amount = parseFloat(document.getElementById('paymentAmount').value);
        const method = document.getElementById('paymentMethod').value;
        const reference = document.getElementById('paymentReference').value.trim();
        const payerName = document.getElementById('paymentPayerName').value.trim();
        const paymentDate = document.getElementById('paymentDate').value;
        const notes = document.getElementById('paymentNotes').value.trim();
        
        // Validate all mandatory fields
        if (!month || !amount || amount <= 0 || !method || !reference || !payerName || !paymentDate) {
          showToast('Please fill in ALL required fields (Month, Amount, Method, Reference, Payer Name, Payment Date)', 'bad');
          return;
        }
        
        try {
          const student = state.students[studentId];
          const enrollment = state.transportEnrollments[studentId];
          if (!student || !enrollment) throw new Error('Student transport enrollment not found.');
          const payments = Object.values(state.transportPayments[studentId] || {});
          const multipliers = cachedMultipliers[Number(state.year)] || (await TransportPricing.loadYearMultipliers(Number(state.year)));
          if (!cachedMultipliers[Number(state.year)]) cachedMultipliers[Number(state.year)] = multipliers;
          const status = await calculateTransportStatus(enrollment, payments, multipliers);
          const recorder = resolveRecorder();
          // Convert payment date to timestamp (local timezone - Africa/Nairobi)
          const paidAt = new Date(paymentDate + 'T12:00:00').getTime();
          const timestamp = Date.now();
          const pendingRef = schoolRef('approvalsPending').push();
          const monthName = MONTH_NAMES[month] || `Month ${month}`;
          const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.replace(/\s+/g, ' ').trim();
          const totalRequired = Number(status.totalExpected || 0);
          const totalPaidBefore = Number(status.totalPaid || 0);
          const newBalance = Math.max(0, totalRequired - Math.min(totalRequired, totalPaidBefore + amount));

          // Also write to transport ledger as pending (for parent view and history)
          const yearStr = String(state.year);
          const payRef = schoolRef(`years/${yearStr}/transportLedgers/${studentId}/payments`).push();
          
          const paymentData = {
            month: monthName,
            amount,
            method,
            ref: reference,
            payerName,
            paidAt,
            notes: notes || null,
            createdBy: state.user ? 'parent' : 'staff',
            createdByUid: state.user?.uid || null,
            approved: false,
            approvedBy: null,
            approvedAt: null,
            timestamp
          };
          
          await payRef.set(paymentData);

          // Canonical write: transportPayments/{year}/{studentId}/{paymentId}
          const canonical = {
            month,
            amount,
            method,
            reference,
            payerName,
            paidAt,
            notes: notes || '',
            status: 'pending',
            createdAt: timestamp
          };
          await schoolRef(`years/${yearStr}/transportPayments/${studentId}`).push(canonical);
          
          // Queue for approval - include payment key for matching
          const queueRef = schoolRef(`pendingApprovals/transportPayments/${payRef.key}`);
          await queueRef.set({
            year: yearStr,
            studentId,
            admissionNumber: student.admissionNumber || studentId,
            studentName: fullName,
            parentPhone: student.primaryParentContact || student.primaryContact || student.guardianPhone || '--',
            paymentRef: payRef.key, // Store the ledger payment key for approval matching
            ...paymentData,
            queuedAt: timestamp
          });

          // Legacy approval queue (keep for backward compatibility)
          await pendingRef.set({
            approvalId: pendingRef.key,
            sourceModule: 'transport',
            studentAdm: student.admissionNumber || studentId,
            studentName: fullName || (student.admissionNumber || studentId),
            className: student.classLevel || '',
            parentContact: student.primaryParentContact || student.primaryContact || student.guardianPhone || '--',
            amountPaidNow: amount,
            paymentMethod: method,
            paymentReferenceCode: reference,
            payerName: payerName,
            paymentDate: paymentDate,
            datePaid: paidAt,
            recordedBy: recorder,
            status: 'pending',
            notes,
            totalRequired,
            totalPaidBefore,
            newBalanceAfterThis: newBalance,
            createdAt: firebase.database.ServerValue.TIMESTAMP,
            modulePayload: {
              studentKey: studentId,
              payment: {
                studentId,
                month,
                year: state.year,
                amount,
                method,
                reference,
                payerName,
                paidAt,
                notes,
                timestamp,
                recordedBy: recorder,
              },
              breakdown: [
                { label: 'Month', value: monthName },
                { label: 'Year', value: state.year },
                { label: 'Route', value: `` },
                { label: 'Expected (Year)', value: formatCurrency(status.totalExpected) },
                { label: 'Paid Before', value: formatCurrency(status.totalPaid) },
                { label: 'Debt Before', value: formatCurrency(status.debt) },
              ],
            },
          });

          showToast('Payment pending admin approval.', 'ok');
          closePaymentModal();
          
          // Refresh based on view mode
          const urlParams = new URLSearchParams(window.location.search);
          const studentParam = urlParams.get('studentKey');
          if (studentParam) {
            // Single-student view - reload that student only
            renderYearScopedStudentView(studentParam);
          } else {
            // Admin view - reload all data
            loadAllData();
          }
        } catch (error) {
          console.error('Error saving payment:', error);
          showToast('Failed to save payment', 'bad');
        }
      }

      // View payment history - with real-time approval status
      async function viewPaymentHistory(studentId) {
        const student = state.students[studentId];
        if (!student) {
          showToast('Student not found', 'bad');
          return;
        }
        
        // Load transport assignment to get start date
        const year = String(state.year);
        try {
          const assignSnap = await scopedOrSocratesLegacy(`years/${year}/transportAssignments/${studentId}`, `transportAssignments/${year}/${studentId}`);
          const assign = assignSnap.val();
          const rawStart = assign?.startDate || assign?.start_date || assign?.startTimestamp || assign?.start_time;
          if (rawStart) {
            const normalized = normalizeDateInput(rawStart, Number(year));
            document.getElementById('historyStartDateValue').textContent = formatStartDateDisplay(normalized);
            document.getElementById('historyStartDateInfo').style.display = 'block';
          } else {
            document.getElementById('historyStartDateInfo').style.display = 'none';
          }
        } catch (err) {
          console.warn('Error loading start date:', err);
          document.getElementById('historyStartDateInfo').style.display = 'none';
        }
        
        let payments = state.transportPayments[studentId] || {};
        
        // Handle array or object format
        if (Array.isArray(payments)) {
          payments = payments.sort((a, b) => (b.timestamp || b.paidAt || 0) - (a.timestamp || a.paidAt || 0));
        } else if (payments && typeof payments === 'object') {
          payments = Object.values(payments).sort((a, b) => (b.timestamp || b.paidAt || 0) - (a.timestamp || a.paidAt || 0));
        } else {
          payments = [];
        }
        
        // Also check pendingApprovals to get latest approval status
        try {
          const pendingSnap = await schoolRef('pendingApprovals/transportPayments').once('value');
          const pendingApprovals = pendingSnap.val() || {};
          
          // Create a map of payment keys to approval status
          const approvalMap = {};
          Object.entries(pendingApprovals).forEach(([key, approval]) => {
            if (approval && approval.studentId === studentId && approval.ref) {
              // Match by reference code for accurate matching
              approvalMap[approval.ref] = {
                approved: false,
                pending: true
              };
            }
          });
          
          // Also check approvalsHistory for approved payments
          const year = String(state.year);
          const historySnap = await scopedOrSocratesLegacy(`years/${year}/approvalsHistory`, `approvalsHistory/${year}`).catch(() => ({ val: () => null }));
          const history = historySnap.val() || {};
          Object.values(history).forEach(months => {
            Object.values(months || {}).forEach(records => {
              Object.values(records || {}).forEach(record => {
                if (record && record.sourceModule === 'transport' && record.modulePayload?.studentKey === studentId) {
                  const ref = record.paymentReferenceCode || record.modulePayload?.payment?.reference;
                  if (ref) {
                    approvalMap[ref] = {
                      approved: record.finalStatus === 'approved',
                      pending: false
                    };
                  }
                }
              });
            });
          });
          
          // Update payment approval status from map
          payments = payments.map(p => {
            const ref = p.ref || p.reference;
            if (ref && approvalMap[ref]) {
              return {
                ...p,
                approved: approvalMap[ref].approved ? true : (p.approved || false)
              };
            }
            return p;
          });
        } catch (err) {
          console.warn('Error checking approval status:', err);
        }
        
        const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
        const admissionNo = student.admissionNumber || 'N/A';
        
        // Update modal title
        document.getElementById('historyModalTitle').textContent = `Payment History - ${fullName} (${admissionNo})`;
        
        const historyBody = document.getElementById('historyBody');
        const historyEmpty = document.getElementById('historyEmpty');
        
        if (payments.length === 0) {
          historyBody.innerHTML = '';
          historyEmpty.classList.remove('hidden');
        } else {
          historyEmpty.classList.add('hidden');
          historyBody.innerHTML = payments.map(p => {
            // Check approval status more thoroughly
            const isApproved = p.approved === true || p.approved === 'true' || p.approvedAt || (p.approvedBy && !p.approvedBy.includes('pending'));
            const statusBadge = isApproved 
              ? '<span class="chip ok" style="background: rgba(16, 185, 129, 0.15); color: #86efac; border: 1px solid rgba(16, 185, 129, 0.35); padding: 0.25rem 0.75rem; border-radius: 999px; font-size: 0.75rem; font-weight: 700;">Approved</span>'
              : '<span class="chip warn" style="background: rgba(245, 158, 11, 0.15); color: #fcd34d; border: 1px solid rgba(245, 158, 11, 0.35); padding: 0.25rem 0.75rem; border-radius: 999px; font-size: 0.75rem; font-weight: 700;">Pending</span>';
            
            const d = p.paidAt ? new Date(p.paidAt).toLocaleDateString('en-GB') : (p.timestamp ? new Date(p.timestamp).toLocaleDateString('en-GB') : '-');
            const monthName = typeof p.month === 'number' ? MONTH_NAMES[p.month] : (p.month || '-');
            const rowColor = isApproved ? 'style="background: rgba(16, 185, 129, 0.05);"' : 'style="background: rgba(245, 158, 11, 0.05);"';
            
            return `<tr ${rowColor}>
              <td style="font-weight: 600;">${d}</td>
              <td>${monthName}</td>
              <td style="color: var(--accent-success); font-weight: 700;">${formatCurrency(p.amount || 0)}</td>
              <td>${p.method || '-'}</td>
              <td style="font-family: monospace; font-size: 0.875rem;">${p.ref || p.reference || '-'}</td>
              <td>${p.payerName || '-'}</td>
              <td>${statusBadge}</td>
              <td style="font-size: 0.875rem; color: var(--text-secondary);">${p.notes || '-'}</td>
            </tr>`;
          }).join('');
        }
        
        document.getElementById('historyModal').classList.remove('hidden');
      }
      
      function closeHistoryModal() {
        document.getElementById('historyModal').classList.add('hidden');
      }

      // Add expense
      async function addExpense() {
        const category = document.getElementById('expenseCategory').value;
        const amount = parseFloat(document.getElementById('expenseAmount').value);
        const description = document.getElementById('expenseDescription').value;
        
        if (!category || !amount || amount <= 0 || !description) {
          showToast('Please fill in all fields', 'bad');
          return;
        }
        
        try {
          const expense = {
            category,
            amount,
            description,
            timestamp: Date.now(),
            addedBy: state.user.uid,
            year: state.year,
          };
          
          await schoolRef(`years/${state.year}/transport_expenses`).push(expense);
          
          showToast('Expense added successfully!');
          document.getElementById('expenseCategory').value = '';
          document.getElementById('expenseAmount').value = '';
          document.getElementById('expenseDescription').value = '';
          loadAllData();
        } catch (error) {
          console.error('Error adding expense:', error);
          showToast('Failed to add expense', 'bad');
        }
      }

      // Render expenses table
      function renderExpensesTable() {
        const expensesBody = document.getElementById('expensesBody');
        const expenses = Object.values(state.expenses)
          .filter(exp => exp.year == state.year)
          .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        
        if (expenses.length === 0) {
          expensesBody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 2rem;">No expenses recorded</td></tr>';
          return;
        }
        
        expensesBody.innerHTML = expenses.map(exp => `
          <tr>
            <td>${formatDate(exp.timestamp)}</td>
            <td><span class="chip ${exp.category === 'FUEL' ? 'warn' : exp.category === 'MAINTENANCE' ? 'info' : 'ok'}">${exp.category}</span></td>
            <td>${exp.description}</td>
            <td>${formatCurrency(exp.amount)}</td>
            <td>${exp.addedBy || '-'}</td>
          </tr>
        `).join('');
      }

      // Export to Excel - OPTIMIZED (already uses Promise.all, but removed redundant multiplier loading)
      async function exportToExcel() {
        const yearNum = Number(state.year);
        const multipliers = cachedMultipliers[yearNum] || (await TransportPricing.loadYearMultipliers(yearNum));
        if (!cachedMultipliers[yearNum]) cachedMultipliers[yearNum] = multipliers;
        
        // OPTIMIZATION: Process all students in parallel (already using Promise.all, but removed redundant multiplier loading)
        const data = await Promise.all(Object.entries(state.transportEnrollments).map(async ([studentId, enrollment]) => {
          const student = state.students[studentId];
          if (!student) return null;
          
          const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
          
          const payments = Object.values(state.transportPayments[studentId] || {});
          const transportStatus = await calculateTransportStatus(enrollment, payments, multipliers, studentId);
          
          const feePerYear = Number(student.feePerYear) || 0;
          const schoolPayments = student.payments || {};
          const schoolPaid = Object.values(schoolPayments).reduce((sum, p) => sum + (Number(p.amount) || 0), 0);
          const schoolDebt = Math.max(0, feePerYear - schoolPaid);
          
          return {
            'Admission No': student.admissionNumber,
            'Full Name': fullName,
            'Class': student.classLevel,
            'Parent Contact': student.primaryParentContact,
            'School Fee Total': feePerYear,
            'School Fee Paid': schoolPaid,
            'School Debt': schoolDebt,
            'Transport Start Date': transportStatus.startDateDisplay,
            'Morning Route': enrollment.amStop || enrollment.morningRouteId || '&mdash;',
            'Evening Route': enrollment.pmStop || enrollment.eveningRouteId || '&mdash;',
            'Current Month Transport Fee': transportStatus.currentMonthExpected,
            'Base Monthly Transport Fee': transportStatus.monthlyFee,
            'Transport Paid': transportStatus.totalPaid,
            'Transport Debt': transportStatus.debt,
            'Unpaid Months': transportStatus.unpaidMonths,
            'Total Combined Debt': schoolDebt + transportStatus.debt,
          };
        }));
        
        // Filter out null entries (students that don't exist)
        const filteredData = data.filter(d => d !== null);
        
        const ws = XLSX.utils.json_to_sheet(filteredData);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Transport Payments');
        XLSX.writeFile(wb, `transport_payments_${state.year}.xlsx`);
        showToast('Export successful!');
      }

      // Cache for calculated statuses to avoid recalculation
      const statusCache = new Map();
      const getCacheKey = (studentId, year) => `${studentId}_${year}`;

      function normalizePaymentList(data) {
        if (!data) return [];
        if (Array.isArray(data)) return data;
        if (typeof data === 'object') return Object.values(data);
        return [data];
      }

      function filterLegacyPaymentsByYear(data, year) {
        const yearNum = Number(year);
        return normalizePaymentList(data).filter((p) => Number(p?.year) === yearNum);
      }

      async function readSupplementalPayments(year, studentId) {
        let scopedSnap = null;
        try {
          scopedSnap = await schoolRef(`years/${year}/transport_payments/${studentId}`).once('value');
        } catch (err) {
          scopedSnap = null;
        }
        const scopedVal = scopedSnap?.val();
        const scopedEmpty = !scopedSnap?.exists() ||
          (scopedVal && typeof scopedVal === 'object' && Object.keys(scopedVal).length === 0);
        if (!scopedEmpty && scopedVal) {
          return normalizePaymentList(scopedVal);
        }
        if (isSocratesSchool()) {
          try {
            const legacySnap = await db.ref(`transport_payments/${studentId}`).once('value');
            return filterLegacyPaymentsByYear(legacySnap.val(), year);
          } catch (err) {
            return [];
          }
        }
        return [];
      }

      // Load all data - ULTRA-OPTIMIZED: Load only transport students, progressive loading
      async function loadAllData() {
        try {
          showToast('Loading transport data...', 'ok');
          const year = String(state.year);
          
          // STEP 1: Load transport enrollments FIRST (smaller dataset) - this tells us which students to load
          const [legacyEnrollSnap, enrollSnap, assignmentsSnap] = await Promise.all([
            scopedOrSocratesLegacy(`years/${year}/transportEnrollments`, 'transport_enrollments'),
            scopedOrSocratesLegacy(`years/${year}/transportRegistry`, `transportRegistry/${year}`).catch(() => ({ val: () => null })),
            scopedOrSocratesLegacy(`years/${year}/transportAssignments`, `transportAssignments/${year}`).catch(() => ({ val: () => null }))
          ]);

          // Build list of student IDs on transport
          state.transportEnrollments = {};
          const transportStudentIds = new Set();
          
          // Process legacy enrollments
          const legacyEnrollments = legacyEnrollSnap.val() || {};
          Object.entries(legacyEnrollments).forEach(([studentId, enrollment]) => {
            if (enrollment) {
              state.transportEnrollments[studentId] = enrollment;
              transportStudentIds.add(studentId);
            }
          });
          
          // Process registry
          try {
            const registry = enrollSnap.val() || {};
            Object.entries(registry).forEach(([studentId, reg]) => {
              if (reg && reg.using) {
                transportStudentIds.add(studentId);
                if (!state.transportEnrollments[studentId]) {
                  state.transportEnrollments[studentId] = {
                    amStop: reg.routeId || '',
                    pmStop: reg.stopName || '',
                    monthlyFee: reg.monthlyFee || 0
                  };
                }
              }
            });
          } catch (err) {
            console.warn('Could not load transportRegistry:', err);
          }
          
          // Process assignments
          try {
            const assignments = assignmentsSnap.val() || {};
            Object.entries(assignments).forEach(([studentId, assignRecord]) => {
              if (assignRecord && assignRecord.status === 'Using') {
                transportStudentIds.add(studentId);
                const existing = state.transportEnrollments[studentId] || {};
                state.transportEnrollments[studentId] = {
                  ...existing,
                  startDate: assignRecord.startDate || existing.startDate,
                  baseMonthlyFee: assignRecord.baseMonthlyFee || existing.baseMonthlyFee,
                  amStop: existing.amStop || assignRecord.amStop || assignRecord.morningRouteId || existing.routeId || '',
                  pmStop: existing.pmStop || assignRecord.pmStop || assignRecord.eveningRouteId || existing.stopName || '',
                };
              }
            });
          } catch (err) {
            console.warn('Could not load transportAssignments:', err);
          }

          // STEP 2: Load ONLY students who are on transport (not all students!)
          const studentIds = Array.from(transportStudentIds);
          if (studentIds.length === 0) {
            state.students = {};
            state.transportPayments = {};
            state.expenses = {};
            renderKPIs();
            renderPaymentsTable();
            renderExpensesTable();
            showToast('No students on transport', 'ok');
            return;
          }

          // Load students in batches to avoid timeout on slow connections
          const BATCH_SIZE = 50;
          state.students = {};
          for (let i = 0; i < studentIds.length; i += BATCH_SIZE) {
            const batch = studentIds.slice(i, i + BATCH_SIZE);
            const studentPromises = batch.map(id => 
              scopedOrSocratesLegacy(`students/${id}`, `students/${id}`).then(snap => ({ id, data: snap.val() }))
            );
            const students = await Promise.all(studentPromises);
            students.forEach(({ id, data }) => {
              if (data) state.students[id] = data;
            });
            // Show progress
            if (i % (BATCH_SIZE * 2) === 0) {
              showToast(`Loading students... ${Math.min(i + BATCH_SIZE, studentIds.length)}/${studentIds.length}`, 'ok');
            }
          }

          // STEP 3: Load payments ONLY for transport students (year-scoped ledgers primary)
          showToast('Loading payments...', 'ok');
          const paymentsSnap = await scopedOrSocratesLegacy(`years/${year}/transportLedgers`, `transportLedgers/${year}`);
          let scopedPaymentsSnap = null;
          let legacyPaymentsSnap = null;

          try {
            scopedPaymentsSnap = await schoolRef(`years/${year}/transport_payments`).once('value');
          } catch (err) {
            scopedPaymentsSnap = null;
          }

          const scopedPaymentsVal = scopedPaymentsSnap?.val() || {};
          const scopedEmpty = !scopedPaymentsSnap?.exists() ||
            (scopedPaymentsVal && typeof scopedPaymentsVal === 'object' && Object.keys(scopedPaymentsVal).length === 0);

          if (isSocratesSchool() && scopedEmpty) {
            try {
              legacyPaymentsSnap = await db.ref('transport_payments').once('value');
            } catch (err) {
              legacyPaymentsSnap = null;
            }
          }

          const legacyPaymentsVal = legacyPaymentsSnap?.val ? (legacyPaymentsSnap.val() || {}) : {};

          const paymentsData = {};
          const ledgers = paymentsSnap.val() || {};
          studentIds.forEach(studentId => {
            if (ledgers[studentId] && ledgers[studentId].payments) {
              paymentsData[studentId] = normalizePaymentList(ledgers[studentId].payments);
            }
          });

          // Optional legacy payments: scoped year path (non-Socrates) or legacy root (Socrates fallback)
          studentIds.forEach(studentId => {
            if (paymentsData[studentId] && paymentsData[studentId].length) return;
            if (scopedPaymentsVal && scopedPaymentsVal[studentId]) {
              paymentsData[studentId] = normalizePaymentList(scopedPaymentsVal[studentId]);
              return;
            }
            if (legacyPaymentsVal && legacyPaymentsVal[studentId]) {
              const legacyPayments = legacyPaymentsVal[studentId];
              paymentsData[studentId] = filterLegacyPaymentsByYear(legacyPayments, year);
            }
          });

          state.transportPayments = paymentsData;

          // STEP 4: Load expenses (lightweight, can load all)
          const expensesSnap = await scopedOrSocratesLegacy(`years/${year}/transport_expenses`, 'transport_expenses');
          const allExpenses = expensesSnap.val() || {};
          state.expenses = {};
          Object.entries(allExpenses).forEach(([key, exp]) => {
            if (exp && (exp.year == year || !exp.year)) {
              state.expenses[key] = exp;
            }
          });

          // STEP 5: Pre-load multipliers
          const yearNum = Number(state.year);
          if (!cachedMultipliers[yearNum]) {
            cachedMultipliers[yearNum] = await TransportPricing.loadYearMultipliers(yearNum);
          }

          // STEP 6: Clear status cache for this year
          statusCache.clear();

          // STEP 7: Render progressively - show table first, then KPIs
          showToast('Rendering data...', 'ok');
          await renderPaymentsTable();
          await renderKPIs();
          renderExpensesTable();
          
          showToast('Data loaded successfully!', 'ok');
        } catch (error) {
          console.error('Error loading data:', error);
          showToast('Error loading data: ' + error.message, 'bad');
        }
      }

      function refreshData() {
        showToast('Refreshing data...');
        loadAllData();
      }

      maybeAutoAdvanceYear();
      maybeRunRollover();

      // Event listeners
      if (yearSelect) {
        yearSelect.value = state.year;
        yearSelect.addEventListener('change', (e) => {
          state.year = parseInt(e.target.value);
          statusCache.clear(); // Clear cache on year change
          if (window.somapYearContext) {
            window.somapYearContext.setSelectedYear(String(state.year));
          }
          loadAllData();
        });
      }
      
      // Listen to year context changes
      if (window.somapYearContext) {
        window.somapYearContext.onYearChanged((year) => {
          const newYear = parseInt(year) || state.year;
          if (newYear !== state.year) {
            state.year = newYear;
            statusCache.clear(); // Clear cache on year change
            if (yearSelect) yearSelect.value = state.year;
            loadAllData();
          }
        });
      }

      classFilter.addEventListener('change', renderPaymentsTable);
      searchInput.addEventListener('input', renderPaymentsTable);
      statusFilter.addEventListener('change', renderPaymentsTable);

      // Update due date display
      (function updateDueDate(){
        const params = new URLSearchParams(window.location.search);
        const yearParam = parseInt(params.get('year'), 10);
        const dueDay = 27;
        // If year is provided in URL, show 27th December of that year; else show next month's 27th
        if (Number.isFinite(yearParam)) {
          document.getElementById('dueDate').textContent = `${dueDay}th December ${yearParam}`;
        } else {
          const today = new Date();
          const nextMonth = new Date(today.getFullYear(), today.getMonth() + 1, dueDay);
          document.getElementById('dueDate').textContent = `${dueDay}th ${MONTH_NAMES[nextMonth.getMonth() + 1]} ${nextMonth.getFullYear()}`;
        }
      })();

      // Parent transport payment renderer - unified view with existing KPIs and table
      async function renderParentTransportPayment(studentId) {
        try {
          const y = String(state.year);
          
          // Ensure expenses/balance cards are hidden (already done on init, but double-check)
          const expCard = document.getElementById('totalExpenses')?.closest('.stat-card');
          const netCard = document.getElementById('netBalance')?.closest('.stat-card');
          if (expCard) expCard.style.display = 'none';
          if (netCard) netCard.style.display = 'none';
          
          // Hide expenses section completely
          const expSection = document.querySelector('section.card.mt-3:has([id="fuelExpenses"])');
          if (expSection) expSection.style.display = 'none';
          
          // Get parent phone (parents logged in via index.html with studentKey)
          const parentPhone = normalizePhone(localStorage.getItem('parentPhone') || '');
        
        // Load ONLY this specific student's data (fast!)
        // Use same data source as admin view (transportLedgers)
        const [sSnap, enrollSnap, ledSnap, finSnap] = await Promise.all([
          scopedOrSocratesLegacy(`students/${studentId}`, `students/${studentId}`),
          scopedOrSocratesLegacy(`years/${y}/transportEnrollments/${studentId}`, `transport_enrollments/${studentId}`).catch(() => ({ val: () => null })),
          scopedOrSocratesLegacy(`years/${y}/transportLedgers/${studentId}/payments`, `transportLedgers/${y}/${studentId}/payments`).catch(() => ({ val: () => null })),
          scopedOrSocratesLegacy(`years/${y}/finance/${studentId}/payments`, `finance/${y}/${studentId}/payments`).catch(() => ({ val: () => null }))
        ]);
        
        const S = sSnap.val() || {};
        const enrollment = enrollSnap.val() || {};
        let pays = normalizePaymentList(ledSnap.val() || {});
        
        // Also check legacy path if no data in new path
        if (!pays || pays.length === 0) {
          pays = await readSupplementalPayments(y, studentId);
        }
        
        const schoolPayments = finSnap.val() || {};
        
        // Ensure pays is an array
        if (!Array.isArray(pays)) {
          pays = pays ? [pays] : [];
        }
        
        // Verify parent owns student (but don't block if no phone match - parents already authenticated)
        const studentPhone = normalizePhone(S.motherPhone || S.parentPhone || S.primaryParentContact || '');
        if (parentPhone && parentPhone !== studentPhone) {
          alert('Access denied. This child is not linked to your account.');
          window.location.href = 'parent.html';
          return;
        }
        
        // Check if using transport
        if (!enrollment) {
          alert('This child is not using transport for the selected year.');
          window.location.href = 'parent.html';
          return;
        }
        
        // Populate state so modal functions work
        state.students[studentId] = S;
        state.transportEnrollments[studentId] = enrollment;
        state.transportPayments[studentId] = pays;
        state.currentPaymentStudentId = studentId;
        await renderYearScopedStudentView(studentId);
        return;
        } catch (error) {
          console.error('Error in renderParentTransportPayment:', error);
          showToast('Error loading student data', 'bad');
          // Still show error in stat cards
          const totalExpectedEl = document.getElementById('totalExpected');
          const totalCollectedEl = document.getElementById('totalCollected');
          const totalDebtEl = document.getElementById('totalDebt');
          if (totalExpectedEl) totalExpectedEl.textContent = 'Error';
          if (totalCollectedEl) totalCollectedEl.textContent = 'Error';
          if (totalDebtEl) totalDebtEl.textContent = 'Error';
        }
      }

      // Year-scoped single-student renderer (strict; never switch student)
      function monthName(num){ return MONTH_NAMES[num] || ''; }
      async function loadTransportContextStrict(year, studentId){
        const db = firebase.database();
        const [assignSnap, enrollSnap, paysSnap, financeSnap, studentSnap] = await Promise.all([
          scopedOrSocratesLegacy(`years/${year}/transportAssignments/${studentId}`, `transportAssignments/${year}/${studentId}`),
          scopedOrSocratesLegacy(`years/${year}/transportEnrollments/${studentId}`, `transport_enrollments/${studentId}`).catch(() => ({ val: () => null })),
          scopedOrSocratesLegacy(`years/${year}/transportLedgers/${studentId}/payments`, `transportLedgers/${year}/${studentId}/payments`).catch(() => ({ val: () => null })),
          scopedOrSocratesLegacy(`years/${year}/finance/${studentId}/payments`, `finance/${year}/${studentId}/payments`).catch(() => ({ val: () => null })),
          scopedOrSocratesLegacy(`students/${studentId}`, `students/${studentId}`).catch(() => ({ val: () => null })),
        ]);
        const assign = assignSnap.val() || null;
        const legacyEnroll = enrollSnap.val() || null;
        
        // Get payments from both paths
        let payments = normalizePaymentList(paysSnap.val() || {});
        if (!payments || payments.length === 0) {
          payments = await readSupplementalPayments(year, studentId);
        }
        
        // Normalize payment objects
        const normalizedPayments = payments.map(x => ({
          month: Number(x.month)||0,
          amount: Number(x.amount)||0,
          status: x.status||'pending'
        }));
        
        const finance = Object.values(financeSnap.val()||{});
        const schoolFeePaid = finance.reduce((a,p)=>a+(Number(p.amount)||0),0);
        const student = studentSnap.val() || {};
        if (student && student.schoolId) {
          // School context is managed by SOMAP; do not override here.
        }
        state.students[studentId] = student;
        const existingEnrollment = state.transportEnrollments[studentId] || {};
        // Prefer year assignment; fallback to legacy enrollment for parent view
        let effective = assign;
        if (!effective && legacyEnroll) {
          const amStop = legacyEnroll.amStop || legacyEnroll.morningRouteId || legacyEnroll.route || '';
          const pmStop = legacyEnroll.pmStop || legacyEnroll.eveningRouteId || legacyEnroll.stopName || '';
          const baseMonthlyFee = Number(legacyEnroll.baseMonthlyFee || 0) || (TransportPricing.priceForStop(amStop) + TransportPricing.priceForStop(pmStop));
          effective = {
            status: 'Using',
            amStop,
            pmStop,
            baseMonthlyFee,
            startDate: legacyEnroll.startDate || legacyEnroll.start_date || legacyEnroll.dateRegistered || null,
          };
        }

        state.transportEnrollments[studentId] = {
          ...existingEnrollment,
          ...(effective || assign || legacyEnroll || {}),
        };
        state.transportPayments[studentId] = normalizedPayments;
        return {
          assign: effective || assign,
          payments: normalizedPayments,
          schoolFeePaid,
          student,
        };
      }

      function setText(sel, txt){ const el=document.querySelector(sel); if(el) el.textContent=txt; }
      function renderIdentityStrict(S){
        const fullName = `${S.firstName||''} ${S.middleName||''} ${S.lastName||''}`.replace(/\s+/g,' ').trim();
        // Use table header summary for identity context
        document.getElementById('paymentSummary').textContent = fullName ? `Payments for ${fullName}` : '';
      }
      function renderNoDataStrict(msg){
        document.getElementById('totalExpected').textContent = '-';
        document.getElementById('totalCollected').textContent = '-';
        document.getElementById('totalDebt').textContent = '-';
        const tbody = document.getElementById('paymentsBody');
        if (tbody) tbody.innerHTML = '';
        const empty = document.getElementById('emptyState');
        if (empty) { empty.textContent = msg || 'No data'; empty.classList.remove('hidden'); }
      }

      async function renderYearScopedStudentView(studentId){
        state.currentPaymentStudentId = studentId;
        const year = String(state.year);
        const { assign, payments, schoolFeePaid, student } = await loadTransportContextStrict(year, studentId);
        renderIdentityStrict(student);
        // If no year-scoped assignment, attempt to render using legacy enrollment data
        if (!assign || assign.status !== 'Using'){
          if (!state.transportEnrollments[studentId]) {
            renderNoDataStrict(`No transport assignment for ${year}.`);
            return;
          }
        }
        
        // Load year multipliers for accurate calculations
        const multipliers = cachedMultipliers[Number(year)] || (await TransportPricing.loadYearMultipliers(Number(year)));
        if (!cachedMultipliers[Number(year)]) cachedMultipliers[Number(year)] = multipliers;
        
        const hasAssignedStart = Boolean(
          assign?.startDate ||
          assign?.start_date ||
          assign?.startTimestamp ||
          assign?.start_time
        );
        const base = Number(assign?.baseMonthlyFee||0);
        const startDate = normalizeDateInput((assign && (assign.startDate || assign.start_date || assign.startTimestamp || assign.start_time)) || `${year}-01-01`, Number(year));
        const amStop = assign?.amStop || assign?.morningRouteId || '';
        const pmStop = assign?.pmStop || assign?.eveningRouteId || '';
        const ledger = await TransportPricing.buildLedger({ 
          year: Number(year), 
          amStop,
          pmStop,
          baseMonthlyFee: base, 
          startDate, 
          payments, 
          multipliers 
        });

        const focusedMonth = getFocusedMonth();
        const selectedMonthLabel = MONTH_NAMES[focusedMonth] || ('Month ' + focusedMonth);
        const dueThisMonth = await TransportPricing.dueForMonth({ 
          year:Number(year), 
          month:focusedMonth, 
          amStop,
          pmStop,
          baseMonthlyFee: base, 
          startDate, 
          multipliers 
        });
        const startDisplay = hasAssignedStart ? formatStartDateDisplay(startDate) : 'N/A';

        // Compute carry-forward debt up to the focused month (exclude future months)
        const monthsToDate = (ledger.months || []).filter(m => m.month <= focusedMonth && m.status !== 'SKIP');
        const dueToDate = monthsToDate.reduce((s,m)=> s + (Number(m.due)||0), 0);
        const paidToDate = monthsToDate.reduce((s,m)=> s + (Number(m.paid)||0), 0);
        const balanceToDate = Math.max(0, Math.round(dueToDate - paidToDate));

        document.getElementById('totalExpected').textContent = formatCurrency(Math.round(dueThisMonth));
        document.getElementById('totalCollected').textContent = formatCurrency(Math.round(paidToDate));
        document.getElementById('totalDebt').textContent = formatCurrency(balanceToDate);
        document.getElementById('monthLabel').textContent = `${selectedMonthLabel} ${year}`;

        // School fee alignment
        // Note: only show value; the rest of school columns are fed from student rows
        // We will update the single-row table to reflect school fee paid from finance ledger

        const unpaid = monthsToDate.filter(m=>m.status==='UNPAID'||m.status==='PARTIAL').map(m=>MONTH_NAMES[m.month]).join(', ') || 'None';

        const tbody = document.getElementById('paymentsBody');
        if (tbody){
          const fullName = `${student.firstName||''} ${student.middleName||''} ${student.lastName||''}`.replace(/\s+/g,' ').trim();
          const schoolPaid = schoolFeePaid;
          const feePerYear = Number(student.feePerYear)||0;
          const schoolDebt = Math.max(0, feePerYear - schoolPaid);
          const combinedDebt = Math.max(0, schoolDebt + balanceToDate);
          const morningRoute = assign?.amStop || assign?.morningRouteId || '&mdash;';
          const eveningRoute = assign?.pmStop || assign?.eveningRouteId || '&mdash;';
          const currentMonthDue = Math.round(dueThisMonth);
          const baseDisplay = formatCurrency(base);
          const rowClass = (combinedDebt>0) ? 'style="background: rgba(239, 68, 68, 0.15); font-weight: 600;"' : '';
          tbody.innerHTML = `
            <tr ${rowClass}>
              <td>${student.admissionNumber || 'N/A'}</td>
              <td>${fullName}</td>
              <td>${student.classLevel || '&mdash;'}</td>
              <td>${formatDate(student.timestamp || student.createdAt)}</td>
              <td>${student.primaryParentContact || 'N/A'}</td>
              <td>${startDisplay}</td>
              <td>${formatCurrency(feePerYear)}</td>
              <td>${formatCurrency(schoolPaid)}</td>
              <td style="color: ${schoolDebt>0?'var(--accent-danger)':'var(--accent-success)'};">${formatCurrency(schoolDebt)}</td>
              <td>&mdash;</td>
              <td>${morningRoute}</td>
              <td>${eveningRoute}</td>
              <td title="Base fee before multiplier: ${baseDisplay}">
                ${formatCurrency(currentMonthDue)}<br>
                <span style="font-size: 0.7rem; color: var(--text-muted, #94a3b8);">
                  Base: ${baseDisplay} &#183; ${selectedMonthLabel}
                </span>
              </td>
              <td style="color: var(--accent-success);">${formatCurrency(paidToDate)}</td>
              <td style="color: ${balanceToDate>0?'var(--accent-danger)':'var(--accent-success)'};">${formatCurrency(balanceToDate)}</td>
              <td style="font-size: 0.75rem;">${unpaid}</td>
              <td style="color: ${combinedDebt>0?'var(--accent-danger)':'var(--accent-success)'}; font-weight: 700;">${formatCurrency(combinedDebt)}</td>
              <td class="table-actions" style="justify-content: flex-end;">
                <button class="btn success" onclick="openPaymentModal('${studentId}')">&#128176; Pay</button>
                <button class="btn secondary" onclick="viewPaymentHistory('${studentId}')">&#128221; History</button>
              </td>
            </tr>`;
          document.getElementById('emptyState')?.classList.add('hidden');
        }
      }

      // Check for single-student view (ONLY via URL studentKey)
      const urlParams = new URLSearchParams(window.location.search);
      const studentParam = urlParams.get('studentKey');
      const monthParam = parseInt(urlParams.get('month'), 10);
      
      if (Number.isFinite(monthParam) && monthParam >= 1 && monthParam <= 12) {
        state.month = monthParam;
        state.monthSelectedFromUrl = true;
      } else {
        state.monthSelectedFromUrl = false;
      }
      if (yearSelect && state.year) yearSelect.value = state.year;
      
      if (studentParam) {
        state.currentPaymentStudentId = studentParam;
        
        // Hide expense/balance cards for single-student view
        const expensesCard = document.getElementById('totalExpenses')?.closest('.stat-card');
        const netBalanceCard = document.getElementById('netBalance')?.closest('.stat-card');
        if (expensesCard) expensesCard.style.display = "none";
        if (netBalanceCard) netBalanceCard.style.display = "none";
        
        // Hide expenses section completely
        const expensesSection = document.querySelector('section.card.mt-3:has([id="fuelExpenses"])');
        if (expensesSection) expensesSection.style.display = 'none';
        
        // Change back button to go to parent.html
        const backBtn = document.getElementById('backButton');
        if (backBtn) {
          backBtn.href = '../parent.html';
          backBtn.textContent = '<- Back to Parent Dashboard';
        }
        
        // Initialize stat cards with loading state to prevent flashing
        const totalExpectedEl = document.getElementById('totalExpected');
        const totalCollectedEl = document.getElementById('totalCollected');
        const totalDebtEl = document.getElementById('totalDebt');
        const monthLabelEl = document.getElementById('monthLabel');
        
        if (totalExpectedEl) totalExpectedEl.textContent = 'Loading...';
        if (totalCollectedEl) totalCollectedEl.textContent = 'Loading...';
        if (totalDebtEl) totalDebtEl.textContent = 'Loading...';
        if (monthLabelEl) monthLabelEl.textContent = '';
        if (classFilter) classFilter.style.display = "none";
        if (searchInput) searchInput.style.display = "none";
        if (statusFilter) statusFilter.style.display = "none";
        const debtorsBtn = document.getElementById('debtorsBtnText')?.parentElement;
        if (debtorsBtn) debtorsBtn.style.display = "none";
        
        // Load and render immediately using strict year-scoped data
        renderYearScopedStudentView(studentParam).catch(err => {
          console.error('Error rendering single-student transport payment:', err);
          if (totalExpectedEl) totalExpectedEl.textContent = 'Error';
          if (totalCollectedEl) totalCollectedEl.textContent = 'Error';
          if (totalDebtEl) totalDebtEl.textContent = 'Error';
        });
      } else {
        const backBtn = document.getElementById('backButton');
        if (backBtn) { backBtn.href = 'transport.html'; backBtn.textContent = '<- Back to Dashboard'; }
        loadAllData();
      }

      // Listen to year changes for single-student view
      if (window.somapYearContext) {
        window.somapYearContext.onYearChanged((year) => {
          const studentId = state.currentPaymentStudentId;
          const urlParams = new URLSearchParams(window.location.search);
          const studentParam = urlParams.get('studentKey');
          if (studentParam) {
            const newYear = parseInt(year) || state.year;
            state.year = newYear;
            renderYearScopedStudentView(studentId || studentParam);
          }
        });
      }
    </script>
  </body>
</html>

