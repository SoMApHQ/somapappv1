<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SoMAp Transport Hub ¬∑ Dashboard</title>
    <link rel="stylesheet" href="./css/transport_dark.css" />
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-storage-compat.js"></script>
    <script src="../somapappv1multischool/js/context.js"></script>
    <script src="../Todashboardhtml/yearContext.js"></script>
    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyBhONntRE_aRsU0y1YcPZzWud3CBfwH_a8",
        authDomain: "somaptestt.firebaseapp.com",
        databaseURL: "https://somaptestt-default-rtdb.firebaseio.com",
        projectId: "somaptestt",
        storageBucket: "somaptestt.appspot.com",
        messagingSenderId: "105526245138",
        appId: "1:105526245138:web:b8e7c0cb82a46e861965cb",
      };
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
    </script>
  </head>
  <body>
    <!-- Context Bar with Year Selection and Date Display -->
    <div id="contextBar" class="bar">
      <div>
        <h1>üöå SoMAp Transport Hub</h1>
        <small>Advanced Transport Management System √Ç¬∑ <span id="schoolNameDisplay">√¢‚Ç¨‚Äù</span></small>
      </div>
      <div class="context-selectors">
        <div class="date-time-display">
          <span class="label">Today</span>
          <span class="value" id="currentDate">‚Äî</span>
        </div>
        <div>
          <label style="margin-bottom: 0.25rem; font-size: 0.75rem;">Academic Year</label>
          <select id="yearSelect" data-somap-year-select data-somap-year-min="2023" style="min-width: 100px; padding: 0.5rem;">
          </select>
        </div>
      </div>
    </div>

    <main>
      <!-- KPI Cards Row -->
      <section class="row" id="kpiRow"></section>

      <!-- Management Cards Row -->
      <section class="row" id="startCards"></section>

      <!-- Alerts Section -->
      <section class="mt-3" id="alerts"></section>
    </main>

    <!-- Students on Transport Modal -->
    <div id="studentsModal" class="modal hidden">
      <div class="modal-content" style="max-width: 1400px;">
        <div class="flex space center mb-2">
          <div>
            <h2 style="margin: 0;">Students on Transport Registry</h2>
            <small style="color: var(--text-muted); font-size: 0.875rem;">Academic Year <strong id="studentsModalYear">‚Äî</strong></small>
          </div>
          <button class="btn secondary" id="closeStudentsModal">Close</button>
        </div>
        
        <div class="filter-bar">
          <select id="classFilterModal">
            <option value="">All Classes</option>
            <option>Baby Class</option>
            <option>Middle Class</option>
            <option>Pre Unit Class</option>
            <option>Class 1</option>
            <option>Class 2</option>
            <option>Class 3</option>
            <option>Class 4</option>
            <option>Class 5</option>
            <option>Class 6</option>
            <option>Class 7</option>
          </select>
          <input id="searchStudent" type="text" placeholder="Search student..." style="max-width: 300px;" />
          <button class="btn success" id="exportStudentsCsv">üì• Export CSV</button>
        </div>

        <div style="overflow-x: auto; margin-top: 1.5rem;">
          <table class="table" id="studentsTransportTable">
            <thead>
              <tr>
                <th>Admission No</th>
                <th>Full Name</th>
                <th>Class</th>
                <th>Date Registered</th>
                <th>Parent Contact</th>
                <th>Fee Total</th>
                <th>Paid Amount</th>
                <th>Debt</th>
                <th>Debt Till</th>
                <th>Transport Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="studentsTransportBody">
              <!-- Populated by JavaScript -->
            </tbody>
          </table>
          <div id="emptyStudents" class="empty hidden">No students found</div>
        </div>
      </div>
    </div>

    <!-- Transport Assignment Modal -->
    <div id="transportAssignModal" class="modal hidden">
      <div class="modal-content">
        <div class="flex space center mb-2">
          <h2 style="margin: 0;">Assign Transport</h2>
          <button class="btn secondary" id="closeTransportAssign">Close</button>
        </div>

        <div id="assignAlert" class="alert hidden"></div>

        <div style="margin-bottom: 1rem; padding: 1rem; background: rgba(59, 130, 246, 0.1); border-radius: 12px; border: 1px solid rgba(59, 130, 246, 0.2);">
          <h3 style="margin: 0 0 0.5rem 0; font-size: 1rem;">Student Information</h3>
          <p id="assignStudentInfo" style="margin: 0; color: var(--text-secondary);"></p>
        </div>

        <div class="grid two">
          <div class="card">
            <h3 style="margin-top: 0;">Time Period</h3>
            <label for="assignPeriod">When will student use transport?</label>
            <select id="assignPeriod" required>
              <option value="">-- Select Period --</option>
              <option value="morning">Morning Only (Asubuhi)</option>
              <option value="evening">Evening Only (Jioni)</option>
              <option value="both">Morning & Evening (Both)</option>
            </select>
          </div>
        </div>

        <div class="grid two mt-2" id="dropOffSection" style="display: none;">
          <div class="card" id="morningDropSection" style="display: none;">
            <h3 style="margin-top: 0;">Morning Drop-off Point</h3>
            <label for="assignMorningDropSearch">Where to drop in the morning? (type to search)</label>
            <div class="route-search-wrap" id="morningRouteSearchWrap">
              <span class="route-search-icon">üîç</span>
              <input type="text" class="route-search-input" id="assignMorningDropSearch" placeholder="Type route name to search..." autocomplete="off" data-route-for="morning" />
              <div class="route-search-list hidden" id="morningRouteSearchList"></div>
            </div>
            <select id="assignMorningDrop" style="display:none;" aria-hidden="true"></select>
          </div>

          <div class="card" id="eveningDropSection" style="display: none;">
            <h3 style="margin-top: 0;">Evening Drop-off Point</h3>
            <label for="assignEveningDropSearch">Where to drop in the evening? (type to search)</label>
            <div class="route-search-wrap" id="eveningRouteSearchWrap">
              <span class="route-search-icon">üîç</span>
              <input type="text" class="route-search-input" id="assignEveningDropSearch" placeholder="Type route name to search..." autocomplete="off" data-route-for="evening" />
              <div class="route-search-list hidden" id="eveningRouteSearchList"></div>
            </div>
            <select id="assignEveningDrop" style="display:none;" aria-hidden="true"></select>
          </div>
        </div>

        <div class="card mt-2" id="startDateSection" style="display: none;">
          <h3 style="margin-top: 0;">Start Date</h3>
          <label for="transportStartDate">Start Date (first day student uses transport) *</label>
          <input type="date" id="transportStartDate" required />
        </div>

        <div class="card mt-2" id="farePreview" style="display: none;">
          <h3 style="margin-top: 0;">Monthly Fee Preview</h3>
          <div id="fareBreakdown" style="font-size: 0.875rem; line-height: 1.8;"></div>
          <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--glass-border);">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: 600; font-size: 1.125rem;">Total Monthly Fee:</span>
              <span id="totalFareDisplay" style="font-weight: 800; font-size: 1.5rem; color: var(--accent-success);"></span>
            </div>
            <div id="startMonthDueWrap" style="margin-top: .5rem; display:none;">
              <div style="display:flex; justify-content: space-between; align-items:center;">
                <span style="font-size:.9rem;">Start month due (prorated):</span>
                <span id="startMonthDueDisplay" style="font-weight:700;"></span>
              </div>
            </div>
          </div>
        </div>

        <div class="card mt-2" id="vehicleAssignSection" style="display: none;">
          <h3 style="margin-top: 0;">üöê Vehicle & Driver Assignment</h3>
          <div id="vehicleInfo" style="padding: 1rem; background: rgba(16, 185, 129, 0.1); border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.2);">
            <p style="margin: 0 0 1rem 0; font-size: 0.875rem; color: var(--text-secondary);">
              Vehicle and driver are automatically assigned based on the selected route(s).
            </p>
            <div id="autoAssignInfo"></div>
          </div>
        </div>

        <div class="flex mt-2" style="justify-content: flex-end; gap: 1rem;">
          <button class="btn secondary" id="cancelAssign">Cancel</button>
          <button class="btn success" id="saveTransportAssign">üíæ Save Assignment</button>
        </div>
      </div>
    </div>

    <div id="toast" class="toast hidden"></div>

    <script src="./modules/transport_roles.js"></script>
    <script src="./modules/transport_context.js"></script>
    <script src="./modules/transport_helpers.js"></script>
    <script src="./modules/transport_pricing.js"></script>
    <script src="../shared/finance_math.js"></script>
    <script>
      const db = firebase.database();
      const currentSchool = window.SOMAP?.getSchool?.();
      if (!currentSchool || !currentSchool.id) {
        window.location.href = '../somapappv1multischool/multischool.html';
      }
      const schoolId = currentSchool?.id || '';
      window.currentSchoolId = schoolId; // for finance_math.js
      const schoolName = currentSchool?.name || schoolId;
      const isSocratesSchool = (id) => id === 'socrates-school' || id === 'default';

      function schoolSubPath(subPath) {
        const clean = String(subPath || '').replace(/^\/+/, '');
        return isSocratesSchool(schoolId) ? `schools/${schoolId}/${clean}` : clean;
      }

      function schoolRef(subPath) {
        return db.ref(window.SOMAP.P(schoolSubPath(subPath)));
      }

      async function scopedOrSocratesLegacy(scopedSubPath, legacyPath) {
        const scopedRef = schoolRef(scopedSubPath);
        if (!isSocratesSchool(schoolId) || !legacyPath) return scopedRef.once('value');
        const scopedSnap = await scopedRef.once('value');
        if (scopedSnap.exists()) return scopedSnap;
        return db.ref(legacyPath).once('value');
      }

      function schoolPath(subPath) {
        return window.SOMAP.P(schoolSubPath(subPath));
      }

      function maybeAutoAdvanceYear() {
        const ctx = window.somapYearContext;
        if (!ctx || typeof ctx.getSelectedYear !== 'function') return;
        const current = String(new Date().getFullYear());
        const selected = String(ctx.getSelectedYear());
        if (Number(current) > Number(selected)) {
          if (typeof ctx.resetToCurrentYear === 'function') {
            ctx.resetToCurrentYear();
          } else if (typeof ctx.setSelectedYear === 'function') {
            ctx.setSelectedYear(current, { manual: false, forceDispatch: true });
          }
        }
      }

      // Route options - loaded dynamically from transportCatalog (includes Morombo and any + Add Stop)
      let ROUTE_OPTIONS = [];
      const FEE_GROUP = (fee) => {
        if (fee <= 17000) return '1 KM - 17,000 TZS/month/time';
        if (fee <= 18500) return '1.5 KM - 18,500 TZS/month/time';
        if (fee <= 21000) return '2 KM - 21,000 TZS/month/time';
        if (fee <= 24000) return '3-4 KM - 24,000 TZS/month/time';
        if (fee <= 25000) return '5-6 KM - 25,000 TZS/month/time';
        if (fee <= 28000) return '6-10 KM - 28,000 TZS/month/time';
        if (fee <= 38000) return '10-15 KM - 38,000 TZS/month/time';
        return 'NJE YA MAENEO HAYA - 44,000 TZS/month/time';
      };
      async function loadRouteOptions() {
        let stops = [];
        if (typeof TransportPricing?.loadStopsForYear === 'function') {
          stops = await TransportPricing.loadStopsForYear(state.year) || [];
        }
        if (stops.length === 0 && isSocratesSchool(schoolId)) {
          const schoolPath = `schools/${schoolId}/transportCatalog/${state.year}/stops`;
          try {
            const snap = await db.ref(schoolPath).once('value');
            const val = snap.val() || {};
            stops = Object.entries(val).map(([id, s]) => ({ id, name: s?.name || id, baseFee: Number(s?.baseFee) || 0, active: s?.active !== false }));
          } catch (_) {}
        }
        ROUTE_OPTIONS = (stops || [])
          .filter(s => s.active !== false)
          .map(s => {
            const name = String(s.name || s.id || '').trim();
            const v = name.toLowerCase();
            return { v, l: name, g: FEE_GROUP(Number(s.baseFee) || 0) };
          })
          .sort((a, b) => a.l.localeCompare(b.l));
        if (ROUTE_OPTIONS.length === 0) {
          showToast('No routes found. Add stops in Routes & Stops first.', 'bad');
        }
      }

      const CLASS_ORDER = ['Baby Class', 'Middle Class', 'Pre Unit Class', 'Class 1', 'Class 2', 'Class 3', 'Class 4', 'Class 5', 'Class 6', 'Class 7'];
      function shiftClass(baseClass, deltaYears) {
        const normalized = String(baseClass || '').trim();
        const idx = CLASS_ORDER.findIndex(c => c.toLowerCase() === normalized.toLowerCase());
        if (idx < 0) return baseClass || '';
        const newIdx = idx + Number(deltaYears || 0);
        if (newIdx < 0) return 'PRE-ADMISSION';
        if (newIdx >= CLASS_ORDER.length) return 'GRADUATED';
        return CLASS_ORDER[newIdx];
      }

      async function maybeRunRollover() {
        const systemYear = String(new Date().getFullYear());
        const flagRef = schoolRef(`meta/rolloverDone/${systemYear}`);
        try {
          const flagSnap = await flagRef.get();
          if (flagSnap.exists()) return;
          const previousYear = String(Number(systemYear) - 1);
          const prevEnrollSnap = await scopedOrSocratesLegacy(`years/${previousYear}/enrollments`, `enrollments/${previousYear}`);
          const prevEnrollments = prevEnrollSnap.val() || {};
          const nowIso = new Date().toISOString();
          const updates = {};

          Object.entries(prevEnrollments).forEach(([studentKey, record]) => {
            const baseClass = (record && (record.className || record.classLevel)) || '';
            const nextClass = shiftClass(baseClass, 1);
            if (nextClass === 'GRADUATED') {
              updates[schoolPath(`years/${systemYear}/graduated/${studentKey}`)] = {
                className: baseClass || 'Class 7',
                promotedAt: nowIso,
                fromYear: Number(previousYear)
              };
              updates[schoolPath(`years/${systemYear}/enrollments/${studentKey}`)] = {
                className: 'GRADUATED',
                promotedFrom: baseClass || 'Class 7',
                fromYear: Number(previousYear),
                at: firebase.database.ServerValue.TIMESTAMP
              };
            } else {
              updates[schoolPath(`years/${systemYear}/enrollments/${studentKey}`)] = {
                className: nextClass,
                promotedFrom: baseClass,
                fromYear: Number(previousYear),
                at: firebase.database.ServerValue.TIMESTAMP
              };
            }
          });

          updates[schoolPath(`meta/rolloverDone/${systemYear}`)] = true;
          await db.ref().update(updates);
        } catch (err) {
          console.warn('Year rollover skipped/failed:', err);
        }
      }

      const schoolNameDisplay = document.getElementById('schoolNameDisplay');
      if (schoolNameDisplay) schoolNameDisplay.textContent = schoolName || '‚Äî';

      // Allow deep links to set the active year via the shared helper
      (function syncYearFromUrl() {
        const params = new URLSearchParams(window.location.search);
        const y = parseInt(params.get('year'), 10);
        if (Number.isFinite(y) && window.somapYearContext?.setSelectedYear) {
          window.somapYearContext.setSelectedYear(String(y), { manual: false, forceDispatch: true });
        }
      })();

      // Global State
      const state = {
        user: null,
        role: null,
        year: (() => {
            const rawYear = window.somapYearContext?.getSelectedYear?.();
            const parsed = parseInt(rawYear, 10);
            return Number.isFinite(parsed) ? parsed : new Date().getFullYear();
          })(),
        month: new Date().getMonth() + 1,
        schoolId,
        schoolName,
        students: {},
        yearEnrollments: {}, // year-scoped class levels
        vehicles: {},
        transportEnrollments: {},
        transportAssignments: {},
        transportPayments: {},
        financeData: {},
        currentAssignStudentId: null,
        drivers: [],
        routeVehicleValidation: {}, // Track which routes have vehicles assigned
      };

      const toast = document.getElementById("toast");
      const startCardsEl = document.getElementById("startCards");
      const kpiRowEl = document.getElementById("kpiRow");
      const alertsEl = document.getElementById("alerts");
      const yearSelect = document.getElementById("yearSelect");
      const currentDateEl = document.getElementById("currentDate");

      // Modal elements
      const studentsModal = document.getElementById("studentsModal");
      const closeStudentsModal = document.getElementById("closeStudentsModal");
      const studentsTransportBody = document.getElementById("studentsTransportBody");
      const classFilterModal = document.getElementById("classFilterModal");
      const searchStudent = document.getElementById("searchStudent");

      const transportAssignModal = document.getElementById("transportAssignModal");
      const closeTransportAssign = document.getElementById("closeTransportAssign");
      const assignRouteSelect = document.getElementById("assignRouteSelect"); // Legacy - Route Selection card removed; routes loaded from DB
      const assignPeriod = document.getElementById("assignPeriod");
      const assignMorningDrop = document.getElementById("assignMorningDrop");
      const assignEveningDrop = document.getElementById("assignEveningDrop");
      const saveTransportAssign = document.getElementById("saveTransportAssign");

      // Utility Functions
      function showToast(message, tone = "ok") {
        toast.textContent = message;
        toast.classList.remove("hidden");
        toast.style.background = tone === "bad" ? "#ef4444" : "#1f2937";
        setTimeout(() => toast.classList.add("hidden"), 3500);
      }

      function formatCurrency(amount) {
        return new Intl.NumberFormat('en-TZ', { style: 'currency', currency: 'TZS' }).format(amount || 0);
      }
      function routeMatches(assignedVal, target) {
        const a = String(assignedVal || '').toLowerCase().trim();
        const t = String(target || '').toLowerCase().trim();
        if (!a || !t) return false;
        if (a === t) return true;
        if (a.includes(t) || t.includes(a)) return true;
        return false;
      }

      function formatDate(timestamp) {
        if (!timestamp) return 'N/A';
        const date = new Date(timestamp);
        return date.toLocaleDateString('en-GB');
      }

      // Update current date display
      function updateDateDisplay() {
        const now = new Date();
        const options = { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' };
        currentDateEl.textContent = now.toLocaleDateString('en-US', options);
      }

      // Initialize date display and update every second
      updateDateDisplay();
      setInterval(updateDateDisplay, 1000);

      // Year selection handler
      if (yearSelect && window.somapYearContext) {
        window.somapYearContext.attachYearDropdown(yearSelect);
        const synchronizeYear = (yearValue) => {
          const normalized = parseInt(yearValue, 10);
          if (!Number.isFinite(normalized)) return;
          state.year = normalized;
          if (String(normalized) !== yearSelect.value) {
            yearSelect.value = String(normalized);
          }
          if (state.user) {
            studentsLoaded = false;
            studentsLoadedForYear = null;
            loadCriticalData();
          }
        };
        synchronizeYear(window.somapYearContext.getSelectedYear());
        window.somapYearContext.onYearChanged((nextYear) => {
          synchronizeYear(nextYear);
        });
        yearSelect.addEventListener('change', (event) => {
          window.somapYearContext.setSelectedYear(event.target.value);
        });
      } else if (yearSelect) {
        yearSelect.value = state.year;
        yearSelect.addEventListener('change', (event) => {
          const normalized = parseInt(event.target.value, 10);
          if (!Number.isFinite(normalized) || normalized === state.year) return;
          state.year = normalized;
          studentsLoaded = false;
          studentsLoadedForYear = null;
          loadCriticalData();
          // Reload students if modal is open
          if (studentsModal && !studentsModal.classList.contains('hidden')) {
            loadStudentsIfNeeded().then(() => renderStudentsTable());
          }
        });
      }

      // Render KPI Cards
      function renderKpis() {
        const totalStudents = Object.keys(state.students || {}).length;
        const studentsOnTransport = Object.keys(state.transportEnrollments || {}).length;
        const notOnTransport = totalStudents > 0 ? totalStudents - studentsOnTransport : '‚Äî';

        // Calculate financial KPIs (matching transportpayments.html logic)
        let expectedThisMonth = 0;
        let totalCollected = 0;
        let totalDebt = 0;

        const enrollments = state.transportEnrollments || {};
        const payments = state.transportPayments || {};
        const MONTH_NAMES = ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        
        Object.entries(enrollments).forEach(([studentId, enrollment]) => {
          if (!enrollment) return;
          
          const amStop = enrollment.amStop || '';
          const pmStop = enrollment.pmStop || '';
          
          // Current month expected (with multiplier) - for "Expected This Month" KPI
          const currentMonthExpected = TransportPricing.expectedForMonth(amStop, pmStop, state.month);
          expectedThisMonth += currentMonthExpected;

          // Calculate total expected and total paid across ALL months (like transportpayments.html)
          let totalExpected = 0;
          let totalPaid = 0;
          
          const studentPayments = payments[studentId] || {};
          const paymentsArray = Array.isArray(studentPayments) ? studentPayments : Object.values(studentPayments || {});
          
          for (let month = 1; month <= 12; month++) {
            const monthlyExpected = TransportPricing.expectedForMonth(amStop, pmStop, month);
            totalExpected += monthlyExpected;
            
            // Handle both number and month name formats for payments
            const monthPayments = paymentsArray.filter(p => {
              if (!p || !p.month) return false;
              if (typeof p.month === 'number') return p.month === month;
              if (typeof p.month === 'string') return MONTH_NAMES[month] === p.month;
              return false;
            });
            
            const monthPaid = monthPayments.reduce((sum, p) => sum + (Number(p.amount) || 0), 0);
            totalPaid += monthPaid;
          }
          
          totalCollected += totalPaid;
          totalDebt += Math.max(0, totalExpected - totalPaid);
        });

        const cards = [
          {
            id: "students-transport",
            label: "Students on Transport",
            value: studentsOnTransport,
            description: `${totalStudents} total students`,
            color: "primary",
            clickable: true,
          },
          {
            id: "not-transport",
            label: "Not Using Transport",
            value: notOnTransport,
            description: totalStudents > 0 ? "Available for enrollment" : "Loading...",
            color: "info",
          },
          {
            id: "expected-month",
            label: `Expected ${getMonthName(state.month)} ${state.year}`,
            value: formatCurrency(expectedThisMonth),
            description: "Monthly target",
            color: "success",
          },
          {
            id: "paid-month",
            label: "Total Collected",
            value: formatCurrency(totalCollected),
            description: "All transport payments",
            color: "success",
          },
          {
            id: "debt-month",
            label: "Total Transport Debt",
            value: formatCurrency(totalDebt),
            description: "Unpaid amounts",
            color: "danger",
          },
        ];

        kpiRowEl.innerHTML = cards
          .map(
            (card) => `
            <article class="card stat-card ${card.clickable ? 'clickable' : ''}" ${card.clickable ? `onclick="openStudentsModal()"` : ''} style="cursor: ${card.clickable ? 'pointer' : 'default'};">
              <div class="stat-label">${card.label}</div>
              <div class="stat-value">${card.value}</div>
              <div class="stat-label" style="font-size: 0.75rem; margin-top: 0.5rem;">${card.description}</div>
            </article>
          `
          )
          .join("");
      }

      function getMonthName(monthIndex) {
        const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        return months[monthIndex - 1] || "";
      }

      // Render Management Cards
      function renderStartCards() {
        const cards = [
          {
            title: "Payments Queue",
            description: "Approve transport fee claims and ledgers",
            href: "transportpayments.html",
            icon: "üí∞",
          },
          {
            title: "Vehicle Registry",
            description: "Fleet, owners, insurance expiries",
            href: "transportbuses.html",
            icon: "üöê",
          },
          {
            title: "Routes & Stops",
            description: "Manage routes, stops, and schedules",
            href: "transportroutes.html",
            icon: "üó∫Ô∏è",
          },
          {
            title: "Fuel Requests",
            description: "Review, approve & flag fuel usage",
            href: "transportfuel.html",
            icon: "‚õΩ",
          },
          {
            title: "Maintenance Desk",
            description: "Repairs, parts history and approvals",
            href: "transportmaintenance.html",
            icon: "üîß",
          },
          {
            title: "Boarding Gate",
            description: "No Pay ¬∑ No Board control centre",
            href: "transportattendance.html",
            icon: "üö™",
          },
          {
            title: "Reports & Exports",
            description: "Monthly KPIs and CSV/PDF exports",
            href: "transportreports.html",
            icon: "üìä",
          },
          {
            title: "Operations & Toggles",
            description: "Windows, active days, km-per-litre controls",
            href: "transportops.html",
            icon: "‚öôÔ∏è",
          },
        ];

        startCardsEl.innerHTML = cards
          .map(
            (card) => `
            <article class="card">
              <div style="font-size: 2rem; margin-bottom: 0.5rem;">${card.icon}</div>
              <h2>${card.title}</h2>
              <p class="muted">${card.description}</p>
              <a class="btn mt-2" href="${card.href}?school=${state.schoolId}&year=${state.year}" style="display: block;">
                Open ‚Üí
              </a>
            </article>
          `
          )
          .join("");
      }

      // Open Students on Transport Modal
      async function openStudentsModal() {
        studentsModal.classList.remove("hidden");
        const yearEl = document.getElementById('studentsModalYear');
        if (yearEl) yearEl.textContent = state.year;
        // Show loading state
        studentsTransportBody.innerHTML = '<tr><td colspan="11" style="text-align: center; padding: 2rem;">Loading students...</td></tr>';
        
        // Load students data if not already loaded
        await loadStudentsIfNeeded();
        renderStudentsTable();
      }

      closeStudentsModal.addEventListener("click", () => {
        studentsModal.classList.add("hidden");
      });

      // Render Students Table
      function renderStudentsTable() {
        const filterClass = classFilterModal.value;
        const searchTerm = searchStudent.value.toLowerCase();

        const filtered = Object.entries(state.students).filter(([id, student]) => {
          const displayClass = student._resolvedClass || student.classLevel || student.className || '';
          const matchesClass = !filterClass || displayClass === filterClass;
          const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.toLowerCase();
          const matchesSearch = !searchTerm || 
            fullName.includes(searchTerm) || 
            (student.admissionNumber || '').toLowerCase().includes(searchTerm);
          return matchesClass && matchesSearch;
        });

        if (filtered.length === 0) {
          studentsTransportBody.innerHTML = '';
          document.getElementById('emptyStudents').classList.remove('hidden');
          return;
        }

        document.getElementById('emptyStudents').classList.add('hidden');

        studentsTransportBody.innerHTML = filtered
          .map(([id, student]) => {
            const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
            const displayClass = student._resolvedClass || student.classLevel || student.className || 'N/A';
            const enrollment = state.transportEnrollments[id];
            const assignments = state.transportAssignments || {};
            const assignment = assignments[id];
            const isUsingTransport = assignment
              ? assignment.status === 'Using'
              : !!enrollment;

            // Get finance data (year-scoped via SomapFinance when available)
            const financeData = state.financeData[id] || {};
            const feeTotal = financeData.feePerYear || 0;
            const paidAmount = financeData.paidAmount ?? Object.values(financeData.payments || {}).reduce((sum, p) => sum + (Number(p.amount) || 0), 0);
            const debt = Math.max(0, feeTotal - paidAmount);
            const debtTill = financeData.debtTill || '‚Äî';

            const statusBadge = isUsingTransport 
              ? '<span class="chip ok">Using</span>'
              : '<span class="chip warn">Not Using</span>';

            const actionBtn = isUsingTransport
              ? `<button class="btn secondary" onclick="editTransportAssignment('${id}')">Edit</button>`
              : `<button class="btn success" onclick="assignTransport('${id}')">Assign Transport</button>`;

            return `
              <tr>
                <td>${student.admissionNumber || 'N/A'}</td>
                <td>${fullName}</td>
                <td>${displayClass}</td>
                <td>${formatDate(student.timestamp || student.createdAt)}</td>
                <td>${student.primaryParentContact || 'N/A'}</td>
                <td>${formatCurrency(feeTotal)}</td>
                <td>${formatCurrency(paidAmount)}</td>
                <td style="color: ${debt > 0 ? 'var(--accent-danger)' : 'var(--accent-success)'};">${formatCurrency(debt)}</td>
                <td>${debtTill}</td>
                <td>${statusBadge}</td>
                <td class="table-actions">${actionBtn}</td>
              </tr>
            `;
          })
          .join("");
      }

      // Debounce search for better performance
      let searchTimeout = null;
      classFilterModal.addEventListener('change', renderStudentsTable);
      searchStudent.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => renderStudentsTable(), 300); // Wait 300ms after typing stops
      });

      // Searchable route dropdown - opens UPWARDS, uses fixed position so not clipped by modal
      // List is appended to body so position:fixed works correctly (modal transform creates new containing block)
      function initSearchableRoute(searchInputId, listId, selectEl, currentValue) {
        const input = document.getElementById(searchInputId);
        const list = document.getElementById(listId);
        if (!input || !list || !selectEl) return;
        const q = (term) => String(term || '').toLowerCase().trim();
        // Ensure list is in body for correct fixed positioning (avoids modal transform clipping)
        if (list.parentNode !== document.body) {
          document.body.appendChild(list);
        }
        if (input.dataset.routeSearchInit) {
          input.value = currentValue ? (ROUTE_OPTIONS.find(r => r.v === currentValue)?.l || currentValue) : '';
          selectEl.innerHTML = '<option value=""></option>' + ROUTE_OPTIONS.map(r => `<option value="${r.v}">${r.l}</option>`).join('');
          if (currentValue) selectEl.value = currentValue;
          return;
        }
        input.dataset.routeSearchInit = '1';
        const positionList = () => {
          const rect = input.getBoundingClientRect();
          list.style.position = 'fixed';
          list.style.left = rect.left + 'px';
          list.style.width = Math.max(rect.width, 200) + 'px';
          list.style.maxHeight = '320px';
          list.style.bottom = (window.innerHeight - rect.top + 4) + 'px';
          list.style.top = 'auto';
          list.style.zIndex = '10000';
        };
        const renderList = (filterTerm) => {
          const term = q(filterTerm);
          const filtered = term ? ROUTE_OPTIONS.filter(r => q(r.l).includes(term) || q(r.v).includes(term)) : ROUTE_OPTIONS;
          let lastGroup = '';
          let html = '';
          filtered.forEach(r => {
            if (r.g !== lastGroup) {
              lastGroup = r.g;
              html += `<div class="route-opt-group">${r.g}</div>`;
            }
            html += `<div class="route-opt" data-value="${r.v}" data-label="${r.l.replace(/"/g, '&quot;')}">${r.l}</div>`;
          });
          list.innerHTML = html || '<div class="route-opt" style="color:var(--text-muted);">No matching routes</div>';
          list.classList.remove('hidden');
          requestAnimationFrame(() => {
            positionList();
            list.scrollTop = 0;
          });
          list.querySelectorAll('.route-opt[data-value]').forEach(el => {
            el.addEventListener('mousedown', (e) => {
              e.preventDefault();
              const v = el.dataset.value;
              const lbl = el.dataset.label;
              selectEl.value = v;
              input.value = lbl || v;
              list.classList.add('hidden');
              selectEl.dispatchEvent(new Event('change'));
            });
          });
        };
        input.value = currentValue ? (ROUTE_OPTIONS.find(r => r.v === currentValue)?.l || currentValue) : '';
        const showList = () => renderList(input.value);
        input.addEventListener('focus', showList);
        input.addEventListener('click', showList);
        input.addEventListener('input', showList);
        input.addEventListener('blur', () => setTimeout(() => list.classList.add('hidden'), 200));
        const onScrollOrResize = () => { if (!list.classList.contains('hidden')) positionList(); };
        transportAssignModal?.addEventListener('scroll', onScrollOrResize, true);
        window.addEventListener('resize', onScrollOrResize);
        // Populate hidden select
        selectEl.innerHTML = '<option value=""></option>' + ROUTE_OPTIONS.map(r => `<option value="${r.v}">${r.l}</option>`).join('');
        if (currentValue) selectEl.value = currentValue;
      }

      // Assign Transport Function
      async function assignTransport(studentId) {
        state.currentAssignStudentId = studentId;
        
        // Ensure students and routes are loaded
        await loadStudentsIfNeeded();
        await loadRouteOptions();
        
        const student = state.students[studentId];
        if (!student) {
          showToast('Student not found', 'bad');
          return;
        }

        const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
        const displayClass = student._resolvedClass || state.yearEnrollments?.[studentId]?.className || state.yearEnrollments?.[studentId]?.classLevel || student.classLevel || 'N/A';
        document.getElementById('assignStudentInfo').textContent = 
          `${fullName} - ${student.admissionNumber} - ${displayClass}`;

        // Reset form and route search state so both morning/evening get fresh init
        if (assignRouteSelect) assignRouteSelect.value = '';
        assignPeriod.value = '';
        assignMorningDrop.value = '';
        assignEveningDrop.value = '';
        const morningSearch = document.getElementById('assignMorningDropSearch');
        const eveningSearch = document.getElementById('assignEveningDropSearch');
        if (morningSearch) delete morningSearch.dataset.routeSearchInit;
        if (eveningSearch) delete eveningSearch.dataset.routeSearchInit;
        if (morningSearch) morningSearch.value = '';
        if (eveningSearch) eveningSearch.value = '';
        document.getElementById('dropOffSection').style.display = 'none';
        document.getElementById('farePreview').style.display = 'none';
        document.getElementById('vehicleAssignSection').style.display = 'none';
        state.routeVehicleValidation = {};

        // Reset save button
        const saveBtn = document.getElementById('saveTransportAssign');
        if (saveBtn) {
          saveBtn.disabled = true;
          saveBtn.style.opacity = '0.6';
          saveBtn.style.cursor = 'not-allowed';
          saveBtn.title = 'Please complete all required fields';
        }

        transportAssignModal.classList.remove('hidden');
      }

      async function editTransportAssignment(studentId) {
        await assignTransport(studentId);
        const enrollment = state.transportEnrollments[studentId];
        if (enrollment) {
          if (assignRouteSelect) assignRouteSelect.value = enrollment.route || '';
          assignPeriod.value = enrollment.period || '';
          assignMorningDrop.value = enrollment.amStop || '';
          assignEveningDrop.value = enrollment.pmStop || '';
          // Trigger period handler to show drop sections and init searchable
          assignPeriod.dispatchEvent(new Event('change'));
          // Re-init searchable with existing values (period handler may have reset them)
          const period = enrollment.period || '';
          if (period === 'morning' || period === 'both') {
            initSearchableRoute('assignMorningDropSearch', 'morningRouteSearchList', assignMorningDrop, enrollment.amStop || '');
          }
          if (period === 'evening' || period === 'both') {
            initSearchableRoute('assignEveningDropSearch', 'eveningRouteSearchList', assignEveningDrop, enrollment.pmStop || '');
          }
          await calculateFare();
          updateSaveButtonState();
        }
      }

      // Period change handler
      assignPeriod.addEventListener('change', async () => {
        const period = assignPeriod.value;
        const dropSection = document.getElementById('dropOffSection');
        const morningSection = document.getElementById('morningDropSection');
        const eveningSection = document.getElementById('eveningDropSection');

        if (period === 'morning') {
          dropSection.style.display = 'grid';
          morningSection.style.display = 'block';
          eveningSection.style.display = 'none';
          assignEveningDrop.value = '';
          document.getElementById('assignEveningDropSearch').value = '';
          initSearchableRoute('assignMorningDropSearch', 'morningRouteSearchList', assignMorningDrop, assignMorningDrop.value || '');
        } else if (period === 'evening') {
          dropSection.style.display = 'grid';
          morningSection.style.display = 'none';
          eveningSection.style.display = 'block';
          assignMorningDrop.value = '';
          document.getElementById('assignMorningDropSearch').value = '';
          initSearchableRoute('assignEveningDropSearch', 'eveningRouteSearchList', assignEveningDrop, assignEveningDrop.value || '');
        } else if (period === 'both') {
          dropSection.style.display = 'grid';
          morningSection.style.display = 'block';
          eveningSection.style.display = 'block';
          initSearchableRoute('assignMorningDropSearch', 'morningRouteSearchList', assignMorningDrop, assignMorningDrop.value);
          initSearchableRoute('assignEveningDropSearch', 'eveningRouteSearchList', assignEveningDrop, assignEveningDrop.value);
        } else {
          dropSection.style.display = 'none';
        }

        await calculateFare();
        // reveal start date when period/routes selected
        const hasAny = assignMorningDrop.value || assignEveningDrop.value;
        document.getElementById('startDateSection').style.display = hasAny ? 'block' : 'none';
        updateSaveButtonState();
      });

      assignMorningDrop.addEventListener('change', async () => {
        await calculateFare();
        const hasAny = assignMorningDrop.value || assignEveningDrop.value;
        document.getElementById('startDateSection').style.display = hasAny ? 'block' : 'none';
        updateSaveButtonState();
      });
      assignEveningDrop.addEventListener('change', async () => {
        await calculateFare();
        const hasAny = assignMorningDrop.value || assignEveningDrop.value;
        document.getElementById('startDateSection').style.display = hasAny ? 'block' : 'none';
        updateSaveButtonState();
      });

      // Recalculate when start date changes (to update proration preview)
      document.getElementById('transportStartDate')?.addEventListener('change', async () => {
        await calculateFare();
      });

      // Calculate and display fare with vehicle/driver info
      async function calculateFare() {
        const period = assignPeriod.value;
        if (!period) {
          document.getElementById('farePreview').style.display = 'none';
          document.getElementById('vehicleAssignSection').style.display = 'none';
          return;
        }

        const morningRoute = assignMorningDrop.value;
        const eveningRoute = assignEveningDrop.value;
        const year = Number(state.year);
        
        // Get start date to determine which month's price to use
        const startDateInput = document.getElementById('transportStartDate');
        const focusedMonth = startDateInput?.value 
          ? (new Date(startDateInput.value)).getMonth() + 1
          : (new Date()).getMonth() + 1;
        
        // Use date-aware pricing
        const baseFee = await TransportPricing.computeBaseMonthlyFeeOnMonth({
          year,
          month: focusedMonth,
          amStop: morningRoute,
          pmStop: eveningRoute
        });
        
        // For display breakdown, get individual prices
        const morningPrice = morningRoute ? await TransportPricing.baseFeeOnDate({
          year,
          stopName: morningRoute,
          onDate: TransportPricing.monthStartIso(year, focusedMonth)
        }) : 0;
        const eveningPrice = eveningRoute ? await TransportPricing.baseFeeOnDate({
          year,
          stopName: eveningRoute,
          onDate: TransportPricing.monthStartIso(year, focusedMonth)
        }) : 0;

        let breakdown = '<div style="display: grid; gap: 0.5rem;">';
        if (morningRoute) {
          breakdown += `<div style="display: flex; justify-content: space-between;">
            <span>Morning (${morningRoute}):</span>
            <span style="font-weight: 600;">${formatCurrency(morningPrice)}</span>
          </div>`;
        }
        if (eveningRoute) {
          breakdown += `<div style="display: flex; justify-content: space-between;">
            <span>Evening (${eveningRoute}):</span>
            <span style="font-weight: 600;">${formatCurrency(eveningPrice)}</span>
          </div>`;
        }
        breakdown += `</div>
          <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(59, 130, 246, 0.1); border-radius: 8px;">
            <p style="margin: 0; font-size: 0.75rem; color: var(--text-muted);">
              Note: This is the base monthly fee. Actual monthly fees vary with multipliers:
              January (1.5√ó), April & September (0.8√ó), November (1.25√ó), June & December (0√ó)
            </p>
          </div>`;

        document.getElementById('fareBreakdown').innerHTML = breakdown;
        document.getElementById('totalFareDisplay').textContent = formatCurrency(baseFee);
        document.getElementById('farePreview').style.display = 'block';

        // If start date selected, preview prorated start month due
        const sd = document.getElementById('transportStartDate')?.value;
        const y = state.year;
        if (sd) {
          const { y: sy, m: sm } = (function(s){ const a=String(s).split('-'); return { y:Number(a[0]||y), m:Number(a[1]||1) }; })(sd);
          const multipliers = await TransportPricing.loadYearMultipliers(sy);
          const due = await TransportPricing.dueForMonth({ 
            year: sy, 
            month: sm, 
            amStop: morningRoute,
            pmStop: eveningRoute,
            baseMonthlyFee: baseFee, 
            startDate: sd,
            multipliers
          });
          const wrap = document.getElementById('startMonthDueWrap');
          const disp = document.getElementById('startMonthDueDisplay');
          if (wrap && disp) { wrap.style.display='block'; disp.textContent = formatCurrency(Math.round(due)); }
        } else {
          const wrap = document.getElementById('startMonthDueWrap'); if (wrap) wrap.style.display='none';
        }

        // Show vehicle and driver assignment
        updateVehicleDriverInfo(morningRoute, eveningRoute);
        document.getElementById('vehicleAssignSection').style.display = 'block';
      }

      // Update vehicle and driver information based on selected routes
      function updateVehicleDriverInfo(morningRoute, eveningRoute) {
        const routes = [morningRoute, eveningRoute].filter(r => r);
        if (routes.length === 0) {
          document.getElementById('autoAssignInfo').innerHTML = '<p style="margin: 0; color: var(--text-muted);">No routes selected</p>';
          state.routeVehicleValidation = {};
          updateSaveButtonState();
          return;
        }

        // Reset validation state
        state.routeVehicleValidation = {};

        let vehicleDriverInfo = '<div style="display: grid; gap: 1rem;">';
        let allRoutesHaveVehicles = true;

        routes.forEach(route => {
          // Find vehicle(s) assigned to this route
          const vehiclesForRoute = Object.values(state.vehicles || {}).filter(v => {
            if (!v) return false;
            // assignedRoutes can be array OR object of strings/objects
            const rawAssigned = v.assignedRoutes;
            const assigned = Array.isArray(rawAssigned)
              ? rawAssigned
              : (rawAssigned && typeof rawAssigned === 'object')
                ? Object.values(rawAssigned)
                : [];
            const target = String(route).toLowerCase().trim();
            return assigned.some(r => {
              if (!r) return false;
              const val = (typeof r === 'string') ? r : (r.route || r.name || r.id || '');
              return routeMatches(val, target);
            });
          });

          if (vehiclesForRoute.length > 0) {
            // Route has vehicle(s) - mark as valid
            state.routeVehicleValidation[route] = true;

            vehiclesForRoute.forEach(vehicle => {
              const driver = state.drivers.find(d => d.id === vehicle.assignedDriverUid);
              const driverName = driver ? driver.fullName : 'Driver not assigned';
              const driverPhone = driver ? driver.phone : '';

              vehicleDriverInfo += `
                <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.3);">
                  <div style="display: grid; gap: 0.5rem; font-size: 0.875rem;">
                    <div><strong>Route:</strong> ${route}</div>
                    <div><strong>üöê Vehicle:</strong> ${vehicle.plate} (${vehicle.makeModel || 'N/A'})</div>
                    <div><strong>üë®‚Äç‚úàÔ∏è Driver:</strong> ${driverName}${driverPhone ? ` (${driverPhone})` : ''}</div>
                    <div><strong>Capacity:</strong> ${vehicle.capacity || 'N/A'} seats</div>
                  </div>
                </div>
              `;
            });
          } else {
            // Route has no vehicle - mark as invalid
            state.routeVehicleValidation[route] = false;
            allRoutesHaveVehicles = false;

            vehicleDriverInfo += `
              <div style="background: rgba(239, 68, 68, 0.1); padding: 1rem; border-radius: 8px; border: 1px solid rgba(239, 68, 68, 0.3);">
                <div style="font-size: 0.875rem;">
                  <strong>Route:</strong> ${route}<br/>
                  <span style="color: var(--accent-danger);">‚ö†Ô∏è No vehicle assigned to this route yet. Please assign a vehicle in Vehicle Registry.</span>
                </div>
              </div>
            `;
          }
        });

        vehicleDriverInfo += '</div>';
        document.getElementById('autoAssignInfo').innerHTML = vehicleDriverInfo;

        // Update save button state based on validation
        updateSaveButtonState(allRoutesHaveVehicles);
      }

      // Update save button state based on vehicle assignment validation
      function updateSaveButtonState(allRoutesHaveVehicles = false) {
        const saveBtn = document.getElementById('saveTransportAssign');
        if (!saveBtn) return;

        const period = assignPeriod.value;
        const morningRoute = assignMorningDrop.value;
        const eveningRoute = assignEveningDrop.value;
        const hasRoutes = morningRoute || eveningRoute;

        // Check if all selected routes have vehicles
        const routes = [morningRoute, eveningRoute].filter(r => r);
        const allValid = routes.length > 0 && routes.every(route => state.routeVehicleValidation[route] === true);

        if (!period || !hasRoutes || !allValid) {
          saveBtn.disabled = true;
          saveBtn.style.opacity = '0.6';
          saveBtn.style.cursor = 'not-allowed';
          if (hasRoutes && !allValid) {
            saveBtn.title = 'Cannot save: No vehicle assigned to one or more selected routes';
          } else {
            saveBtn.title = 'Please complete all required fields';
          }
        } else {
          saveBtn.disabled = false;
          saveBtn.style.opacity = '1';
          saveBtn.style.cursor = 'pointer';
          saveBtn.title = '';
        }
      }

      // Save transport assignment
      saveTransportAssign.addEventListener('click', async () => {
        const studentId = state.currentAssignStudentId;
        const period = assignPeriod.value;
        const morningRoute = assignMorningDrop.value;
        const eveningRoute = assignEveningDrop.value;
        const startDate = (document.getElementById('transportStartDate') || {}).value;

        // Basic validation
        if (!period || (!morningRoute && !eveningRoute)) {
          showToast('Please complete all required fields', 'bad');
          return;
        }

        if (!startDate) {
          showToast('Please select Start Date', 'bad');
          return;
        }

        // Validate vehicle assignment for all selected routes
        const routes = [morningRoute, eveningRoute].filter(r => r);
        const missingVehicles = routes.filter(route => state.routeVehicleValidation[route] !== true);

        if (missingVehicles.length > 0) {
          showToast(`Cannot save: No vehicle assigned to route(s): ${missingVehicles.join(', ')}. Please assign vehicles in Vehicle Registry first.`, 'bad');
          return;
        }

        try {
          // Find and store vehicle/driver info for each route
          const routeVehicleMap = {};
          routes.forEach(route => {
            const vehiclesForRoute = Object.values(state.vehicles || {}).filter(v => {
              if (!v || !v.assignedRoutes) return false;
              const raw = v.assignedRoutes;
              const list = Array.isArray(raw)
                ? raw
                : (typeof raw === 'object') ? Object.values(raw) : [];
              return list.some(r => {
                if (!r) return false;
                const val = (typeof r === 'string') ? r : (r.route || r.name || r.id || '');
                return routeMatches(val, route);
              });
            });
            
            if (vehiclesForRoute.length > 0) {
              // Use the first vehicle found for this route
              const vehicle = vehiclesForRoute[0];
              const driver = state.drivers.find(d => d.id === vehicle.assignedDriverUid);
              routeVehicleMap[route] = {
                vehicleId: vehicle.id || null,
                vehiclePlate: vehicle.plate || '',
                driverId: vehicle.assignedDriverUid || null,
                driverName: driver ? driver.fullName : 'Not assigned'
              };
            }
          });

          const enrollment = {
            studentId,
            school: state.schoolId,
            year: state.year,
            period,
            amStop: morningRoute || '',
            pmStop: eveningRoute || '',
            route: morningRoute || eveningRoute,
            // Store vehicle/driver assignment info
            morningVehicle: morningRoute ? routeVehicleMap[morningRoute] : null,
            eveningVehicle: eveningRoute ? routeVehicleMap[eveningRoute] : null,
            updatedAt: Date.now(),
            updatedBy: state.user.uid,
          };

          await schoolRef(`years/${state.year}/transportEnrollments/${studentId}`).set(enrollment);

          // Also write year-scoped assignment with base fees + start date (canonical path)
          const baseMorningFee = TransportPricing.priceForStop(morningRoute || '');
          const baseEveningFee = TransportPricing.priceForStop(eveningRoute || '');
          const baseMonthlyFee = baseMorningFee + baseEveningFee;
          const assignPayload = {
            status: 'Using',
            morningRouteId: morningRoute || '',
            eveningRouteId: eveningRoute || '',
            morningVehicle: morningRoute ? routeVehicleMap[morningRoute] : null,
            eveningVehicle: eveningRoute ? routeVehicleMap[eveningRoute] : null,
            baseMorningFee,
            baseEveningFee,
            baseMonthlyFee,
            startDate: startDate,
            dateRegistered: Date.now(),
            parentContact: state.students[studentId]?.primaryParentContact || '',
            className: state.students[studentId]?.classLevel || '',
            admissionNo: state.students[studentId]?.admissionNumber || '',
            fullName: `${state.students[studentId]?.firstName||''} ${state.students[studentId]?.middleName||''} ${state.students[studentId]?.lastName||''}`.replace(/\s+/g,' ').trim()
          };
          await schoolRef(`years/${state.year}/transportAssignments/${studentId}`).set(assignPayload);

          showToast('Transport assignment saved successfully!');
          transportAssignModal.classList.add('hidden');
          
          // Update local state immediately
          state.transportEnrollments[studentId] = enrollment;
          state.transportAssignments[studentId] = assignPayload;
          
          // Refresh data in background
          loadCriticalData().then(() => {
            if (studentsModal && !studentsModal.classList.contains('hidden')) {
              renderStudentsTable();
            }
          });
          
          // Update KPIs immediately
          renderKpis();
        } catch (error) {
          console.error('Error saving assignment:', error);
          showToast('Failed to save assignment', 'bad');
        }
      });

      closeTransportAssign.addEventListener('click', () => {
        transportAssignModal.classList.add('hidden');
      });

      document.getElementById('cancelAssign').addEventListener('click', () => {
        transportAssignModal.classList.add('hidden');
      });

      // Cache for drivers (rarely changes)
      let driversCache = null;
      let driversCacheTime = 0;
      const DRIVERS_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

      // Load critical data first (for KPIs and UI)
      async function loadCriticalData() {
        try {
          // Show loading state
          kpiRowEl.innerHTML = '<article class="card stat-card"><div class="stat-label">Loading...</div><div class="stat-value">‚è≥</div></article>';
          
          // IMPORTANT:
          // For Socrates/legacy schools we must MERGE legacy + year-scoped data.
          // If the year-scoped path exists, the old helper would stop falling back,
          // which makes previously-assigned students "disappear" in the UI.
          const yearKey = String(state.year);
          const isLegacyMerge = isSocratesSchool(schoolId);

          const legacyBusesPaths = isSocratesSchool(schoolId) ? [
            `transport/socrates-school/${yearKey}/buses`,
            `transport/socrates/${yearKey}/buses`
          ] : [];
          const [
            enrollScopedSnap,
            enrollLegacySnap,
            registryScopedSnap,
            registryLegacySnap,
            assignmentsScopedSnap,
            assignmentsLegacySnap,
            vehiclesSnap,
            ...legacyBusesSnaps
          ] = await Promise.all([
            schoolRef(`years/${yearKey}/transportEnrollments`).once('value'),
            isLegacyMerge ? db.ref('transport_enrollments').once('value') : Promise.resolve(null),
            schoolRef(`years/${yearKey}/transportRegistry`).once('value').catch(() => ({ val: () => null })),
            isLegacyMerge ? db.ref(`transportRegistry/${yearKey}`).once('value').catch(() => ({ val: () => null })) : Promise.resolve(null),
            schoolRef(`years/${yearKey}/transportAssignments`).once('value').catch(() => ({ val: () => null })),
            isLegacyMerge ? db.ref(`transportAssignments/${yearKey}`).once('value').catch(() => ({ val: () => null })) : Promise.resolve(null),
            schoolRef(`years/${yearKey}/transport/buses`).once('value'),
            ...legacyBusesPaths.map(p => db.ref(p).once('value').catch(() => ({ val: () => null })))
          ]);

          const scopedEnrollments = (enrollScopedSnap && typeof enrollScopedSnap.val === 'function') ? (enrollScopedSnap.val() || {}) : {};
          const legacyEnrollmentsRaw = (enrollLegacySnap && typeof enrollLegacySnap.val === 'function') ? (enrollLegacySnap.val() || {}) : {};
          const legacyEnrollments = isLegacyMerge ? { ...legacyEnrollmentsRaw, ...scopedEnrollments } : scopedEnrollments;

          const scopedRegistry = (registryScopedSnap && typeof registryScopedSnap.val === 'function') ? (registryScopedSnap.val() || {}) : {};
          const legacyRegistry = (registryLegacySnap && typeof registryLegacySnap.val === 'function') ? (registryLegacySnap.val() || {}) : {};
          const registry = isLegacyMerge ? { ...legacyRegistry, ...scopedRegistry } : scopedRegistry;

          const scopedAssignments = (assignmentsScopedSnap && typeof assignmentsScopedSnap.val === 'function') ? (assignmentsScopedSnap.val() || {}) : {};
          const legacyAssignments = (assignmentsLegacySnap && typeof assignmentsLegacySnap.val === 'function') ? (assignmentsLegacySnap.val() || {}) : {};
          const assignments = isLegacyMerge ? { ...legacyAssignments, ...scopedAssignments } : scopedAssignments;
          state.transportAssignments = assignments || {};
          state.transportEnrollments = {};

          // Always load legacy enrollments, then let year-scoped assignments override them.
          Object.entries(legacyEnrollments).forEach(([studentId, enrollment]) => {
            if (enrollment) state.transportEnrollments[studentId] = enrollment;
          });

          // Merge registry-based enrollments (if used in this school/year).
          Object.entries(registry).forEach(([studentId, reg]) => {
            if (!reg || reg.using !== true) return;
            if (!state.transportEnrollments[studentId]) {
              state.transportEnrollments[studentId] = {
                amStop: reg.routeId || '',
                pmStop: reg.stopName || '',
                monthlyFee: reg.monthlyFee || 0
              };
            }
          });

          Object.entries(assignments).forEach(([studentId, assignRecord]) => {
            if (!assignRecord || assignRecord.status !== 'Using') {
              // If a student exists in legacy but is marked not using in assignments, remove.
              if (state.transportEnrollments[studentId]) {
                delete state.transportEnrollments[studentId];
              }
              return;
            }
            const existing = state.transportEnrollments[studentId] || {};
            const amStop = assignRecord.morningRouteId || assignRecord.amStop || existing.amStop || '';
            const pmStop = assignRecord.eveningRouteId || assignRecord.pmStop || existing.pmStop || '';
            const route = assignRecord.route || existing.route || amStop || pmStop || '';
            const period = amStop && pmStop ? 'both' : (amStop ? 'morning' : (pmStop ? 'evening' : ''));
            state.transportEnrollments[studentId] = {
              ...existing,
              ...assignRecord,
              amStop,
              pmStop,
              route,
              period: assignRecord.period || existing.period || period,
              baseMonthlyFee: assignRecord.baseMonthlyFee || existing.baseMonthlyFee,
              startDate: assignRecord.startDate || existing.startDate,
            };
          });
          
          // Process vehicles (merge scoped + legacy paths)
          state.vehicles = {};
          const mergeBusesFromSnap = (snap) => {
            if (!snap || !snap.val) return;
            const val = typeof snap.val === 'function' ? snap.val() : snap.val;
            if (!val || typeof val !== 'object') return;
            Object.entries(val).forEach(([key, v]) => {
              if (v && !state.vehicles[key]) {
                state.vehicles[key] = { id: key, ...(v || {}) };
              }
            });
          };
          mergeBusesFromSnap(vehiclesSnap);
          (legacyBusesSnaps || []).forEach(mergeBusesFromSnap);

          // Load drivers (with caching)
          await loadDriversCached();

          // Load payments in background (needed for KPI calculations)
          // Use same data source as transportpayments.html (transportLedgers)
          const year = String(state.year);
          
          Promise.all([
            scopedOrSocratesLegacy(`years/${year}/transportLedgers`, `transportLedgers/${year}`).catch(() => ({ val: () => null })),
            scopedOrSocratesLegacy(`years/${year}/transport_payments`, 'transport_payments').catch(() => ({ val: () => null }))
          ]).then(([ledgersSnap, legacySnap]) => {
            // New format: transportLedgers/{year}/{studentId}/payments
            const paymentsData = {};
            const ledgers = ledgersSnap.val() || {};
            Object.entries(ledgers).forEach(([studentId, ledger]) => {
              if (ledger && ledger.payments) {
                paymentsData[studentId] = Object.values(ledger.payments);
              }
            });
            
            // Also check legacy path for backward compatibility
            const legacyPayments = legacySnap.val() || {};
            Object.entries(legacyPayments).forEach(([studentId, payments]) => {
              if (!paymentsData[studentId]) {
                paymentsData[studentId] = Array.isArray(payments) ? payments : Object.values(payments || {});
              }
            });
            
            state.transportPayments = paymentsData;
            renderKpis(); // Re-render KPIs when payments load
          }).catch(err => {
            console.warn('Failed to load payments:', err);
            state.transportPayments = {};
            renderKpis();
          });

          // Render UI immediately with available data
          renderKpis();
        } catch (error) {
          console.error('Error loading critical data:', error);
          showToast('Error loading data', 'bad');
          kpiRowEl.innerHTML = '<article class="card stat-card"><div class="stat-label">Error</div><div class="stat-value">‚ùå</div></article>';
        }
      }

      // Load drivers with caching
      async function loadDriversCached() {
        const now = Date.now();
        if (driversCache && (now - driversCacheTime) < DRIVERS_CACHE_TTL) {
          state.drivers = driversCache;
          return;
        }

        try {
          const workersSnap = await scopedOrSocratesLegacy('workers', 'workers');
          state.drivers = [];
          if (workersSnap.exists()) {
            workersSnap.forEach(workerSnap => {
              const worker = workerSnap.val();
              if (worker.profile && worker.profile.role === 'driver' && worker.profile.active !== false) {
                state.drivers.push({
                  id: workerSnap.key,
                  fullName: worker.profile.fullNameUpper || `${worker.profile.firstName} ${worker.profile.middleName} ${worker.profile.lastName}`,
                  phone: worker.profile.phone,
                  firstName: worker.profile.firstName,
                  middleName: worker.profile.middleName,
                  lastName: worker.profile.lastName
                });
              }
            });
          }
          driversCache = state.drivers;
          driversCacheTime = now;
        } catch (error) {
          console.warn('Error loading drivers:', error);
          state.drivers = driversCache || [];
        }
      }

      // Lazy load students data (only when needed) - year-scoped
      let studentsLoaded = false;
      let studentsLoadedForYear = null;
      async function loadStudentsIfNeeded() {
        const yearKey = String(state.year);
        if (studentsLoaded && studentsLoadedForYear === yearKey && Object.keys(state.students).length > 0) {
          return; // Already loaded for this year
        }

        try {
          const [scopedSnap, enrollYearsSnap, enrollLegacySnap] = await Promise.all([
            schoolRef('students').once('value'),
            schoolRef(`years/${yearKey}/enrollments`).once('value'),
            isSocratesSchool(schoolId) ? db.ref(`enrollments/${yearKey}`).once('value') : Promise.resolve({ val: () => null })
          ]);

          let merged = scopedSnap.val() || {};
          if (isSocratesSchool(schoolId)) {
            const legacySnap = await db.ref('students').once('value');
            const legacyVal = legacySnap.val() || {};
            merged = { ...legacyVal, ...merged };
          }

          const yearEnroll = (enrollYearsSnap.val && enrollYearsSnap.val()) || {};
          const legacyEnroll = (enrollLegacySnap && typeof enrollLegacySnap.val === 'function' && enrollLegacySnap.val()) || {};
          state.yearEnrollments = { ...legacyEnroll, ...yearEnroll };

          const baseStudents = Object.fromEntries(
            Object.entries(merged || {}).filter(([, student]) => {
              const status = String(student?.status || '').trim().toLowerCase();
              return status !== 'shifted';
            })
          );

          // Filter: only students enrolled in selected year (not graduated)
          const getRegistrationYear = (stu) => {
            const ts = stu?.timestamp ?? stu?.createdAt;
            if (ts && Number.isFinite(ts)) return new Date(ts).getFullYear();
            return null;
          };
          const resolveClassForYear = (studentId, fallbackClass, stuObj) => {
            const override = state.yearEnrollments?.[studentId];
            if (override && (override.className || override.classLevel)) {
              return override.className || override.classLevel;
            }
            const baseClass = fallbackClass || '';
            const regYear = getRegistrationYear(stuObj);
            if (!regYear || !Number.isFinite(Number(yearKey))) return baseClass || 'N/A';
            const delta = Number(yearKey) - regYear;
            return shiftClass(baseClass, delta);
          };

          state.students = {};
          Object.entries(baseStudents).forEach(([id, student]) => {
            const enroll = state.yearEnrollments[id];
            const resolvedClass = resolveClassForYear(id, student.classLevel || student.className, student);
            if (resolvedClass === 'GRADUATED') return; // Exclude graduated students for this year
            if (enroll && (enroll.className === 'GRADUATED' || enroll.classLevel === 'GRADUATED')) return;
            state.students[id] = { ...student, _resolvedClass: resolvedClass };
          });

          // Load finance data via SomapFinance (year-scoped) when available
          state.financeData = {};
          if (typeof window.SomapFinance?.loadStudentFinance === 'function') {
            const ids = Object.keys(state.students);
            const results = await Promise.all(ids.map(async (id) => {
              try {
                const fin = await window.SomapFinance.loadStudentFinance(yearKey, id);
                return [id, { feePerYear: fin.due ?? fin.feePerYear ?? 0, payments: {}, paidAmount: fin.paid ?? 0, debtTill: '‚Äî' }];
              } catch (_) {
                return [id, { feePerYear: 0, payments: {}, debtTill: '‚Äî' }];
              }
            }));
            results.forEach(([id, data]) => { state.financeData[id] = data; });
          } else {
            Object.entries(state.students).forEach(([id, student]) => {
              state.financeData[id] = {
                feePerYear: student.feePerYear || 0,
                payments: student.payments || {},
                debtTill: student.debtTill || '‚Äî',
              };
            });
          }

          studentsLoaded = true;
          studentsLoadedForYear = yearKey;

          renderKpis();
        } catch (error) {
          console.error('Error loading students:', error);
          state.students = {};
          state.financeData = {};
          state.yearEnrollments = {};
        }
      }

      // Load all data (backward compatibility)
      async function loadAllData() {
        await loadCriticalData();
        await loadStudentsIfNeeded();
      }

      // Auth and initialization
      function ensureAuth(callback) {
        firebase.auth().onAuthStateChanged((user) => {
          if (!user) {
            alertsEl.innerHTML =
              '<div class="alert red">üîí Sign in to view Transport Hub.</div>';
            return;
          }
          
          state.user = user;
          
          // Check if TransportRoles is available
          if (typeof TransportRoles === 'undefined') {
            console.warn('TransportRoles module not loaded, defaulting to admin access');
            state.role = "admin";
            alertsEl.innerHTML =
              '<div class="alert amber">‚ö†Ô∏è Permission module not loaded. Proceeding with default access.</div>';
            callback();
            return;
          }

          firebase
            .database()
            .ref(`users/${user.uid}/role`)
            .get()
            .then((snapshot) => {
              const roleRaw = snapshot.val();
              state.role = TransportRoles.normalize(roleRaw);
              
              if (!TransportRoles.canViewTransport(state.role)) {
                alertsEl.innerHTML =
                  '<div class="alert warn">‚ö†Ô∏è No transport permissions for this account. Please contact your administrator.</div>';
                return;
              }
              
              alertsEl.innerHTML = "";
              callback();
            })
            .catch((err) => {
              console.error('Error verifying permissions:', err);
              // If we can't verify permissions, default to allowing access but show a warning
              state.role = "admin"; // Default to admin role
              alertsEl.innerHTML =
                '<div class="alert amber">‚ö†Ô∏è Could not verify permissions. Proceeding with default access. If you experience issues, please refresh the page.</div>';
              // Still call callback to allow the page to load
              setTimeout(() => {
                callback();
              }, 500);
            });
        });
      }

      // Initialize
      ensureAuth(() => {
        maybeAutoAdvanceYear();
        maybeRunRollover();
        // Render start cards immediately (no data needed)
        renderStartCards();
        // Load critical data (this will render KPIs when ready)
        loadCriticalData();
        // Preload students in background (they'll load when modal opens anyway)
        setTimeout(() => loadStudentsIfNeeded(), 1000);
      });
    </script>
  </body>
</html>
